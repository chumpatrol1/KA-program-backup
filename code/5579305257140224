/**************************************
 * Build an animation of a lamp
 * Then save it to create an animation
**************************************/

var BACKGROUND = color(250, 250, 250);
var RED = color(200, 0, 0);
var BLUE = color(64, 95, 237);
var SKYBLUE = color(82, 115, 173);
var PINK = color(255, 0, 175);
var PINK_T = color(255, 0, 175, 80);
var GREEN = color(28, 173, 123);
var ORANGE = color(255, 165, 0);
var GREY = color(140, 140, 140);
var CS_GREEN = color(67, 122, 57);
var GRIDGREY = color(230, 240, 230);
var TEXTCOL = color(20, 20, 20);
var TOOLBAR = color(235, 235, 235, 240);

var RESOLUTION = 4;

var setup = false;

var sansFont = createFont("sans", 24);
var serifFont = createFont("serif", 24);

frameRate(24);
var FRAMES = 24;

var modelData = {
    x: 400,
    y: 75,
    shapes: {
        base: {
            origin: [200, 350],
            fill: color(225, 230, 235),
            stroke: color(200, 200, 200),
            vertices: [[136,350],[264,350],[260,335],[208,335],[208,320],[192,320],[192,335],[140,335]]
        },
        arm1: {
            origin: [200, 328],
            fill: color(225, 230, 235),
            stroke: color(200, 200, 200),
            vertices: [[200,337],[190,327],[270,247],[280,257]]
        },
        arm2: {
            origin: [270, 257],
            fill: color(225, 230, 235),
            stroke: color(200, 200, 200),
            vertices: [[280,257],[270,267],[190,187],[200,177]]
        },
        lamp: {
            origin: [203,194],
            fill: color(225, 230, 235),
            stroke: color(200, 200, 200),
            vertices: [[180,197],[200,177],[220,197],[200,217],[180,277],[120,217]]
        }
    },
    connections: ['base->arm1', 'arm1->arm2', 'arm2->lamp'],
    deformers: [
        ['translateX', 'base'],
        ['translateY', 'base'],
        ['rotate', 'arm1'],
        ['rotate', 'arm2'],
        ['rotate', 'lamp'],
        ['scale', 'lamp'],
    ]
};

var removeButton, speedSlider;

/********************************************************
 *      Handy functions
*********************************************************/
var cubicSpline = function(p1, p2, m1, m2, t) {
    var t2 = t * t;
    var t3 = t * t2;
    
    var a = -1 * t3 + 3 * t2 - 3 * t + 1;
    var b = t3;
    var c =  3 * t3 - 6 * t2 + 3 * t;
    var d = -3 * t3 + 3 * t2;
    
    return {
        x: p1.x * a + p2.x * b + m1.x * c + m2.x * d,
        y: p1.y * a + p2.y * b + m1.y * c + m2.y * d
    };
};

var removeFromArray = function(arr, el) {
    var index = arr.indexOf(el);
    if (index > -1) {
        arr.splice(index, 1);
    }
};

var callFunctionForEach = function(arr, func) {
    for (var i = 0; i < arr.length; i++) {
        arr[i][func]();
    }
};

/********************************************************
 *      Slider object
*********************************************************/
{
var Slider = function(x, y, length, orientation, minValue, maxValue, nowValue, name, updateF) {
    this.x = x;
    this.y = y;
    this.length = length;
    this.orientation = orientation;
    
    if (this.orientation === 'vertical') {
        this.start = y;
        this.end = y + this.length;
        this.v1 = this.end;
        this.v2 = this.start;
    } else {
        this.start = x;
        this.end = x + this.length;
        this.v1 = this.start;
        this.v2 = this.end;
    }
    
    this.name = name;
    this.updateFunction = updateF;
    
    this.ballR = 8;
    this.ballD = this.ballR * 2;
    
    this.min = minValue;
    this.max = maxValue;
    this.value = nowValue || minValue;
    this.setValue(this.value);

    this.held = false;
};

Slider.prototype.draw = function() {
    if (this.name) {
        textAlign(CENTER, CENTER);
        fill(10);
        textSize(13);
        text(this.name + ": " + this.value,  this.x + this.length / 2, this.y - 15);
    }
    
    strokeWeight(3);
    stroke(GREY);
    if (this.orientation === 'vertical') {
        line(this.x, this.y, this.x, this.end);
    } else {
        line(this.x, this.y, this.end, this.y);
    }
    
    strokeWeight(1);
    stroke(BACKGROUND);
    fill(ORANGE);
    if (this.orientation === 'vertical') {
        ellipse(this.x, this.ball, this.ballD, this.ballD);
    } else {
        ellipse(this.ball, this.y, this.ballD, this.ballD);
    }
    
};

Slider.prototype.mouseOver = function() {
    if (mouseX >= this.x - this.ballR &&
        mouseY >= this.y - this.ballR) {
        if (this.orientation === 'vertical') {
            return mouseX <= this.x + this.ballR &&
                   mouseY <= this.end + this.ballR;
        } else {
            return mouseX <= this.end + this.ballR &&
                   mouseY <= this.y + this.ballR;
        }   
    }
};
    
Slider.prototype.mousePressed = function() {
    if (this.orientation === 'vertical') {
        this.held = dist(mouseX, mouseY, this.x, this.ball) <= this.ballR;
    } else {
        this.held = dist(mouseX, mouseY, this.ball, this.y) <= this.ballR;
    }
    if (!this.held && this.mouseOver()) {
        this.setBallPosition();
    }
};
    
Slider.prototype.mouseDragged = function() {
    if (this.held) {
        this.setBallPosition();
        return true;
    }
};

Slider.prototype.mouseReleased = function() {
    this.held = false;
};

Slider.prototype.setBallPosition = function() {
    var value = this.orientation === 'vertical' ? mouseY : mouseX;
    this.ball = constrain(value, this.start, this.end);
    this.setValue();
};

Slider.prototype.setValue = function(d) {
    if (d !== undefined) {
        this.value = constrain(d, this.min, this.max);
    } else {
        
        this.value = round(map(this.ball, this.v1, this.v2, this.min, this.max));
        this.update();
    }
    this.ball = map(this.value, this.min, this.max, this.v1,  this.v2);
};

Slider.prototype.update = function() {
    if (this.updateFunction) {
        this.updateFunction(this.value);
    }
};
}
/********************************************************
 * Generic GUI component from which other elements inherit
 * The default object is basically a button.
*********************************************************/
{
var GUI_Component = function(x, y, w, h, name, updateFunction) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    
    this.name = name;
    this.updateFunction = updateFunction;
    
    this.showing = true;
    this.selected = false;
    this.disabled = false;
};

GUI_Component.prototype.draw = function() {
    if (!this.showing) { return; }
    
    if (this.mouseOver()) {
        fill(100);
    } else {
        fill(200);
    }
    
    noStroke();
    rect(this.x, this.y, this.w, this.h, 12);
    
    fill(TEXTCOL);
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2 + 1);
};

GUI_Component.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h);
};

GUI_Component.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
};

GUI_Component.prototype.mouseDragged = function() {};

GUI_Component.prototype.mouseReleased = function() {
    if (this.selected && this.showing && !this.deactivated && this.mouseOver()) {
        this.trigger();
    }
    this.selected = false;
};

GUI_Component.prototype.trigger = function() {
    if (this.updateFunction) {
        this.updateFunction();
    }
};

GUI_Component.prototype.deactivationCondition = function() {
    if (this.deactivationFunction) {
        this.deactivated = this.deactivationFunction();
    }
};
}
/********************************************************
 *          GUI Button
*********************************************************/
{
var Button = function(x, y, w, h, name, updateFunction) {
    GUI_Component.call(this, x, y, w, h, name, updateFunction);

    this.defaultCol = TOOLBAR;
    this.highlightCol = color(210, 210, 210, 250);
    this.transition = 0;
};
Button.prototype = Object.create(GUI_Component.prototype);

Button.prototype.draw = function() {
    if (!this.showing) { return; }
    
    this.fade();
    this.deactivationCondition();
    
    if (this.deactivated) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(200);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 12);
    
    if (this.deactivated) {
        fill(120);
    } else {
        fill(TEXTCOL);
    }
    
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2 + 1);
};

Button.prototype.fade = function() {
    if (this.mouseOver() || this.selected) {
        this.transition = min(10, this.transition + 1);
    } else {
        this.transition = max(0, this.transition - 1);
    }
};

var FilledButtonDraw = function() {
    if (!this.showing) { return; }
    
    this.fade();
    this.deactivationCondition();
    
    if (this.deactivated) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(this.highlightCol);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 19);
    
    if (this.deactivated) {
        fill(120);
    } else {
        fill(lerpColor(this.highlightCol, color(255, 255, 255), this.transition / 10));
    }
    
    textFont(sansFont, 16);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2);
};

Button.prototype.makeFilled = function(col) {
    this.draw = FilledButtonDraw.bind(this);
    this.defaultCol = color(0, 0, 0, 1);
    this.highlightCol = col;
};

// Circular button
var CircleButton = function(x, y, w, h, clickFunction, drawFunction) {
    Button.call(this, x, y, w, h, "", clickFunction);
    this.drawIcon = drawFunction;
};
CircleButton.prototype = Object.create(Button.prototype);

CircleButton.prototype.draw = function() {
    var c;
    if (this.mouseOver()) {
        c = color(40, 40, 40);
        fill(TOOLBAR);
    } else {
        c = color(140, 140, 140);
        noFill();
    }
    
    var x = this.x + this.w / 2;
    var y = this.y + this.w / 2;
    stroke(c);
    strokeWeight(2);
    ellipse(x, y, this.w, this.w);
    
    if (this.drawIcon) {
        fill(c);
        this.drawIcon(x, y, this.w / 2);   
    }
};
}
/*******************************************************
 *          Draggable point
********************************************************/
{
var DraggablePoint = function(x, y, color) {
    this.x = x;
    this.y = y;
    this.r = 14;
    this.color = color || ORANGE;
    this.animation = 0;
    this.selected = false;
};

DraggablePoint.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.x, this.y) <= this.r;
};

DraggablePoint.prototype.move = function() {
    this.x += mouseX - pmouseX;
    this.y += mouseY - pmouseY;
    this.onMove();
};

DraggablePoint.prototype.onMove = function() {
    // To be overwritten
};

DraggablePoint.prototype.draw = function() {
    if (this.selected || (!this.selected && this.mouseOver())) {
        if (this.animation < 5) {
            this.animation++;
        }
    } else {
        this.animation = 0;
    }

    stroke(BACKGROUND);
    strokeWeight(1);
    fill(this.color);
    
    var r = this.r + this.animation;
    ellipse(this.x, this.y, r, r);
    
    if (this.selected) {
        noFill();
        stroke(BACKGROUND);
        ellipse(this.x, this.y, r - 4, r - 4);
    }
};

var ConstrainedPoint = function(x, y, rangeX, rangeY, color) {
    DraggablePoint.call(this, x, y, color);
    this.minX = rangeX[0];
    this.maxX = rangeX[1];
    this.minY = rangeY[0];
    this.maxY = rangeY[1];
};
ConstrainedPoint.prototype = Object.create(DraggablePoint.prototype);

ConstrainedPoint.prototype.move = function() {
    this.x = constrain(this.x + mouseX - pmouseX, this.minX, this.maxX);
    this.y = constrain(this.y + mouseY - pmouseY, this.minY, this.maxY);
    this.onMove();
};

ConstrainedPoint.prototype.moveBy = function(dx, dy) {
    this.x = constrain(this.x + dx, this.minX, this.maxX);
    this.y = constrain(this.y + dy, this.minY, this.maxY);
};
}
/*******************************************************
 *          KeyFrame
 * A point representing the value of an avar at a given
 * keyframe.
 * It can be moved vertically to change the value.
********************************************************/
{
var KeyFrame = function(frame, value, avar, fixed) {
    this.frame = frame;
    this.value = value;
    this.avar = avar;
    this.fixed = fixed;
    this.color = ORANGE;
    this.animation = 0;
    this.r = 14;
    this.frameSelector = this.avar.timeline.frameSelector;
    
    this.handles = [];
    this.frameSets = [];
    this.setPosition();
};

KeyFrame.prototype = Object.create(DraggablePoint.prototype);

KeyFrame.prototype.setPosition = function() {
    this.x = this.avar.frameToXPosition(this.frame);
    this.y = this.avar.valueToYPosition(this.value);
};

KeyFrame.prototype.drawWithHandles = function() {
    for (var i = 0; i < this.handles.length; i++) {
        var handle = this.handles[i];
        if (!handle.hide) {
            strokeWeight(2);
            stroke(handle.color + (100 << 24));
            line(handle.x, handle.y, this.x, this.y);
            handle.draw();
        }
    }
    this.draw();
};

KeyFrame.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.x, this.y) <= this.r + 1;
};

KeyFrame.prototype.move = function() {
    this.y = constrain(this.y + mouseY - pmouseY, this.avar.y2, this.avar.y1);
    this.value = this.avar.yPositionToValue(this.y);
    
    // Drag keyframe to next frame
    // Overwrite any existing keyframe there
    var mouseFrame = this.frameSelector.mapMouseToFrame();
    if (!this.fixed && this.frame !== mouseFrame) {
        var existing = this.avar.isKeyFrame(mouseFrame);
        if (existing) {
            if (existing.fixed) {
                this.fixed = true;
            }
            this.avar.removeKeyFrame(existing);
        }
        
        var dx = (mouseFrame - this.frame) * this.avar.dx;
        this.frame = mouseFrame;
        this.setPosition();
        
        for (var i = 0; i < this.frameSets.length; i++) {
            this.frameSets[i].updateConstraints();
        }
        
        // Move handle positions
        for (var i = 0; i < this.handles.length; i++) {
            this.handles[i].moveBy(dx, 0);
        }
    }
    
    this.updateFrameSets();
};

KeyFrame.prototype.updateFrameSets = function() {
    for (var i = 0; i < this.frameSets.length; i++) {
        this.frameSets[i].updateValues();
    }
};
}
/*******************************************************
 *          FrameSet
 * A set of frames between two keyframes (inclusive).
********************************************************/
{
var FrameSet = function(kf1, kf2, avar) {
    this.kfs = [kf1, kf2];
    this.handles = [];
    this.avar = avar;
    this.x1 = kf1.x;
    this.x2 = kf2.x;
    this.y1 = avar.y2;
    this.y2 = avar.y1;
    
    this.updateKeyFrames();
};

FrameSet.prototype.updateKeyFrames = function() {
    var dx = this.x2 - this.x1;
    var y1 = this.kfs[0].y;
    var y2 = this.kfs[1].y;
    
    var d = abs(dx) * 0.2;
    var angle = atan2(y2 - y1, dx);
    
    var constrainX = [this.x1, this.x2];
    var constrainY = [this.y1, this.y2];
    
    var handles = [
        new ConstrainedPoint(
            this.x1 + d * cos(angle),
            y1 + d * sin(angle),
            constrainX, constrainY,
            PINK
        ),
        new ConstrainedPoint(
            this.x2 - d * cos(angle),
            y2 - d * sin(angle),
            constrainX, constrainY,
            PINK
        )
    ];
    
    for (var i = 0; i < 2; i++) {
        var kf = this.kfs[i];
        // Attach this frameSet to each keyFrame
        kf.frameSets.push(this);
        
        // Add new handle if required
        if (kf.handles.length < kf.frameSets.length) {
            handles[i].onMove = kf.updateFrameSets.bind(kf);
            kf.handles.push(handles[i]);
            this.handles.push(handles[i]);
        } else {
            // Update constraints on existing handles
            var index = kf.handles.length > 1 ? 1 - i : 0;
            var handle = kf.handles[index];
            handle.minX = this.x1;
            handle.maxX = this.x2;
            handle.moveBy(0, 0);
            this.handles.push(handle);
        }
    }
    
    this.updateValues();
};

FrameSet.prototype.getValues = function(gap) {
    var p1 = this.kfs[0];
    var p2 = this.kfs[1];
    var m1 = this.handles[0];
    var m2 = this.handles[1];
    var values = [p1.value];
    
    if (this.frameLength === 1) {
        m1 = p2;
        m2 = p1;
    }
    
    // How many points are used in this frameSet for drawing the line
    var points = this.frameLength * RESOLUTION * gap;
    
    var dx = this.avar.dx / gap;
    var x = this.avar.frameToXPosition(p1.frame) + dx;
    var y = p1.value;
    var minD = abs(x - p1.x);
    
    for (var i = 0; i < points; i++) {
        var p = cubicSpline(p1, p2, m1, m2, i / points);
        
        if (i) {
            // Distance between calculated x and real x
            var difference = abs(x - p.x);
            
            // Distance will increase up to a point,
            // then we'll go past it
            // Use the closest value of x we find
            if (difference > minD) {
                values.push(y);
                x += dx;
                minD = abs(x - p.x);
            } else {
                minD = difference;
            }
            
            y = this.avar.yPositionToValue(p.y);
        }
    }

    // Last value is equal to the last keyPose value
    values.push(p2.value);
    return values;
};

FrameSet.prototype.updateValues = function() {
    // Use getValues for most of this
    
    var p1 = this.kfs[0];
    var p2 = this.kfs[1];
    var m1 = this.handles[0];
    var m2 = this.handles[1];
    
    // Total number of frames in this frameSet
    this.frameLength = p2.frame - p1.frame;
    
    // Hide control points if frameSet is only one frame long 
    m1.hide = (this.frameLength === 1);
    m2.hide = (this.frameLength === 1);
    
    // How many points are used in this frameSet for drawing the line
    var points = this.frameLength * RESOLUTION;
    var values = this.avar.values;
    
    // First value is equal to the first keyPose value
    var frameNumber = p1.frame;
    values[frameNumber++] = p1.value;
    
    var x = this.avar.frameToXPosition(frameNumber);
    var y = p1.value;
    var minD = abs(x - p1.x);
    
    if (this.frameLength > 1) {
        for (var j = 0; j < points; j++) {
            var p = cubicSpline(p1, p2, m1, m2, j / points);
            
            if (j) {
                // Distance between calculated x and real x
                var dx = abs(x - p.x);
                
                // Distance will increase up to a point, then we'll go past it
                // Use the closest value of x we find
                if (dx > minD) {
                    values[frameNumber++] = y;
                    x += this.avar.dx;
                    minD = abs(x - p.x);
                } else {
                    minD = dx;
                }
                
                y = this.avar.yPositionToValue(p.y);
            }
        }
    }

    // Last value is equal to the last keyPose value
    values[frameNumber] = p2.value;
};

FrameSet.prototype.updateConstraints = function() {
    for (var i = 0; i < this.handles.length; i++) {
        this.handles[i].minX = this.kfs[0].x;
        this.handles[i].maxX = this.kfs[1].x;
        this.handles[i].moveBy(0, 0);
    }
};

FrameSet.prototype.draw = function() {
    strokeWeight(2);
    stroke(BLUE);
    noFill();
    
    // Just draw a line if the frameSet is one frame long
    if (this.frameLength === 1) {
        line(this.kfs[0].x, this.kfs[0].y,
             this.kfs[1].x, this.kfs[1].y);
        return;
    }
    
    // Interpolated line
    bezier(this.kfs[0].x, this.kfs[0].y,
           this.handles[0].x, this.handles[0].y,
           this.handles[1].x, this.handles[1].y,
           this.kfs[1].x, this.kfs[1].y
    );
};

FrameSet.prototype.mouseOver = function() {
    return mouseY >= this.y1 && mouseY <= this.y2 && 
           mouseX >= this.x1 && mouseX <= this.x2;
};
}
/*******************************************************
 *          Frame selector
 * A slider allowing the user to select a frame
********************************************************/
{
var FrameSelector = function(timeline, maxFrames) {
    this.timeline = timeline;
    this.x = timeline.x;
    this.y = timeline.y;
    this.x2 = this.x - timeline.labelW;
    this.dx = timeline.dx;
    this.w = (maxFrames + 1) * this.dx;
    
    this.r = 9;
    this.d = this.r * 2; 
    this.by = this.y - this.r;
    this.maxFrames = maxFrames;
    this.held = false;
    
    this.setBallPosition();
    this.mouseOverFrame = -1;
};

FrameSelector.prototype.draw = function() {
    this.mouseOverFrame = this.mapMouseToFrame();
    if (this.mouseOver() &&
        this.mouseOverFrame !== this.timeline.currentFrame) {
            strokeWeight(2);
            stroke(ORANGE);
            noFill();
            var x = this.x + (this.mouseOverFrame + 0.5) * this.dx;
            ellipse(x, this.by, this.d, this.d);
    }
    
    // Frame counter
    strokeWeight(1);
    stroke(GREY);
    fill(TEXTCOL);
    textSize(12);
    
    textAlign(LEFT, BASELINE);
    text("Frame:", this.x2, this.y - 3);
    
    textSize(11);
    textAlign(CENTER, BASELINE);
    for (var i = 0; i <= this.maxFrames; i++) {
        var x = this.x + (i + 0.5) * this.dx;
        line(x, this.y, x, this.y - 3);
        text(i + 1, x, this.y - 5);
    }
    
    // Line over the avar boxes
    strokeWeight(1);
    stroke(200);
    line(this.bx, this.y, this.bx, this.y + this.timeline.h);
    
    // Selector ball
    fill(ORANGE);
    stroke(BACKGROUND);
    ellipse(this.bx, this.by, this.d + 1, this.d + 1);
    
    fill(TEXTCOL);
    textSize(11);
    textAlign(CENTER, CENTER);
    text(this.timeline.currentFrame + 1, this.bx, this.by);
    
    strokeWeight(1);
    stroke(GREY);
    line(this.x2, this.y, this.x + this.w, this.y);
};

FrameSelector.prototype.setBallPosition = function() {
    this.bx = this.x + (this.timeline.currentFrame + 0.5) * this.dx;
};

FrameSelector.prototype.mousePressed = function() {
    this.held = dist(mouseX, mouseY, this.bx, this.by) <= this.r;
};

FrameSelector.prototype.mouseDragged = function() {
    if (this.held) {
        this.updateFrame(this.mapMouseToFrame());
        return true;
    }
};

FrameSelector.prototype.mouseOver = function() {
    return mouseX > this.x && mouseX < this.x + this.w &&
           mouseY < this.y && mouseY > this.y - this.d;
};

FrameSelector.prototype.mouseReleased = function() {
    // Clicking on frame moves to that frame
    if (this.mouseOver()) {
        this.updateFrame(this.mapMouseToFrame());
    }
    this.held = false;
};

FrameSelector.prototype.mapMouseToFrame = function() {
    var f = map(mouseX + 2, this.x, this.x + this.w, 0, this.maxFrames + 1);
    return constrain(floor(f), 0, this.maxFrames);
};

FrameSelector.prototype.updateFrame = function(frame) {
    // Move to a new frame based on the mouse position
    this.timeline.currentFrame = frame;
    this.setBallPosition();
    this.timeline.scene.update();
};
}
/*******************************************************
 *          Deformer
 * An avar that controls a set of shapes.
 * Changing the value of a deformer applies a
 * transformation based on an origin and a direction.
*******************************************************/
var deformers = {
    translateX: {
        id: 'Tx', min: -500, max: 500,
        transform: function(coord, origin, value) {
            coord.x += value;
        }
    },
    translateY: {
        id: 'Ty', min: -200, max: 200,
        transform: function(coord, origin, value) {
            coord.y -= value;
        }
    },
    scale: {
        id: 'S', min: 0.2, max: 3, value: 1,
        transform: function(coord, origin, value) {
            coord.x = (coord.x - origin.x) * value + origin.x;
            coord.y = (coord.y - origin.y) * value + origin.y;
        }
    },
    rotate: {
        id: 'R', min: -180, max: 180,
        transform: function(coord, origin, value) {
            var cosAngle = cos(value);
            var sinAngle = sin(value);
            var x = coord.x - origin.x;
            var y = coord.y - origin.y;
            
            coord.x = origin.x + x * cosAngle - y * sinAngle;
            coord.y = origin.y + x * sinAngle + y * cosAngle;
        }
    }
};
/*******************************************************
 *          Avar
 * An animation variable which controls a deformer
 * Each variable has a value for each frame.
 * Values are determined by keyframes and interpolation
 * between these frames.
*******************************************************/
{
var Avar = function(timeline, name, deformer, shape, model) {
    this.timeline = timeline;
    this.name = name;
    this.transform = deformer.transform;
    this.min = deformer.min;
    this.max = deformer.max;
    this.shape = shape;
    this.model = model;
    
    var value = deformer.value || 0;
    this.keyFrames = [];
    this.frameSets = [];
    this.values = [];
    
    this.frameCount = timeline.frameCount;
    this.x = timeline.x;
    this.y = timeline.avarY;
    this.w = timeline.w;
    this.w2 = timeline.labelW;
    this.x2 = this.x - this.w2;
    this.h = timeline.dy;
    
    this.dx = this.w / this.frameCount;
    var padding = 10;
    this.y1 = this.y + this.h - padding;
    this.y2 = this.y + padding;
    
    this.selected = false;
    this.dragging = false;
    this.toAddKeyFrame = false;
    
    this.addKeyFrame(0, value, true);
    this.addKeyFrame(this.frameCount - 1, value, true);
    this.addFrameSet(0);
};

Avar.prototype.draw = function(f) {
    // Lower border line
    strokeWeight(1);
    stroke(GREY);
    noFill();
    line(this.x2, this.y + this.h, this.x + this.w, this.y + this.h);
    
    // Label
    noStroke();
    fill(224);
    rect(this.x2, this.y + 1, this.w2, this.h - 1);
    
    // Current avar value
    textAlign(CENTER, BASELINE);
    textFont(serifFont, 16);
    fill(TEXTCOL);
    text(this.name, this.x - this.w2 / 2, this.y + this.h / 2 - 4);
    
    textAlign(CENTER, TOP);
    textFont(sansFont, 12);
    text(round(this.values[f]), this.x - this.w2 / 2, this.y + this.h / 2 + 1);
    
    for (var i = 0; i < this.frameSets.length; i++) {
        this.frameSets[i].draw();
    }
    
    for (var i = 0; i < this.keyFrames.length; i++) {
        this.keyFrames[i].drawWithHandles();
    }

    // Mouse over keyframe
    var frame = this.mouseOverAvars();
    
    if (frame && !(mouseIsPressed && !this.toAddKeyFrame)) {
        strokeWeight(2);
        stroke(ORANGE);
        // Indicate possible keyFrame
        if (!this.isKeyFrame(frame[0])) {
            fill(BACKGROUND);
            ellipse(frame[1], frame[2], 13, 13);   
        }
        
        // Indicate this frame
        var fs = this.timeline.frameSelector;
        noFill();
        ellipse(frame[1], fs.by, fs.r * 2 + 1, fs.r * 2 + 1);
    }
    
};

Avar.prototype.updateShape = function(frame) {
    this.shape.transform(this.transform, this.shape.origin, this.values[frame]);
};

Avar.prototype.addKeyFrame = function(frame, value, fixed) {
    var kf = new KeyFrame(frame, value, this, fixed);
    this.keyFrames.push(kf);
    
    this.keyFrames.sort(function(a, b) {
        return a.frame - b.frame;
    });
    
    // Find index after sorting
    var index = this.keyFrames.indexOf(kf);
 
    // Find existing frameset
    if (this.frameSets.length) {
        this.removeFrameSet(index - 1);
    
        // Replace with two new ones
        this.addFrameSet(index - 1);
        this.addFrameSet(index);
    }
};

Avar.prototype.removeSelectedKeyFrame = function() {
    // Check it's not the first or last frame
    if (this.selected && !this.selected.fixed) {
        this.removeKeyFrame(this.selected);
    }
};

Avar.prototype.removeKeyFrame = function(keyFrame) {
    var index = this.keyFrames.indexOf(keyFrame);
    
    if (index === this.keyFrames.length - 1) { index--; }
    if (index > 0) { index--; }
    
    removeFromArray(this.keyFrames, keyFrame);
    this.removeFrameSet(index);
    this.removeFrameSet(index);
    this.addFrameSet(index);
};

Avar.prototype.addFrameSet = function(index) {
    var kf1 = this.keyFrames[index];
    var kf2 = this.keyFrames[index + 1];
    var fs = new FrameSet(kf1, kf2, this);
    this.frameSets.push(fs);
    
    this.frameSets.sort(function(a, b) {
        return a.kfs[0].frame - b.kfs[0].frame;
    });
};

Avar.prototype.removeFrameSet = function(index) {
    var frameSet = this.frameSets[index];
    
    // Remove oldFrameSet in this.frameSets
    removeFromArray(this.frameSets, frameSet);
    
    // Replace oldFrameSet in keyframe.frameSets
    for (var i = 0; i < frameSet.kfs.length; i++) {
        var kf = frameSet.kfs[i];
        removeFromArray(kf.frameSets, frameSet);
    }
};

Avar.prototype.setKeyFrame = function(frameNum, value) {
    // TODO: check keyFrame is valid
    var keyFrame;
    
    for (var i = 0; i < this.keyFrames.length; i++) {
        if (this.keyFrames[i].frame === frameNum) {
            keyFrame = this.keyFrames[i];
        }
    }
    
    if (!keyFrame) {
        this.addKeyFrame(frameNum, value);
    } else {
        keyFrame.y = this.valueToYPosition(value);
    }
    
    this.updateValues();
};

Avar.prototype.getValues = function(speed) {
    var gap = 7 - speed;
    
    if (gap === 1) {
        return this.values;
    }
    
    var values = [];
    for (var i = 0; i < this.frameSets.length; i++) {
        // Remove value where two frameSets overlap (because it will be the same)
        if (i) { values.pop(); }
        values = values.concat(this.frameSets[i].getValues(gap));
    }
    
    return values;
};

Avar.prototype.valueToYPosition = function(v) {
    return map(v, this.min, this.max, this.y1, this.y2);
};

Avar.prototype.yPositionToValue = function(y) {
    return map(y, this.y1, this.y2, this.min, this.max);
};

Avar.prototype.xPositionToFrame = function(x) {
    var fs = this.timeline.frameSelector;
    return map(x, fs.x, fs.x + fs.w, 1, fs.maxFrames + 1);
};

Avar.prototype.frameToXPosition = function(f) {
    var fs = this.timeline.frameSelector;
    return fs.x + (f + 0.5) * fs.dx;
};

Avar.prototype.isKeyFrame = function(frame) {
    for (var i = 0; i < this.keyFrames.length; i++) {
        if (this.keyFrames[i].frame === frame) {
            return this.keyFrames[i];
        }
    }
};

Avar.prototype.mouseOver = function() {
    return mouseY >= this.y && mouseY <= this.y + this.h && 
           mouseX >= this.x && mouseX <= this.x + this.w;
};

Avar.prototype.mouseOverAvars = function() {
    if (this.mouseOver()) {
        var fs = this.timeline.frameSelector;
        var frame = fs.mouseOverFrame;
        
        if (frame > -1) {
            var vx = this.x + (frame + 0.5) * this.dx;
            var vy = this.valueToYPosition(this.values[frame]);
            
            if (dist(mouseX, mouseY, vx, vy) <= (this.dx - 2) / 2) {
                return [frame, vx, vy];
            }
        }
    }
};

Avar.prototype.mousePressed = function() {
    if (this.selected) {
        this.selected.selected = false;
        this.selected = false;
    }
    
    this.toAddKeyFrame = false;
    
    if (this.mouseOver()) {
        // First check key frame nodes
        for (var i = 0; i < this.keyFrames.length; i++) {
            var kf = this.keyFrames[i];
            if (kf.mouseOver()) {
                this.selected = kf;
                this.dragging = kf;
                kf.selected = true;
                this.timeline.currentFrame = kf.frame;
                
                // Show remove button a non-end frame is selected
                if (!kf.fixed) {
                    removeButton.deactivated = false;
                }
                return;
            }
        }
        
        // Then check keyframe handles
        for (var i = 0; i < this.keyFrames.length; i++) {
            var kf = this.keyFrames[i];
            for (var j = 0; j < kf.handles.length; j++) {
                if (!kf.handles[j].hide && kf.handles[j].mouseOver()) {
                    this.dragging = kf.handles[j];
                    return;
                }
            }
        }
        
        // See if we want to add a keyframe
        this.toAddKeyFrame = this.mouseOverAvars();
    }
};

Avar.prototype.mouseDragged = function() {
    if (this.dragging) {
        this.dragging.move();
        this.model.update();
    }
};

Avar.prototype.mouseReleased = function() {
    this.dragging = false;
    
    if (this.toAddKeyFrame) {
        var frame = this.mouseOverAvars();
        var frameNum = frame[0];
        if (frame && !this.isKeyFrame(frameNum)) {
            this.addKeyFrame(frameNum, this.values[frameNum]);
            this.timeline.frameSelector.updateFrame(frameNum);
        }
    }
};
}
/***************************************************
 *          Timeline
 * A object that contains an array for each avar.
****************************************************/
{
var Timeline = function(x, y, w, h, scene) {
    this.labelW = 40;
    this.x = x + this.labelW;
    this.y = y;
    this.avarY = y;

    this.w = w - this.labelW;
    this.h = h;
    this.dx = this.w / FRAMES;
    this.dy = 50;
    this.scene = scene;
    this.state = 'paused';
    
    this.frameCount = FRAMES;
    this.currentFrame = 0;
    this.frameSelector = new FrameSelector(this, this.frameCount - 1);
    
    this.avars = [];
    this.keyFrames = [0, this.frameCount - 1];
};

Timeline.prototype.addAvar = function(avar) {
    this.avars.push(avar);
    this.avarY += this.dy;
};

Timeline.prototype.draw = function() {
    if (this.state === 'running' &&
        frameCount % (7 - speedSlider.value) === 0) {
        var frame = (this.currentFrame + 1) % this.frameCount;
        this.frameSelector.updateFrame(frame);
    }
    
    // Frame Selector
    this.frameSelector.draw();

    // Draw avars
    for (var i = 0; i < this.avars.length; i++) {
        this.avars[i].draw(this.currentFrame);
    }
};

Timeline.prototype.removeSelectedKeyFrame = function() {
    for (var i = 0; i < this.avars.length; i++) {
        if (this.avars[i].selected) {
            this.avars[i].removeSelectedKeyFrame();
            removeButton.deactivated = true;
        }
    }
};

Timeline.prototype.mouseOver = function() {
    return mouseX >= this.x && mouseX <= this.x + this.w &&
           mouseY >= this.y && mouseY <= this.y + this.h;
};

Timeline.prototype.mouseDragged = function() {
    // Drag sliders and update values
    if (this.state === 'paused') {
        this.frameSelector.mouseDragged();
        callFunctionForEach(this.avars, 'mouseDragged');
    }
};

Timeline.prototype.mousePressed = function() {
    this.frameSelector.mousePressed();
    
    if (this.frameSelector.mouseOver()) {
        this.state = 'paused';
    } else if (this.mouseOver()) {
        this.state = 'paused';
        
        removeButton.deactivated = true;
        
        for (var i = 0; i < this.avars.length; i++) {
            var avar = this.avars[i];
            avar.mousePressed();
            
            if (avar.selected) {
                removeButton.deactivated = avar.selected.fixed;
            }
        }
    }
};

Timeline.prototype.mouseReleased = function() {
    if (this.state === 'paused') {
        this.frameSelector.mouseReleased();
        callFunctionForEach(this.avars, 'mouseReleased');
    }
};
}
/*******************************************************
 *          Shape
 * A set of points, which are connected by straight
 * lines, and filled. Points are drawn relative to an
 * origin, which is a node where deformers can be added.
********************************************************/
{
var Shape = function(origin, points, fillColor, strokeColor, x, y) {
    this.x = x || 0;
    this.y = y || 0;
    this.originalOrigin = new PVector(origin[0] + this.x, origin[1] + this.y);
    this.originalCoords = points;
    this.fillColor = fillColor;
    this.strokeColor = strokeColor;
    this.resetCoords();
    
    // Shapes controlled by this one
    this.dependentShapes = [];
};

// Convert arrays of two coordinates, [x, y], into PVectors
// With values relative to the origin
Shape.prototype.resetCoords = function() {
    this.finalCoords = [];
    for (var i = 0; i < this.originalCoords.length; i++) {
        var coord = this.originalCoords[i];
        this.finalCoords.push(new PVector(coord[0] + this.x, coord[1] + this.y));
    }
    this.origin = this.originalOrigin.get();
};

Shape.prototype.transform = function(transform, origin, value) {
    for (var i = 0; i < this.finalCoords.length; i++) {
        transform(this.finalCoords[i], origin, value);
    }
    
    for (var i = 0; i < this.dependentShapes.length; i++) {
        var shape = this.dependentShapes[i];
        transform(shape.origin, origin, value);
        shape.transform(transform, origin, value);
    }
};

Shape.prototype.draw = function() {
    noStroke();
    fill(0, 0, 0, 50);
    
    pushMatrix();
    translate(2, 3);
    this.drawShape(true);
    popMatrix();
    
    
    if (this.fillColor) {
        fill(this.fillColor);
    } else {
        noFill();
    }
    
    if (this.strokeColor) {
        strokeWeight(1);
        stroke(this.strokeColor);
    } else {
        noStroke();
    }
    
    this.drawShape();
};

Shape.prototype.drawShape = function() {
    beginShape();
    for (var i = 0; i < this.finalCoords.length; i++) {
        var p = this.finalCoords[i];
        vertex(p.x, p.y);
    }
    endShape(CLOSE);
};
}
/*******************************************************
 *      Model
 * An Model is an object in a scene to be animated.
********************************************************/
{
var Model = function(timeline) {
    this.timeline = timeline;
    this.shapes = {};
    this.avars = [];
};

Model.prototype.draw = function() {
    var f = this.timeline.currentFrame;

    pushMatrix();
    scale(0.5, 0.5);
    for (var shape in this.shapes) {
        this.shapes[shape].draw();
    }
    popMatrix();
};

Model.prototype.getShape = function(name) {
    var shape = this.shapes[name];
    if (shape) {
        return shape;
    } else {
        println("ERROR: Invalid index: " + name);
    }
};

Model.prototype.connectShapes = function(parent, child) {
    parent = this.getShape(parent);
    child = this.getShape(child);
    if (parent && child) {
        if (parent === child) {
            println("ERROR: cannot make node dependent on itself");
        } else {
            parent.dependentShapes.push(child);
        }
    }
};

Model.prototype.loadData = function(data) {
    var x = data.x || 0;
    var y = data.y || 0;
    
    // Add shapes
    for (var name in data.shapes) {
        var d = data.shapes[name];
        this.shapes[name] = new Shape(d.origin, d.vertices, d.fill, d.stroke, x, y);
    }
    
    // Join shapes
    for (var i = 0; i < data.connections.length; i++) {
        var shapes = data.connections[i].split('->');
        this.connectShapes(shapes[0], shapes[1]);
    }
    
    // Add deformers
    for (var i = 0; i < data.deformers.length; i++) {
        var deformerData = data.deformers[i];
        var shape = this.getShape(deformerData[1]);
        
        if (shape) {
            var deformer = deformers[deformerData[0]];
            if (deformer) {
                var name = this.avars.length + " " + deformer.id;
                var avar = new Avar(this.timeline, name, deformer, shape, this);
                this.avars.push(avar);
                this.timeline.addAvar(avar);
            }
        }
    }
};

Model.prototype.update = function() {
    // Reset all coords equal to original positions
    for (var shape in this.shapes) {
        this.shapes[shape].resetCoords();
    }
    
    // Go through deformers in order, updating each shape
    var frame = this.timeline.currentFrame;
    for (var i = 0; i < this.avars.length; i++) {
        this.avars[i].updateShape(frame);
    }
};
}
/*************************************
 *      Scene
 * A scene is box in which the Models exist
**************************************/
{
var Scene = function(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.models = [];
};

Scene.prototype.draw = function() {
    fill(SKYBLUE);
    rect(this.x, this.y, this.w, this.h + 20);
    
    noStroke();
    fill(184, 134, 40);
    rect(this.x + 1, this.y + this.h, this.w - 1, 20);
    
    for (var i = 0; i < this.models.length; i++) {
        this.models[i].draw(this.x, this.y + this.h);
    }
    
    // Border
    strokeWeight(1);
    stroke(20);
    noFill();
    rect(this.x, this.y, this.w, this.h + 20);
    
    // Clip scene
    noStroke();
    fill(BACKGROUND);
    rect(0, 0, width, this.y);
    rect(0, 0, this.x, height);
    rect(this.x + this.w + 1, 0, this.x, height);
    rect(0, this.y + this.h + 21, width, height);
};

Scene.prototype.addModel = function(model) {
    this.models.push(model);
    model.dx = this.x;
    model.dy = this.y + this.h;
};

Scene.prototype.update = function() {
    callFunctionForEach(this.models, 'update');
};
}
/*************************************
 *      Setup
**************************************/

var scene = new Scene(10, 10, width - 20, 200);

// Create a region for the frameSelector and avars
var timeline = new Timeline(
    10, scene.h + scene.y + 50,
    width - 20, height - scene.h - scene.y - 92, scene
);

var restart = function() {
    var luxoJr = new Model(timeline);
    luxoJr.loadData(modelData);
    
    scene.addModel(luxoJr);
    
    timeline.state = 'paused';
    timeline.currentFrame = 0;
};
restart();

/*************************************
 *      Set the interface
**************************************/
{
var saveAnimation = function() {
    var screenHeight = 250;
    var bar = (400 - screenHeight) / 2;
    var groundY = 400 - bar - 20;
    
    // TODO: use interpolation to find values between frames
    
    var s = "// Animation made at https://www.khanacademy.org/pixar/animation-with-rigging/5579305257140224";
    s += "\n\nframeRate(24);\n";
    
    var writeN = true;
    
    for (var i = 0; i < timeline.avars.length; i++) {
        var values = timeline.avars[i].getValues(speedSlider.value);
        
        if (writeN) {
            s += "var n = " + values.length + ";\n";
            writeN = false;
        }            
            
        s += "var avar" + i + " = [";
        for (var j = 0; j < values.length; j++) {
            s += (j ? "," : "") + round(values[j]);
        }
        s += "];\n";
    }
    
    s += "\nvar ball = getImage('pixar/luxoball');\n";
    s += "\nvar drawBall = function(img, x, y, r, s) {\n";
    
    s += "\ts = map(s, 0, 100, 0.1, 1.9);\n";
    s += "\tvar rx = 32 * (2 - s);\n";
    s += "\tvar ry = 32 * s;\n\n";
    s += "\t// Shadow\n";
    s += "\tpushMatrix();\n";
    s += "\ttranslate(x + 1, y - ry / 2 + 1);\n";
    s += "\trotate(r);\n";
    s += "\tnoStroke();\n";
    s += "\tfill(0, 0, 0, 60);\n";
    s += "\tellipse(0, 0, rx - 3, ry - 3);\n";
    s += "\tpopMatrix();\n\n";
    s += "\t// Ball\n";
    s += "\tpushMatrix();\n";
    s += "\ttranslate(x, y - ry / 2);\n";
    s += "\trotate(r);\n";
    s += "\timage(img, -rx/2, -ry/2, rx, ry);\n";
    s += "\tpopMatrix();\n";
    s += "};\n";
    
    s += "\ndraw = function() {\n";
    
    s += "\tbackground(0);\n";
    s += "\tfill(230, 240, 255);\n";
    s += "\tnoStroke();\n";
    s += "\trect(-1, " + bar + ", width + 2, " + screenHeight + ");\n";
    
    s += "\tfill(120, 200, 160);\n";
    s += "\trect(-1, " + groundY + ", width + 2, 20);\n";
    
    s += "\tstrokeWeight(2);\n";
    s += "\tstroke(28, 173, 123);\n";
    s += "\tline(-1, " + groundY + ", width + 1, " + groundY + ");\n";
    
    s += "\n\tvar x = xArray[frameCount % n];\n";
    s += "\tvar y = yArray[frameCount % n];\n";
    s += "\tvar r = rArray[frameCount % n];\n";
    s += "\tvar s = sArray[frameCount % n];\n"; 
    s += "\tdrawBall(ball, x, y, r, s);\n";
    s += "};\n";
    
    println(s);
};

var saveSetup = function() {
    var s = "var setup = {";
    
    var trim = function(n) {
        return "" + round(1000 * n) / 1000;
    };
    
    for (var a in timeline.avars) {
        var avar = timeline.avars[a];
        s += a + ":[";
        
        for (var i = 0; i < avar.keyFrames.length; i++) {
            var kf = avar.keyFrames[i];
            s += (i === 0 ? "" : ",");
            s += "[" + trim(kf.frame) + "," + trim(kf.value) + ",";
            s += "[";
            for (var j = 0; j < kf.handles.length; j++) {
                var handle = kf.handles[j];
                s += (j === 0 ? "" : ",");
                s += trim(avar.xPositionToFrame(handle.x)) + ","; 
                s += trim(avar.yPositionToValue(handle.y));
            }
            s += "]]";
        }
        
        s += "],";
    }
    
    s += "};";
    println(s);
};

var buttonY = timeline.y + timeline.h + 9;

var removeKeyFrame = function() {
    timeline.removeSelectedKeyFrame();
};

var playPause = function() {
    if (timeline.state === 'running') {
        timeline.state = 'paused';
    } else if (timeline.state === 'paused') {
        timeline.state = 'running';
        removeButton.deactivated = true;
    }
};

var playIcon = function(x, y, r) {
    noStroke();
    if (timeline.state === 'running') {
        rect(x - 4, y - 5, 3, 10, 5);
        rect(x + 1, y - 5, 3, 10, 5);
    } else {
        triangle(x - r * 0.4, y - r * 0.5, x - r * 0.4, y + r * 0.5, x + r * 0.65, y);
    }
};

var playButton = new CircleButton(26, buttonY, 24, 24, playPause, playIcon);

var restartButton = new Button(width - 82, buttonY + 1, 64, 24, "Clear", restart);
restartButton.makeFilled(RED);

removeButton = new Button(width - 294, buttonY + 1, 132, 24, "Remove keyframe", removeKeyFrame);
removeButton.deactivated = true;

var saveButton = new Button(width - 155, buttonY, 64, 24, "Save", saveAnimation);
saveButton.makeFilled(CS_GREEN);

speedSlider = new Slider(80, buttonY + 20, 60, 'horizontal', 1, 6, 3, "Speed");

var elements = [
    timeline,
    playButton,
    saveButton,
    removeButton,
    restartButton,
    speedSlider
];
}
/*************************************
 *      Main loop
**************************************/

draw = function() {
    background(BACKGROUND);
    scene.draw();
    callFunctionForEach(elements, 'draw');
};

/*************************************
 *      Event handling
**************************************/

mousePressed = function() {
    callFunctionForEach(elements, 'mousePressed');
};

mouseDragged = function() {
    timeline.mouseDragged();
    speedSlider.mouseDragged();
};

mouseReleased = function() {
    callFunctionForEach(elements, 'mouseReleased');
};

mouseOut = function() {
    timeline.mouseReleased();
    speedSlider.held = false;
};

keyPressed = function() {
    if (key.toString() === 's') {
        saveAnimation();
    } else if (key.toString() === 'q') {
        saveSetup();
    }
};
