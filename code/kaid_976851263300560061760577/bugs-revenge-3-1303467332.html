<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Bug's Revenge 3!</title>
    <link rel="stylesheet" href="../../build/css/live-editor.core_deps.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.audio.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.tooltips.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.ui.css"/>
<style>
        body {
            padding: 20px;
        }
        h1 {
            padding: 0;
            margin: 0 0 20px 0;
        }
        #sample-live-editor {
            padding: 0;
        }
    </style>
</head>
<body>
    <h1>Bug's Revenge 3!</h1>
    <div id="sample-live-editor"></div>
    <script src="../../build/js/live-editor.core_deps.js"></script>
    <script src="../../build/js/live-editor.editor_ace_deps.js"></script>
    <script src="../../build/js/live-editor.audio.js"></script>
    <script src="../../build/js/live-editor.shared.js"></script>
    <script src="../../build/js/live-editor.tooltips.js"></script>
    <script src="../../build/js/live-editor.ui.js"></script>
    <script src="../../build/js/live-editor.editor_ace.js"></script>
    <script>
    var outputUrl = "../output.html";
var code = "/**Bug's Revenge 3! by David Elijah de Siqueira Campos McLaughlin\nOriginal size(400, 400);\nOriginally Created on 2013-01-18T19:43:56Z by kaid_976851263300560061760577\nLast Edited: 2013-01-18T19:43:56Z\nVotes/Spinoffs: 4/5\nOriginally Created: 2013-03-19T20:59:29Z from origin 1295371028 with similarity of 0.8711693085228578\nOriginal Link: https://www.khanacademy.org/computer-programming/bugs-revenge-3/1303467332\nRetrieved On: 07-Nov-2022 (17:06:51.960091)**/\
";

code = code + "\n/** INSTRUCTIONS\n * Left and right arrow keys to move, up to jump.\n * Jump on a Jump-person to drop it.\n * Don\'t touch a Jump-person unless you are jumping on it.\n * The enemies breed, and it\'s impossible to destroy every single one. That\'s not the goal! You want to get as many points as you can.\n * \n * MAP\n * Blue = Jump-person. Red = you\n * Green, yellow, light blue, brown, gray, etc. = Platforms\n * \n * FEATURES:\n * You are the bug (my idea)\n * Colored minimap (my idea)\n * Zoomed out (my idea)\n * Moving enemies\n * Enemies spawn randomly (my idea)\n * Score\n * Water\n * */\n\nscale(0.5, 0.5);\nvar score = 0;\nvar drawBackground = function() {\n    background(216, 245, 252);\n};\n\nvar TILE_HEIGHT = 43;\nvar TILE_WIDTH = 100;\n\nvar SCREEN_ROWS = 16;\nvar SCREEN_COLS = 8;\n\nvar TILE_MAP = [\n[0,0,0,0,4,0,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,8,8,8,0,0,0,8,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,8,8,0,0,8,0,0,0,0,0,0,0,8],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],\n[0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],\n[7,0,0,0,0,0,0,0,0,0,0,3,2,0,0,0,0,0,0,0,0,0,0,5,0,0,0,8],\n[7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8],\n[3,7,7,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,8,8],\n[0,1,1,1,6,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0],\n[0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,8,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,8,8,0],\n[4,0,0,0,0,0,0,0,0,5,5,0,0,0,0,0,0,0,0,0,0,0,0,4,0,8,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,4,4,0,4,0,8,0,0],\n[0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0],\n[0,0,0,0,0,4,1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0],\n[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,4,4,4,4,8,0,0]\n];\nvar TILE_MAP_ROWS = TILE_MAP.length;\nvar TILE_MAP_COLS = TILE_MAP[0].length;\n\n// enemies\nvar ENEMY_MAP = [\n[4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,5,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,4,0,0,0,0,0,0,0,0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n];\n\nvar GRAVITY = 2;\n\n// tile access\n// -----------\nvar tileFor = function(tX, tY) {\n    if (typeof tX === \"object\") {\n        // someone passed in tileFor([tX, tY])\n        tY = tX[1];\n        tX = tX[0];\n    }\n\n    if (tY < TILE_MAP_ROWS && tX < TILE_MAP_COLS && tY >= 0 && tX >= 0) {\n        return TILE_MAP[tY][tX];\n    } else {\n        // this tile is impassable\n        return 0;\n    }\n};\n\n// turns some point (x, y) into the (tX, tY) covering that point\nvar tileCoordsForPoint = function(x, y) {\n    if (typeof x === \"object\") {\n        // passed [x, y]\n        y = x[1];\n        x = x[0];\n    }\n    return [floor(x / TILE_WIDTH), floor(y / TILE_HEIGHT)];\n};\n\nvar tileForPoint = function(x, y) {\n    var tileCoords = tileCoordsForPoint(x, y),\n    tX = tileCoords[0],\n    tY = tileCoords[1];\n    \n    return tileFor(tX, tY);\n};\n\nvar rectIntersectsRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {\n    return ( ((x1 <= x2) && (x2 <= x1 + w1)) ||\n             ((x2 <= x1) && (x1 <= x2 + w2)) ) &&\n           ( ((y1 <= y2) && (y2 <= y1 + h1)) ||\n             ((y2 <= y1) && (y1 <= y2 + h2)) );\n};\n\nvar rectIntersectsTile = function(x, y, w, h, tX, tY) {\n    return rectIntersectsRect(x, y, w, h,\n    \n        tX * TILE_WIDTH + 2,\n        tY * TILE_HEIGHT + 2,\n        tX * TILE_WIDTH + TILE_WIDTH - 4,\n        tY * TILE_HEIGHT + TILE_HEIGHT - 4);\n};\n\nvar dudeIntersectsTile = function(dude, tX, tY) {\n    return rectIntersectsTile(\n        dude.x + dude.cXOffset + 2,\n        dude.y + dude.cYOffset + 2,\n        dude.cWidth - 4,\n        dude.cHeight - 4,\n        \n        tX, tY);\n};\n\nvar dudeIntersectsDude = function(dude1, dude2) {\n    return rectIntersectsRect(\n        dude1.x + dude1.cXOffset + 2,\n        dude1.y + dude1.cYOffset + 2,\n        dude1.cWidth - 4,\n        dude1.cHeight - 4,\n        \n        dude2.x + dude2.cXOffset + 1,\n        dude2.y + dude2.cYOffset + 1,\n        dude2.cWidth - 2,\n        dude2.cHeight - 2);\n};\n\nvar t = 0;\n\nvar scrollX = 0, scrollY = 0;\n\nvar animMap = {};\n\nvar myBlock;\n\nvar makeMyBlock = function(r, g, b, alpha) {\n    var originalImage = getImage(\"cute/PlainBlock\");\n    var myBlock, helper;\n    \n    helper = createGraphics(originalImage.width,\n    originalImage.height, JAVA2D);\n    helper.beginDraw();\n    helper.background(255, 0);\n    helper.fill(255, 0);\n    \n    helper.image(originalImage, 0, 0);\n    \n    helper.endDraw();\n    \n    myBlock = createGraphics(originalImage.width,\n    originalImage.height, JAVA2D);\n    myBlock.beginDraw();\n    myBlock.background(255, 0);\n    myBlock.fill(255, 0);\n    myBlock.tint(r, g, b, alpha);\n    myBlock.image(helper, 0, 0);\n    \n    myBlock.endDraw();\n    return myBlock;\n};\n\nvar myBlock = makeMyBlock(64, 192, 192, 255);\n\nvar tileImages = {\n    1: getImage(\"cute/DirtBlock\"),\n    2: getImage(\"cute/WoodBlock\"),\n    3: getImage(\"cute/PlainBlock\"),\n    4: getImage(\"cute/GrassBlock\"),\n    5: getImage(\"cute/StoneBlock\"),\n    6: getImage(\"cute/WaterBlock\"),\n    7: getImage(\"cute/BrownBlock\"),\n    8: getImage(\"cute/WallBlock\"),\n    \n    9: myBlock\n};\n\nvar animFor = function(tX, tY) {\n    if (tY in animMap && tX in animMap[tY]) {\n        var anim = animMap[tY][tX];\n\n        if (anim.type === \"powerup\") {\n            anim.yOffset = anim.t*anim.t - 6*anim.t;\n\n            if (anim.t > 0 && anim.yOffset === 0) {\n                delete animMap[tY][tX];\n            }\n        }\n        \n        anim.t += 1;\n\n        return anim;\n    }\n};\n\nvar drawTile = function(tX, tY) {\n    var anim = animFor(tX, tY);\n    if (anim) {\n        image(tileImages[anim.tile], TILE_WIDTH * tX + scrollX + anim.xOffset, TILE_HEIGHT * tY + scrollY + anim.yOffset);\n\n    } else {\n        var tileImage = tileImages[tileFor(tX, tY)];\n\n        if (!tileImage) {\n            return;\n        }\n\n        if (tileFor(tX, tY) === 9) {\n            \n            image(myBlock, TILE_WIDTH * tX + scrollX, TILE_HEIGHT * tY + scrollY);\n            \n            return;\n        }\n        image(tileImages[tileFor(tX, tY)], TILE_WIDTH * tX + scrollX, TILE_HEIGHT * tY + scrollY);\n    }\n};\n\nvar dudeImages = {\n    1: getImage(\"cute/EnemyBug\"),\n    2: getImage(\"cute/CharacterBoy\"),\n    3: getImage(\"space/beetleship\"),\n    4: getImage(\"cute/CharacterCatGirl\"),\n    5: getImage(\"cute/CharacterPrincessGirl\"),\n    6: getImage(\"space/girl3\")\n};\n\nvar powerImages = {\n    \"armed\": getImage(\"cute/Selector\")\n};\n\nvar hero = {\n    // these are properties that all kinds of characters have\n    // including the hero\n    x: 0,\n    y: 600,\n\n    xVelocity: 0,\n    yVelocity: 0,\n\n    wounded: false,\n    lastWounded: 0,\n\n    cXOffset: 5,\n    cWidth: TILE_WIDTH - 10,\n    cYOffset: 0,\n    cHeight: TILE_HEIGHT,\n\n    im: 1,\n\n    // only the hero has the following properties, though\n    jump: 0, // increases as you hold down JUMP, so a brief tap !== a long press\n    running: false,\n\n    facesLeft: false,\n    ySway: 0,\n    \n    power: \"none\",\n    dead: false\n};\n\nvar hitPowerup = function(tX, tY) {\n    if (!(tY in animMap)) {\n        animMap[tY] = {};\n    }\n\n    animMap[tY][tX] = {\n        tile: tileFor(tX, tY),\n        type: \"powerup\",\n\n        xOffset: 0,\n        yOffset: 0,\n        \n        t: 0\n    };\n    \n    if (hero.power === \"none\") {\n        hero.power = \"armed\";\n    }\n};\n\nvar drawDude = function(dude) {\n    var mod;\n    \n    if (dude.wounded && round(t / 3) % 2 === 0) {\n        return;\n    }\n    \n    if (dude.xVelocity !== 0) {\n        if (dude.xVelocity < 0) {\n            dude.facesLeft = true;\n        } else if (dude.xVelocity > 0) {\n            dude.facesLeft = false;\n        }\n        \n        if (dude.yVelocity === 0) {\n            if (dude.ySway === 0) {\n                dude.ySway = 1;\n            } else {\n                if (dude.running) {\n                    mod = 3;\n                } else {\n                    mod = 4;\n                }\n                \n                if ((t % mod) === 0) {\n                    dude.ySway = -dude.ySway;\n                }\n            }\n        }\n    } else {\n        dude.ySway = 0;\n    }\n    \n    var img = dudeImages[dude.im];\n\n    var dying = dude.dead && (dude.y + scrollY) < height;\n    \n    if (dying) {\n        pushMatrix();\n        dude.rotation += 1;\n        \n        rotate(dude.rotation);\n    }\n    \n    if (dude.facesLeft) {\n        pushMatrix();\n        scale(-1, 1);\n        image(img, -(dude.x + scrollX + img.width), dude.y + scrollY + dude.ySway);\n        popMatrix();\n    } else {\n        image(img, dude.x + scrollX, dude.y + scrollY + dude.ySway);\n    }\n\n    if (dude.power && dude.power !== \"none\") {\n        image(powerImages[dude.power], dude.x + scrollX, dude.y + scrollY + dude.ySway);\n    }\n    \n    if (dying) {\n        popMatrix();\n    }\n};\n\n// sectumsempra\n// ------------\nvar enemies = [];\n\nvar loadEnemy = function(id, tX, tY) {\n    var im;\n    \n    if (id === 0) {\n        return;\n    }\n    \n    enemies.push({\n        x: tX * TILE_WIDTH,\n        y: tY * TILE_HEIGHT,\n        \n        xVelocity: 0,\n        yVelocity: 0,\n        \n        wounded: false,\n        \n        im: id,\n        \n        ySway: 0,\n        \n        cXOffset: 20,\n        cWidth: TILE_WIDTH - 40,\n        cYOffset: 0,\n        cHeight: TILE_HEIGHT,\n        \n        t: 0\n    });\n};\n\nvar loadEnemies = function() {\n    for (var tY = 0; tY < TILE_MAP_ROWS; tY += 1) {\n        for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n            if (ENEMY_MAP[tY][tX] !== 0) {\n                loadEnemy(ENEMY_MAP[tY][tX], tX, tY);\n            }\n        }\n    }\n};\n\nloadEnemies();\n\nvar drawEnemies = function() {\n    for (var i = 0; i < enemies.length; i += 1) {\n        drawDude(enemies[i]);\n    }\n};\n\n\n// drawing\n// -------\nvar drawMapBelowHero = function() {\n    var heroRow = max(floor(hero.y / TILE_HEIGHT), 0);\n    // have to draw rows at the bottom first, and go upward\n    for (var tY = TILE_MAP_ROWS-1; tY >= heroRow; tY -= 1) {\n        for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n            drawTile(tX, tY);\n        }\n    }\n};\nvar drawMapAboveHero = function() {\n    // have to draw rows at the bottom first, and go upward\n    var heroRow = floor(hero.y / TILE_HEIGHT);\n    \n    if (heroRow >= 0) {\n        for (var tY = heroRow; tY >= 0; tY -= 1) {\n            for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n                drawTile(tX, tY);\n            }\n        }\n    }\n};\n\n// collisions\n// ----------\n\n// tiles adjacent to dudes\nvar tileCoordsAdj = function(dude, dir, amt) {\n    var x, y;\n    amt = amt || 1;\n\n    if (dir === \"left\") {\n        x = dude.x + dude.cXOffset - amt;\n        y = dude.y + dude.cYOffset;\n    } else if (dir === \"right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth + amt;\n        y = dude.y + dude.cYOffset;\n    } else if (dir === \"below left\") {\n        x = dude.x + dude.cXOffset;\n        y = dude.y + dude.cYOffset + dude.cHeight + amt;\n    } else if (dir === \"below right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth;\n        y = dude.y + dude.cYOffset + dude.cHeight + amt;\n    } else if (dir === \"above left\") {\n        x = dude.x + dude.cXOffset;\n        y = dude.y + dude.cYOffset - amt;\n    } else if (dir === \"above right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth;\n        y = dude.y + dude.cYOffset - amt;\n    }\n    \n    return tileCoordsForPoint(x, y);\n};\n\nvar tileAdj = function(dude, dir, amt) {\n    return tileFor(tileCoordsAdj(dude, dir, amt));\n};\n\n// tile checks\nvar tileIsBlocking = function(tile) {\n    return tile !== 0 && tile !== 6;\n};\n\nvar tileIsPowerup = function(tile) {\n    return tile === 3;\n};\n\nvar tileAdjIsBlocking = function(dude, dir, amt) {\n    if (dude.dead) {\n        return false;\n    }\n    if (dir === \"left\" || dir === \"right\") {\n        return tileIsBlocking(tileAdj(dude, dir, amt));\n\n    } else if (dir === \"below\" || dir === \"above\") {\n        return tileIsBlocking(tileAdj(dude, dir + \" left\", amt)) ||\n            tileIsBlocking(tileAdj(dude, dir + \" right\", amt));\n    }\n};\n\nvar checkXCollisions = function(dude) {\n    // FIXME jump into block above you bug\n    if (tileAdjIsBlocking(dude, \"left\") && dude.xVelocity < 0) {\n        dude.xVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"left\") && !tileAdjIsBlocking(dude, \"right\")) {\n            dude.x += 1;\n        }\n    } else if (tileAdjIsBlocking(dude, \"right\") && dude.xVelocity > 0) {\n        dude.xVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"right\") && !tileAdjIsBlocking(dude, \"left\")) {\n            dude.x -= 1;\n        }\n    }\n};\n\nvar checkYCollisions = function(dude) {\n    \n    var tal, tar;\n    var curTile = tileCoordsForPoint(dude.x, dude.y);\n    if (tileAdjIsBlocking(dude, \"below\") && dude.yVelocity > 0) {\n        dude.yVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"below\")) {\n            dude.y -= 1;\n        }\n    } else if (tileAdjIsBlocking(dude, \"above\") && dude.yVelocity < 0) {\n        dude.yVelocity = dude.yVelocity * -1/2;\n\n        tal = tileCoordsAdj(dude, \"above left\");\n        if (tileIsPowerup(tileFor(tal)) && dude === hero) {\n            hitPowerup(tal[0], tal[1]);\n        } else {\n            tar = tileCoordsAdj(dude, \"above right\");\n            if (tileIsPowerup(tileFor(tar))&&dude===hero) {\n                hitPowerup(tar[0], tar[1]);\n            }\n        }\n\n        while (tileAdjIsBlocking(dude, \"above\")) {\n            dude.y += 1;\n        }\n    }\n};\n\n// input\n// -----\nvar keyJump = false, keyLeft = false, keyRight = false;\nvar keyPressed = function() {\n    if (keyCode === UP) { // 32 is the keyCode for space\n        keyJump = true;\n    } else if (keyCode === SHIFT) {\n        hero.running = true;\n    } else if (keyCode === LEFT) {\n        keyLeft = true;\n    } else if (keyCode === RIGHT) {\n        keyRight = true;\n    }\n};\nvar keyReleased = function() {\n    if (keyCode === UP) {\n        keyJump = false;\n    } else if (keyCode === SHIFT) {\n        hero.running = false;\n    } else if (keyCode === LEFT) {\n        keyLeft = false;\n    } else if (keyCode === RIGHT) {\n        keyRight = false;\n    }\n};\n\n// hero update stuff\n// -----------------\nvar maxHeroSpeed = function() {\n    if (hero.running) {\n        return 15;\n    } else {\n        return 9;\n    }\n};\n\nvar updateHeroXVelocity = function() {\n    if (keyRight) {\n        if (hero.xVelocity < 0) {\n            hero.xVelocity = 0;\n        }\n        hero.xVelocity += 1;\n    } else if (keyLeft) {\n        if (hero.xVelocity > 0) {\n            hero.xVelocity = 0;\n        }\n        hero.xVelocity -= 1;\n    } else {\n        if (hero.xVelocity > 0) {\n            hero.xVelocity -= 0.5;\n        } else if (hero.xVelocity < 0) {\n            hero.xVelocity += 0.5;\n        }\n    }\n\n    if (hero.xVelocity > maxHeroSpeed()) {\n        hero.xVelocity = maxHeroSpeed();\n    } else if (hero.xVelocity < -maxHeroSpeed()) {\n        hero.xVelocity = -maxHeroSpeed();\n    }\n};\n\nvar updateHeroYVelocity = function() {\n    if (keyJump) {\n        if (hero.yVelocity === 0 && tileAdjIsBlocking(hero, \"below\", 2)) {\n            hero.jump = 1;\n        }\n            \n        if (hero.jump > 0 && hero.jump < 10) {\n            hero.jump += 1;\n            hero.yVelocity -= 6;\n        }\n    }\n\n    if (!keyJump || hero.jump >= 10) {\n        hero.jump = 0;\n    }\n    \n    if (hero.yVelocity < -18) { // max jump speed\n        hero.yVelocity = -18;\n    } else if (hero.yVelocity > 30) { // terminal velocity\n        // (this is as fast as you can ever fall)\n        hero.yVelocity = 30;\n    }\n};\n\nvar killHero = function() {\n    hero.yVelocity -= 100;\n    hero.dead = true;\n};\n\nvar woundHero = function() {\n    hero.wounded = true;\n    hero.lastWounded = t;\n    \n    if (hero.power !== \"none\") {\n        hero.power = \"none\";\n    } else {\n        killHero();\n    }\n};\n\nvar checkEnemyCollisions = function() {\n    // this is intentionally under hero stuff,\n    // because it\'s centered around the hero\n    // (I guess it\'s arguable)\n    if (hero.wounded) {\n        return;\n    }\n    \n    for (var i = 0; i < enemies.length; i += 1) {\n        if (enemies[i].dead) {\n            continue;\n        }\n        if (dudeIntersectsDude(hero, enemies[i])) {\n            if (hero.yVelocity > 0) {\n                // enemy\'s being jumped on\n                hero.yVelocity -= 30;\n                enemies[i].dead = true;\n                score += 100;\n            } else {\n                // enemy hit us!\n                woundHero();\n            }\n        }\n    }    \n};\n\nvar updateHero = function() {\n    updateHeroXVelocity();\n    updateHeroYVelocity();\n    \n    hero.yVelocity += GRAVITY;\n    \n    hero.x += hero.xVelocity;\n    hero.y += hero.yVelocity;\n\n    checkXCollisions(hero);\n    checkYCollisions(hero);\n    \n    checkEnemyCollisions();\n};\n\nvar scroll = function() {\n    scrollX = -hero.x + 350;\n    scrollY = -hero.y + 350;\n};\n\n// enemy update\n// ------------\nvar updateEnemies = function() {\n    var enemy;\n    for (var i = 0; i < enemies.length; i += 1) {\n        enemy = enemies[i];\n\n        enemy.yVelocity += GRAVITY;\n        \n        enemy.x += enemy.xVelocity;\n        enemy.y += enemy.yVelocity;\n        \n        if (enemy.im === 2) {\n            enemy.xVelocity = 1.2 * sin(2 * enemy.t);\n        } else if (enemy.im === 3) {\n            enemy.xVelocity = -2 * sin(2 * enemy.t);\n            if (enemy.t % 60 === 0) {\n                enemy.yVelocity -= 32;\n            }\n        } else if (enemy.im === 4) {\n            enemy.xVelocity = 5 * cos(3 * enemy.t);\n        } else if (enemy.im === 5) {\n            if (enemy.x > hero.x) {\n                enemy.xVelocity = -3 + cos(3.25 * enemy.t);\n            } else if (enemy.im===6) {\n                enemy.xVelocity = 3 - cos(3.25 * enemy.t);\n            }\n            if (enemy.t % 50 < 5) {\n                enemy.yVelocity -= 7;\n            }\n        }\n        \n        if (enemy.y > 2000) {\n            enemies.splice(i, 1);\n        }\n\n        checkXCollisions(enemy);\n        checkYCollisions(enemy);\n        \n        enemy.t++;\n        for (var j = 0; j < enemies.length; j++) {\n            if (enemy.dead || enemies[j].dead || j === i) {\n                continue;\n            }\n            \n            if (dudeIntersectsDude(enemy, enemies[j])) {\n                enemies[j].dead = true;\n            }\n        }\n    }\n};\n\n// game-wide updates\n// -----------------\nvar update = function() {\n    updateHero();\n    updateEnemies();\n\n    scroll();\n};\n\nvar drawDebugInfo = function(scaleFactor) {\n    \n    var a1 = 64; // background\n    var a2 = 141; // tiles, enemies, and hero\n    \n    // draw a minimap of everything at 1/10 scale\n    // draw the whole tilemap\n    noStroke();\n    fill(255, 255, 255, a1);\n    rect(0, 0, TILE_MAP_COLS*TILE_WIDTH*scaleFactor, TILE_MAP_ROWS*TILE_HEIGHT*scaleFactor);\n    \n    for (var tY = 0; tY < TILE_MAP_ROWS; tY += 1) {\n        for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n            if (tileFor(tX, tY) !== 0) {\n                \n                switch (tileFor(tX, tY)) {\n                    case 1: fill(133, 95, 0, a2); break;\n                    case 2: fill(255, 203, 71, a2); break;\n                    case 3: fill(128, 128, 128, a2); break;\n                    case 4: fill(15, 150, 24, a2); break;\n                    case 5: fill(189, 189, 189, a2); break;\n                    case 6: fill(130, 130, 255, a2); break;\n                    case 7: fill(128, 64, 0, a2); break;\n                    case 8: fill(214, 169, 102, a2); break;\n                    case 9: fill(0, 128, 128); break;\n                \n                }\n                \n                rect(tX*TILE_WIDTH*scaleFactor, \n                    tY*TILE_HEIGHT*scaleFactor, \n                    TILE_WIDTH*scaleFactor, \n                    TILE_HEIGHT*scaleFactor);\n            }\n        }\n    }\n    \n    fill(255, 0, 0, a2);\n    rect(hero.x*scaleFactor, hero.y*scaleFactor, TILE_WIDTH*scaleFactor, TILE_HEIGHT*scaleFactor);\n    \n    fill(0, 0, 255, a2);\n    for (var i = 0; i < enemies.length; i += 1) {\n        rect(enemies[i].x*scaleFactor, enemies[i].y*scaleFactor, TILE_WIDTH*scaleFactor, TILE_HEIGHT*scaleFactor);\n    }\n    \n    // draw the onscreen part\n    noFill();\n    strokeWeight(0.8 / scaleFactor);\n    stroke(255, 0, 0, a2);\n    rect(-scrollX*scaleFactor, -scrollY*scaleFactor, SCREEN_COLS*TILE_WIDTH*scaleFactor, SCREEN_ROWS*TILE_HEIGHT*scaleFactor);\n};\n\nvar timer = function() {\n    if (hero.wounded && t - hero.lastWounded > 60) {\n        hero.wounded = false;\n    }\n    t += 1;\n    if (t % 30 === 0 && score > 0) {\n        score--;\n    }\n};\n\nvar addMoreEnemies = function() {\n    // Less chance of another enemy if there is\n    // lots of enemies\n    if (random(0, 1) < 1/(0.8 + (enemies.length / 1.5)) ||\n            t < 60) {\n        var tX = floor(random(0, TILE_MAP_COLS));\n        var tY = floor(random(0, TILE_MAP_ROWS));\n        var x = tX * TILE_WIDTH, y = tY * TILE_HEIGHT;\n        if (dist(x, y, hero.x, hero.y) < 200 || \n                abs(x - hero.x) < 1.5 * TILE_WIDTH) {\n            \n            return;\n        }\n        \n        loadEnemy(floor(random(2, 7)), tX, tY);\n    }\n};\nframeRate(25);\nvar Continue = false, won = false, dontUpdate = false;\nvar draw = function() {\n    if (!dontUpdate) {\n        update();\n    }\n    \n    drawBackground();\n    drawMapBelowHero();\n    drawEnemies();\n    drawDude(hero);\n    drawMapAboveHero();\n    \n    drawDebugInfo(1/5);\n\n    \n    if (!dontUpdate) {\n        timer();\n        addMoreEnemies();\n    }\n    fill(0, 0, 0);\n    textSize(35);\n    textAlign(LEFT, DOWN);\n    text(\"Score: \"+score, 20, 220);\n    \n    if (score >= 9001) {\n        won = true;\n    }\n    \n    if (won && !Continue) {\n        background(0, 255, 0);\n        fill(0, 0, 0);\n        textSize(100);\n        textAlign(CENTER, CENTER);\n        text(\'You win!!\', 400, 80);\n        textSize(60);\n        text(\"Click to keep playing\", 400, 400);\n        if (mouseIsPressed) {\n            Continue = true;\n        }\n    }\n    if (hero.y > (TILE_MAP_ROWS + 6) * TILE_HEIGHT) {\n        filter(INVERT);\n        dontUpdate = true;\n        fill(255, 255, 255);\n        stroke(0, 0, 0);\n        strokeWeight(30);\n        rect(300, 300, 200, 100);\n        fill(0, 255, 255);\n    }\n};\n";
window.liveEditor = new LiveEditor({
                el: $("#sample-live-editor"),
                code: code,
                width: 400,
                height: 400,
                editorHeight: "80%",
                autoFocus: true,
                workersDir: "../../build/workers/",
                externalsDir: "../../build/external/",
                imagesDir: "../../build/images/",
                soundsDir: "../../sounds/",
                execFile: outputUrl,
                jshintFile: "../../build/external/jshint/jshint.js",
                newErrorExperience: true,
            });
            liveEditor.editor.on("change", function() {
                window.localStorage["test-code"] = liveEditor.editor.text();
            });
            ScratchpadAutosuggest.init(liveEditor.editor.editor);
            </script>
        </body>
        </html>
        