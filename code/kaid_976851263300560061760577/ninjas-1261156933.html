<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Ninjas</title>
    <link rel="stylesheet" href="../../build/css/live-editor.core_deps.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.audio.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.tooltips.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.ui.css"/>
<style>
        body {
            padding: 20px;
        }
        h1 {
            padding: 0;
            margin: 0 0 20px 0;
        }
        #sample-live-editor {
            padding: 0;
        }
    </style>
</head>
<body>
    <h1>Ninjas</h1>
    <div id="sample-live-editor"></div>
    <script src="../../build/js/live-editor.core_deps.js"></script>
    <script src="../../build/js/live-editor.editor_ace_deps.js"></script>
    <script src="../../build/js/live-editor.audio.js"></script>
    <script src="../../build/js/live-editor.shared.js"></script>
    <script src="../../build/js/live-editor.tooltips.js"></script>
    <script src="../../build/js/live-editor.ui.js"></script>
    <script src="../../build/js/live-editor.editor_ace.js"></script>
    <script>
    var outputUrl = "../output.html";
var code = "/**Ninjas by David Elijah de Siqueira Campos McLaughlin\nOriginal size(400, 400);\nOriginally Created on 2013-01-02T21:53:09Z by kaid_976851263300560061760577\nLast Edited: 2013-01-02T21:53:09Z\nVotes/Spinoffs: 1/2\nOriginally Created: 2017-04-18T13:32:52Z from origin 1189541997 with similarity of 0.9869138008039303\nOriginal Link: https://www.khanacademy.org/computer-programming/ninjas/1261156933\nRetrieved On: 07-Nov-2022 (17:07:28.460768)**/\
";

code = code + "\n/** This is a Work In Progress 2P battle!\n * P1: Jumpgirl. Use A and D to move and W to jump.\n * Power: Lay bugs that do 50 base damage.\n * \n * P2: Jumpguy. Use the arrow keys to move and Up to jump.\n * Power: Press Down to shoot at Jumpgirl for 50 base damage\n * if you hit.\n * \n * Attack the other player by jumping on his/her player.\n * That does 20 base damage.\n * \n * For both players:\n * You have 1024 health. When you take damage, you get the\n * \"base damage\" times 1 + (1024 - your health)/1024.\n * So if you have 512 health, you will take 1.5x damage.\n * If you have 256 health, you take 1.75x damage.\n * \n * Don\'t fall into the water! Or else you take 10 base damage.\n * \n * \n * Now there is a gem that gives 50 health to the first \n * person to grab it.\n */\n\n\nvar infoImages = [\n    getImage(\"space/0\"),\n    getImage(\"space/1\"),\n    getImage(\"space/2\"),\n    getImage(\"space/3\"),\n    getImage(\"space/4\"),\n    getImage(\"space/5\"),\n    getImage(\"space/6\"),\n    getImage(\"space/7\"),\n    getImage(\"space/8\"),\n    getImage(\"space/9\")\n];\n\nvar stringToDigit = function(theString) {\n    if (theString === \"0\") {return 0;}\n    if (theString === \"1\") {return 1;}\n    if (theString === \"2\") {return 2;}\n    if (theString === \"3\") {return 3;}\n    if (theString === \"4\") {return 4;}\n    if (theString === \"5\") {return 5;}\n    if (theString === \"6\") {return 6;}\n    if (theString === \"7\") {return 7;}\n    if (theString === \"8\") {return 8;}\n    if (theString === \"9\") {return 9;}\n};\n\n\nvar drawNumber = function(inputNum, X, Y, scaleFactor) {\n    var x = X, y = Y;\n    var qwerty = inputNum.toString(10);\n    for (var i = 0; i < qwerty.length; i++) {\n        var digit = stringToDigit(qwerty[i]);\n        if (infoImages[digit] !== undefined) {\n            pushMatrix();\n            translate(x, y);\n            scale(scaleFactor, scaleFactor);\n            image(infoImages[digit], 0, 0);\n            x += 75*scaleFactor;\n            popMatrix();\n        }\n    }\n};\n\n\n\n\nvar HEALTH = 1024,\n    WATER_DAMAGE = 25,\n    HIT_DAMAGE = 25,\n    BULLET_DAMAGE = 20,\n    \n    bullet1 = {\n        x: -100,\n        y: -100,\n        dx: 0,\n        dy: 0\n    },\n    bullet2 = {\n        x: -100,\n        y: -100,\n        dx: 0,\n        dy: 0\n    },\n    \n    gem = {\n        x: -200,\n        y: -200,\n        speed: 15\n    }\n;\n\n\nscale(0.5, 0.5);\nvar drawBackground = function() {\n    background(216, 245, 252);\n};\n\nvar TILE_HEIGHT = 43;\nvar TILE_WIDTH = 100;\n\nvar SCREEN_ROWS = 16;\nvar SCREEN_COLS = 8;\n\n/*\n\n\n\n\n\n*/\n\n\nvar TILE_MAP = [\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[7,0,0,2,2,0,0,7],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,4,0,0,0,0,4,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,8,8,0,0,0],\n[8,0,0,0,0,0,0,8],\n[8,0,0,0,0,0,0,8],\n[8,0,0,0,0,0,0,8],\n[8,5,0,0,0,0,5,8],\n[8,0,0,0,0,0,0,8],\n[8,0,0,0,0,0,0,8],\n[8,0,0,0,0,0,0,8],\n[1,1,1,6,6,1,1,1]\n];\nvar TILE_MAP_ROWS = TILE_MAP.length;\nvar TILE_MAP_COLS = TILE_MAP[0].length;\n\n// enemies\nvar ENEMY_MAP = [\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0],\n[0,0,0,0,0,0,0,0]\n];\n\nvar GRAVITY = 2;\n\n// tile access\n// -----------\nvar tileFor = function(tX, tY) {\n    if (typeof tX === \"object\") {\n        // someone passed in tileFor([tX, tY])\n        tY = tX[1];\n        tX = tX[0];\n    }\n\n    if (tY < TILE_MAP_ROWS && tX < TILE_MAP_COLS && tY >= 0 && tX >= 0) {\n        return TILE_MAP[tY][tX];\n    } else if (tY < 0) {\n        // this tile is above the screen, so it\'s open space\n        return 0;\n    } else {\n        // this tile is impassable\n        return -1;\n    }\n};\n\n// turns some point (x, y) into the (tX, tY) covering that point\nvar tileCoordsForPoint = function(x, y) {\n    if (typeof x === \"object\") {\n        // passed [x, y]\n        y = x[1];\n        x = x[0];\n    }\n    return [floor(x / TILE_WIDTH), floor(y / TILE_HEIGHT)];\n};\n\nvar tileForPoint = function(x, y) {\n    var tileCoords = tileCoordsForPoint(x, y),\n    tX = tileCoords[0],\n    tY = tileCoords[1];\n    \n    return tileFor(tX, tY);\n};\n\nvar rectIntersectsRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {\n    return ( ((x1 <= x2) && (x2 <= x1 + w1)) ||\n             ((x2 <= x1) && (x1 <= x2 + w2)) ) &&\n           ( ((y1 <= y2) && (y2 <= y1 + h1)) ||\n             ((y2 <= y1) && (y1 <= y2 + h2)) );\n};\n\nvar rectIntersectsTile = function(x, y, w, h, tX, tY) {\n    return rectIntersectsRect(x, y, w, h,\n    \n        tX * TILE_WIDTH,\n        tY * TILE_HEIGHT,\n        tX * TILE_WIDTH + TILE_WIDTH,\n        tY * TILE_HEIGHT + TILE_HEIGHT);\n};\n\nvar dudeIntersectsTile = function(dude, tX, tY) {\n    return rectIntersectsTile(\n        dude.x + dude.cXOffset,\n        dude.y + dude.cYOffset,\n        dude.cWidth,\n        dude.cHeight,\n        \n        tX, tY);\n};\n\nvar dudeIntersectsDude = function(dude1, dude2) {\n    return rectIntersectsRect(\n        dude1.x + dude1.cXOffset,\n        dude1.y + dude1.cYOffset,\n        dude1.cWidth,\n        dude1.cHeight,\n        \n        dude2.x + dude2.cXOffset,\n        dude2.y + dude2.cYOffset,\n        dude2.cWidth,\n        dude2.cHeight);\n};\n\nvar t = 0;\n\n\n\nvar animMap = {};\n\nvar tileImages = {\n    1: getImage(\"cute/DirtBlock\"),\n    2: getImage(\"cute/WoodBlock\"),\n    3: getImage(\"cute/PlainBlock\"),\n    4: getImage(\"cute/GrassBlock\"),\n    5: getImage(\"cute/StoneBlock\"),\n    6: getImage(\"cute/WaterBlock\"),\n    7: getImage(\"cute/BrownBlock\"),\n    8: getImage(\"cute/WallBlock\")\n};\n\nvar animFor = function(tX, tY) {\n    if (tY in animMap && tX in animMap[tY]) {\n        var anim = animMap[tY][tX];\n\n        if (anim.type === \"powerup\") {\n            anim.yOffset = anim.t*anim.t - 6*anim.t;\n\n            if (anim.t > 0 && anim.yOffset === 0) {\n                delete animMap[tY][tX];\n            }\n        }\n        \n        anim.t += 1;\n\n        return anim;\n    }\n};\n\nvar drawTile = function(tX, tY) {\n    var anim = animFor(tX, tY);\n    if (anim) {\n        image(tileImages[anim.tile], TILE_WIDTH * tX + anim.xOffset, TILE_HEIGHT * tY + anim.yOffset);\n\n    } else {\n        var tileImage = tileImages[tileFor(tX, tY)];\n\n        if (!tileImage) {\n            return;\n        }\n\n        image(tileImages[tileFor(tX, tY)], TILE_WIDTH * tX, TILE_HEIGHT * tY);\n    }\n};\n\nvar dudeImages = {\n    1: getImage(\"cute/CharacterHornGirl\"),\n    2: getImage(\"cute/CharacterBoy\"),\n    3: getImage(\"cute/EnemyBug\")\n};\n\nvar powerImages = {\n    \"armed\": getImage(\"avatars/leaf-blue\")\n};\n\nvar P1 = {\n    \n    x: 0,\n    y: 0,\n\n    xVelocity: 0,\n    yVelocity: 0,\n\n    wounded: false,\n    lastWounded: 0,\n\n    cXOffset: 20,\n    cWidth: TILE_WIDTH - 40,\n    cYOffset: 0,\n    cHeight: TILE_HEIGHT,\n\n    im: 1,\n\n    // only the hero has the following properties, though\n    jump: 0, // increases as you hold down JUMP, so a brief tap !== a long press\n    health: HEALTH,\n\n    facesLeft: false,\n    ySway: 0,\n    \n    power: \"none\",\n    dead: false\n};\n\nvar P2 = {\n    \n    x: 700,\n    y: 0,\n\n    xVelocity: 0,\n    yVelocity: 0,\n\n    wounded: false,\n    lastWounded: 0,\n\n    cXOffset: 20,\n    cWidth: TILE_WIDTH - 40,\n    cYOffset: 0,\n    cHeight: TILE_HEIGHT,\n\n    im: 2,\n\n    // only the hero has the following properties, though\n    jump: 0, // increases as you hold down JUMP, so a brief tap !== a long press\n    health: HEALTH,\n\n    facesLeft: false,\n    ySway: 0,\n    \n    power: \"none\",\n    dead: false\n};\n\n\n\nvar drawDude = function(dude) {\n    var mod;\n    \n    if (dude.wounded && round(t / 3) % 2 === 0) {\n        return;\n    }\n    \n    if (dude.xVelocity && dude.xVelocity !== 0) {\n        if (dude.xVelocity < 0) {\n            dude.facesLeft = true;\n        } else if (dude.xVelocity > 0) {\n            dude.facesLeft = false;\n        }\n        \n        if (dude.yVelocity === 0) {\n            if (dude.ySway === 0) {\n                dude.ySway = 1;\n            } else {\n                if (dude.running) {\n                    mod = 3;\n                } else {\n                    mod = 4;\n                }\n                \n                if ((t % mod) === 0) {\n                    dude.ySway = -dude.ySway;\n                }\n            }\n        }\n    } else {\n        dude.ySway = 0;\n    }\n    \n    var img = dudeImages[dude.im];\n\n    var dying = dude.dead && (dude.y) < height;\n    \n    if (dying) {\n        pushMatrix();\n        dude.rotation += 1;\n        \n        rotate(dude.rotation);\n    }\n    \n    if (dude.facesLeft) {\n        pushMatrix();\n        scale(-1, 1);\n        image(img, -(dude.x + img.width), dude.y + dude.ySway);\n        popMatrix();\n    } else {\n        image(img, dude.x, dude.y + dude.ySway);\n    }\n\n    if (dude.power && dude.power !== \"none\") {\n        image(powerImages[dude.power], dude.x, dude.y + dude.ySway);\n    }\n    \n    if (dying) {\n        popMatrix();\n    }\n};\n\n// sectumsempra\n// ------------\nvar enemies = [];\n\n\n\nvar drawEnemies = function() {\n    for (var i = 0; i < enemies.length; i += 1) {\n        drawDude(enemies[i]);\n    }\n};\n\n\n// drawing\n// -------\nvar drawMapBelowHero = function() {\n    var heroRow = max(floor(P1.y / TILE_HEIGHT), 0);\n    // have to draw rows at the bottom first, and go upward\n    for (var tY = TILE_MAP_ROWS - 1; tY >= heroRow; tY -= 1) {\n        for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n            drawTile(tX, tY);\n        }\n    }\n};\nvar drawMapAboveHero = function() {\n    // have to draw rows at the bottom first, and go upward\n    var heroRow = floor(P1.y / TILE_HEIGHT);\n    \n    if (heroRow >= 0) {\n        for (var tY = heroRow; tY >= 0; tY -= 1) {\n            for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n                drawTile(tX, tY);\n            }\n        }\n    }\n};\n\n// collisions\n// ----------\n\n// tiles adjacent to dudes\nvar tileCoordsAdj = function(dude, dir, amt) {\n    var x, y;\n    amt = amt || 1;\n\n    if (dir === \"left\") {\n        x = dude.x + dude.cXOffset - amt;\n        y = dude.y + dude.cYOffset;\n    } else if (dir === \"right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth + amt;\n        y = dude.y + dude.cYOffset;\n    } else if (dir === \"below left\") {\n        x = dude.x + dude.cXOffset;\n        y = dude.y + dude.cYOffset + dude.cHeight + amt;\n    } else if (dir === \"below right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth;\n        y = dude.y + dude.cYOffset + dude.cHeight + amt;\n    } else if (dir === \"above left\") {\n        x = dude.x + dude.cXOffset;\n        y = dude.y + dude.cYOffset - amt;\n    } else if (dir === \"above right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth;\n        y = dude.y + dude.cYOffset - amt;\n    }\n    \n    return tileCoordsForPoint(x, y);\n};\n\nvar tileAdj = function(dude, dir, amt) {\n    return tileFor(tileCoordsAdj(dude, dir, amt));\n};\n\n// tile checks\nvar tileIsBlocking = function(tile) {\n    return tile !== 0  && tile !== 6;\n};\n\nvar tileIsPowerup = function(tile) {\n    return false;\n};\n\nvar tileAdjIsBlocking = function(dude, dir, amt) {\n    if (dude.health <= 0) {\n        return false;\n    }\n    if (dir === \"left\" || dir === \"right\") {\n        return tileIsBlocking(tileAdj(dude, dir, amt));\n\n    } else if (dir === \"below\" || dir === \"above\") {\n        return tileIsBlocking(tileAdj(dude, dir + \" left\", amt)) ||\n            tileIsBlocking(tileAdj(dude, dir + \" right\", amt));\n    }\n};\n\nvar checkXCollisions = function(dude) {\n    // FIXME jump into block above you bug\n    if (tileAdjIsBlocking(dude, \"left\") && dude.xVelocity < 0) {\n        dude.xVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"left\") && !tileAdjIsBlocking(dude, \"right\")) {\n            dude.x += 1;\n        }\n    } else if (tileAdjIsBlocking(dude, \"right\") && dude.xVelocity > 0) {\n        dude.xVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"right\") && !tileAdjIsBlocking(dude, \"left\")) {\n            dude.x -= 1;\n        }\n    }\n};\n\nvar checkYCollisions = function(dude) {\n    var tal, tar;\n    var curTile = tileCoordsForPoint(dude.x, dude.y);\n    if (tileAdjIsBlocking(dude, \"below\") && dude.yVelocity > 0) {\n        dude.yVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"below\")) {\n            dude.y -= 1;\n        }\n    } else if (tileAdjIsBlocking(dude, \"above\") && dude.yVelocity < 0) {\n        dude.yVelocity = dude.yVelocity * -1/2;\n\n        tal = tileCoordsAdj(dude, \"above left\");\n        if (tileIsPowerup(tileFor(tal))) {\n            \n        } else {\n            \n        }\n\n        while (tileAdjIsBlocking(dude, \"above\")) {\n            dude.y += 1;\n        }\n    }\n};\n\n// input\n// -----\n\nvar keysPressed = {\n    // P1\n    up: false,\n    left: false,\n    right: false,\n    \n    // P2\n    w: false,\n    a: false,\n    d: false\n};\nvar keyPressed = function() {\n    if (keyCode !== DOWN && keyCode !== 83) {\n        // 83 is the keyCode for S\n        if (keyCode === UP) {\n            keysPressed.up = true;\n        } else if (keyCode === LEFT) {\n            keysPressed.left = true;\n        } else if (keyCode === RIGHT) {\n            keysPressed.right = true;\n        }\n        if (keyCode === 65) {\n            keysPressed.a = true;\n        } else if (keyCode === 68) {\n            keysPressed.d = true;\n        } else if (keyCode === 87) {\n            keysPressed.w = true;\n        }\n    } else if (keyCode === DOWN) {\n        var rX1 = P1.x + 43, rY1 = P1.y + 100;\n        var rX2 = P2.x + 43, rY2 = P2.y + 100; \n        // r is for \"real\"\n        if (P1.x !== P2.x || P1.y !== P2.y) {\n           bullet1.x = rX2; bullet1.y = rY2;\n           bullet1.dx = ((rX1 - rX2)/dist(rX2, rY2, \n               rX1, rY1)) * 16;\n           bullet1.dy=((rY1-rY2) / dist(rX2,rY2,rX1,rY1)) * 16;\n        }\n        \n    } else if (keyCode === 83) {\n        var rX1 = P2.x + 43, rY1 = P2.y + 100;\n        var rX2 = P1.x + 43, rY2 = P1.y + 100; \n        // r is for \"real\"\n        if (P2.x !== P1.x || P2.y !== P1.y) {\n           bullet2.x = rX2; bullet2.y = rY2;\n           bullet2.dx = ((rX1 - rX2)/dist(rX2, rY2, \n               rX2, rY1)) * 16;\n           bullet2.dy=((rY1-rY2) / dist(rX2,rY2,rX1,rY1)) * 16;\n        }\n    }\n};\n\n\n\nvar keyReleased = function() {\n    if (keyCode === UP) {\n            keysPressed.up = false;\n        } else if (keyCode === LEFT) {\n            keysPressed.left = false;\n        } else if (keyCode === RIGHT) {\n            keysPressed.right = false;\n        }\n        if (keyCode === 65) {\n            keysPressed.a = false;\n        } else if (keyCode === 68) {\n            keysPressed.d = false;\n        } else if (keyCode === 87) {\n            keysPressed.w = false;\n        }\n};\n\n// hero update stuff\n// -----------------\nvar maxPlayerSpeed = function() {\n    return 9;\n};\n\nvar updateP1XVelocity = function() {\n    if (keysPressed.d) {\n        if (P1.xVelocity < 0) {\n            P1.xVelocity = 0;\n        }\n        P1.xVelocity += 1;\n    } else if (keysPressed.a) {\n        if (P1.xVelocity > 0) {\n            P1.xVelocity = 0;\n        }\n        P1.xVelocity -= 1;\n    } else {\n        if (P1.xVelocity > 0) {\n            P1.xVelocity -= 0.5;\n        } else if (P1.xVelocity < 0) {\n            P1.xVelocity += 0.5;\n        }\n    }\n\n    if (P1.xVelocity > maxPlayerSpeed()) {\n        P1.xVelocity = 9;\n    } else if (P1.xVelocity < -maxPlayerSpeed()) {\n        P1.xVelocity = -9;\n    }\n};\n\nvar updateP2XVelocity = function() {\n    if (keysPressed.right) {\n        if (P2.xVelocity < 0) {\n            P2.xVelocity = 0;\n        }\n        P2.xVelocity += 1;\n    } else if (keysPressed.left) {\n        if (P2.xVelocity > 0) {\n            P2.xVelocity = 0;\n        }\n        P2.xVelocity -= 1;\n    } else {\n        if (P2.xVelocity > 0) {\n            P2.xVelocity -= 0.5;\n        } else if (P2.xVelocity < 0) {\n            P2.xVelocity += 0.5;\n        }\n    }\n\n    if (P2.xVelocity > maxPlayerSpeed()) {\n        P2.xVelocity = 9;\n    } else if (P2.xVelocity < -maxPlayerSpeed()) {\n        P2.xVelocity = -9;\n    }\n};\n\nvar updatePlayerYVelocity = function(player) {\n    var keyJump;\n    if (player === P1) {\n        keyJump = keysPressed.w;\n    } else {\n        keyJump = keysPressed.up;\n    }\n    if (keyJump) {\n        if (player.yVelocity === 0 && tileAdjIsBlocking(player, \"below\", 2)) {\n            player.jump = 1;\n        }\n            \n        if (player.jump > 0 && player.jump < 10) {\n            player.jump += 1;\n            player.yVelocity -= 7;\n        }\n    }\n\n    \n    if (!keyJump || player.jump >= 10) {\n        player.jump = 0;\n    }\n    \n    if (player.yVelocity < -18) { // max jump speed\n        player.yVelocity = -18;\n    } else if (player.yVelocity > 30) { // terminal velocity\n        // (this is as fast as you can ever fall)\n        player.yVelocity = 30;\n    }\n};\n\nvar killP1 = function() {\n    P1.yVelocity -= 100;\n    P1.dead = true;\n};\nvar t1, t2;\nvar woundP1 = function() {\n    P1.wounded = true;\n    P1.lastWounded = t1;\n    P1.health = round(P1.health);\n    \n    if (P1.health >= 0) {\n        \n    } else {\n        killP1();\n    }\n};\n\nvar killP2 = function() {\n    P2.yVelocity -= 100;\n    P2.dead = true;\n};\n\nvar woundP2 = function() {\n    P2.wounded = true;\n    P2.lastWounded = t2;\n    \n    if (P2.health >= 0) {\n        \n    } else {\n        killP2();\n    }\n};\n\n\nvar checkEnemyCollisions = function() {\n    // this is intentionally under hero stuff,\n    // because it\'s centered around the hero\n    // (I guess it\'s arguable)\n    if (abs((P1.x + 43)-bullet1.x)<40 && \n        abs((P1.y+100) - bullet1.y)<18 && !P1.wounded) {\n        if (HEALTH === 0) {HEALTH = 1;}\n        P1.health -= BULLET_DAMAGE * (1 + (\n            HEALTH - P1.health)/HEALTH);\n        P1.health = round(P1.health);\n        woundP1();\n    }\n    //P2 Bullet\n    if (abs((P2.x + 43)-bullet2.x)<40 && \n        abs((P2.y+100) - bullet2.y)<18 && !P2.wounded) {\n        if (HEALTH === 0) {HEALTH = 1;}\n        P2.health -= BULLET_DAMAGE * (1 + (\n            HEALTH - P2.health)/HEALTH);\n        P2.health = round(P2.health);\n        woundP2();\n    }\n    if (P2.wounded) {\n        return;\n    }\n    \n    for (var i = 0; i < enemies.length; i += 1) {\n        var e = enemies[i];\n        if (abs(e.x - P2.x) < 50 && abs(e.y - P2.y) < 21) {\n            P2.health -= bullet2 * (1 + (HEALTH - P2.health)/HEALTH);\n            woundP2();\n            enemies.splice(i,1);\n        }\n    }    \n};\n\n\n\n\nvar checkBulletBugCollisions = function() {\n    for (var i = 0; i < enemies.length; i++) {\n        var e = enemies[i];\n        var bX = bullet1.x, bY = bullet1.y;\n        if(abs((e.x+ 43)-bX)<50 && abs((e.y + 100)-bY)<60) {\n            enemies.splice(i, 1);\n            bullet1.x = -100; bullet1.y = -100; bullet1.dx = 0;\n            bullet1.dy = 0;\n        }\n    }\n};\n\n\n\n\nvar checkPlayerCollisions = function() {\n    if (dudeIntersectsDude(P1, P2)) {\n        var damageBonus = 0;\n        if (P1.wounded || P2.wounded) {\n            return;\n        }\n        //P1.x -= 100; // just a test\n        if (P2.y > P1.y && P1.yVelocity > P2.yVelocity &&\n            P1.yVelocity > 0) {\n                damageBonus = (HEALTH - P2.health)/HEALTH; \n                P2.health -= HIT_DAMAGE * (1 + damageBonus);\n                P2.health = round(P2.health);\n                woundP2();\n            }\n        \n        if (P1.y > P2.y && P2.yVelocity > P1.yVelocity &&\n            P2.yVelocity > 0) {\n                damageBonus = (HEALTH - P1.health)/HEALTH; \n                P1.health -= HIT_DAMAGE * (1 + damageBonus);\n                P1.health = round(P1.health);\n                woundP1();\n            }\n        \n        \n    }\n};\n\n\n\nvar updateP1 = function() {\n    updateP1XVelocity();\n    updatePlayerYVelocity(P1);\n    \n    P1.yVelocity += GRAVITY;\n    \n    P1.health = round(P1.health);\n    \n    P1.x += P1.xVelocity;\n    P1.y += P1.yVelocity;\n    \n    P1.x = min(700, P1.x);\n    P1.x = max(0, P1.x);\n\n    checkXCollisions(P1);\n    checkYCollisions(P1);\n    \n    if (P1.y > 640 && !P1.dead) {\n        woundP1();\n        P1.health -= WATER_DAMAGE * (1 + (\n            HEALTH - P1.health)/HEALTH);\n        P1.yVelocity -= 100;\n    }\n};\n\nvar updateP2 = function() {\n    updateP2XVelocity();\n    updatePlayerYVelocity(P2);\n    \n    P2.yVelocity += GRAVITY;\n    \n    P2.health = round(P2.health);\n    \n    P2.x += P2.xVelocity;\n    P2.y += P2.yVelocity;\n    \n    P2.x = min(700, P2.x);\n    P2.x = max(0, P2.x);\n\n    checkXCollisions(P2);\n    checkYCollisions(P2);\n    if (P2.y > 640 && !P2.dead) {\n        woundP2();\n        P2.health -= WATER_DAMAGE * (1 + (\n            HEALTH - P2.health)/HEALTH);\n        P2.yVelocity -= 100;\n        \n    }\n};\n\n\n\n\n// game-wide updates\n// -----------------\n\nvar updateGem = function() {\n    var gemImage = getImage(\"cute/GemBlue\");\n    image(gemImage, gem.x, gem.y);\n    gem.y += gem.speed;\n    // You have to wait 10 seconds\n    if (t % 300 === 0 && gem.y > 800) {\n        gem.x = random(0, 700);\n        gem.y = -200;\n        gem.speed = random(5, 16);\n    }\n    \n    if (abs(P1.x - gem.x) < 80 && abs(P1.y - gem.y) < 40) {\n        P1.health += 50;\n        if (P1.health >= 1024) {\n            P1.health = 1024;\n        }\n        gem.x = -300;\n        gem.y = -300;\n    }\n    if (abs(P2.x - gem.x) < 80 && abs(P2.y - gem.y) < 40) {\n        P2.health += 50;\n        if (P2.health >= 1024) {\n            P2.health = 1024;\n        }\n        gem.x = -300; gem.y = -300;\n    }\n    \n};\n\nvar update = function() {\n    updateP1();\n    updateP2();\n    \n    \n    \n    checkPlayerCollisions();\n    \n    bullet1.x += bullet1.dx; bullet1.y += bullet1.dy;\n    \n    checkEnemyCollisions();\n    checkBulletBugCollisions();\n};\n\n\nvar t1 = 0, t2 = 0;\nvar timer1 = function() {\n    if (P1.wounded && t1 - P1.lastWounded > 60) {\n        P1.wounded = false;\n    }\n    t1 += 1;\n};\nvar timer2 = function() {\n    if (P2.wounded && t2 - P2.lastWounded > 60) {\n        P2.wounded = false;\n    }\n    t2 += 1;\n};\n\nvar draw = function() {\n    drawBackground();\n    update();\n    \n    //drawBackground();\n    drawMapBelowHero();\n    drawMapAboveHero();\n    drawEnemies();\n    updateGem();\n    strokeWeight(30);\n    point(bullet1.x, bullet1.y);\n    drawDude(P1);\n    drawDude(P2);\n    \n    \n    \n    //drawDebugInfo(1/10);\n    t++;\n    timer1();\n    timer2();\n    \n    textAlign(LEFT, DOWN);\n    fill(0, 0, 0);\n    textSize(30);\n    text(\"P1 Health:\", 15, 32);\n    drawNumber(max(0, round(P1.health)), 15, 50, 0.5);\n    \n    textAlign(RIGHT, DOWN);\n    text(\"P2 Health:\", 785, 32);\n    \n    var numberX = 635;\n    if (P2.health >= 1000) {\n        numberX += 0;\n    } else if (P2.health >= 100) {\n        numberX += 37.5;\n    } else if (P2.health >= 10) {\n        numberX += 75;\n    } else if (P2.health > 0) {\n        numberX += 112.5;\n    }\n    \n    drawNumber(max(0, round(P2.health)), numberX, 50, 0.5);\n    \n    \n};\n\n\n\n";
window.liveEditor = new LiveEditor({
                el: $("#sample-live-editor"),
                code: code,
                width: 400,
                height: 400,
                editorHeight: "80%",
                autoFocus: true,
                workersDir: "../../build/workers/",
                externalsDir: "../../build/external/",
                imagesDir: "../../build/images/",
                soundsDir: "../../sounds/",
                execFile: outputUrl,
                jshintFile: "../../build/external/jshint/jshint.js",
                newErrorExperience: true,
            });
            liveEditor.editor.on("change", function() {
                window.localStorage["test-code"] = liveEditor.editor.text();
            });
            ScratchpadAutosuggest.init(liveEditor.editor.editor);
            </script>
        </body>
        </html>
        