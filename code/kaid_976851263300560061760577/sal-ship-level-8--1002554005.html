<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Sal Ship Level 8 :-)</title>
    <link rel="stylesheet" href="../../build/css/live-editor.core_deps.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.audio.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.tooltips.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.ui.css"/>
<style>
        body {
            padding: 20px;
        }
        h1 {
            padding: 0;
            margin: 0 0 20px 0;
        }
        #sample-live-editor {
            padding: 0;
        }
    </style>
</head>
<body>
    <h1>Sal Ship Level 8 :-)</h1>
    <div id="sample-live-editor"></div>
    <script src="../../build/js/live-editor.core_deps.js"></script>
    <script src="../../build/js/live-editor.editor_ace_deps.js"></script>
    <script src="../../build/js/live-editor.audio.js"></script>
    <script src="../../build/js/live-editor.shared.js"></script>
    <script src="../../build/js/live-editor.tooltips.js"></script>
    <script src="../../build/js/live-editor.ui.js"></script>
    <script src="../../build/js/live-editor.editor_ace.js"></script>
    <script>
    var outputUrl = "../output.html";
var code = "/**Sal Ship Level 8 :-) by David Elijah de Siqueira Campos McLaughlin\nOriginal size(400, 400);\nOriginally Created on 2012-11-12T19:06:47Z by kaid_976851263300560061760577\nLast Edited: 2012-11-12T19:06:47Z\nVotes/Spinoffs: 1/2\nOriginally Created: 2012-08-29T12:01:40Z from origin 938561708 with similarity of 0.9865794410505556\nOriginal Link: https://www.khanacademy.org/computer-programming/sal-ship-level-8-/1002554005\nRetrieved On: 07-Nov-2022 (17:07:06.698790)**/\
";

code = code + "\n//O.J. squid has grown and Spunky Sam is weaker.\n/**\n * You can also fire by pressing any key. To pause, just\n * click outside of the game window.\n *\n * Like our other official programs, we avoid advanced code\n * concepts such as constructors, prototypal inheritance for\n * polymorphism, or closures to keep code simple!\n */\n\n/////////////////////////////////////////////////////////////\n// Game constants -- try tweaking these!\n\nvar MAX_HEALTH = 7,\n\n    // Chance of a bonus dropping when you defeat an enemy\n    POWER_UP_CHANCE = 4 * 0.01,\n\n    // # of frames a bonus token is around before going poof\n    POWER_UP_LIFETIME = 200,\n\n    // How long you\'re invulnerable after being hit\n    SAFE_AFTER_HIT_FRAMES = 12,\n\n    // Graphics parameters\n    STARTING_SCALE = 1.2,\n    SCALE_INCREASE = 0.0006,\n    SCROLL_SPEED = 2,\n\n    // Red blaster parameters (the starting ship)\n    BLASTER_DAMAGE = 20,\n    BLASTER_DELAY = 10,\n\n    // Yellow shotgun parameters\n    SHOTGUN_DAMAGE = 12,\n    SHOTGUN_PELLETS = 15,\n    SHOTGUN_DELAY = 18,\n    SHOTGUN_SPREAD = 40,\n    SHOTGUN_SPEED = 20,\n\n    // Green machine gun parameters\n    MG_DAMAGE = 8,\n    MG_DELAY = 1,\n    MG_SPREAD = 6,\n    MG_SPEED = 20,\n\n    // Blue \"Spunky Sam\" orbiting pods parameters\n    POD_DELAY = 0,\n    POD_DAMAGE = 0.1,\n    POD_MISSILE_SPEED = 30,\n\n    // Fire bullets parameters\n    FIRE_DAMAGE = 50,\n    FIRE_SPEED_FACTOR = 1.5,\n\n    // Nuke parameters\n    NUKE_RADIUS = 700,\n    NUKE_DAMAGE = 24,\n    NUKE_NUM_SHRAPNEL = 20,\n    SHRAPNEL_DAMAGE = 12,\n\n    // Difficulty ramps - how quickly things get hard\n    ENEMY_GROWTH_RATE = 14 * 0.00001,\n    ENEMY_HEALTH_RATE = 3 * 0.00001,\n    ENEMY_SPEED_RATE = 5 * 0.0001,\n    ENEMY_BASE_SPEED = 2,\n\n    // Asteroid parameters\n    ROCK_HEALTH = 5,\n\n    // Annoying red bug parameters\n    BUG_HOMES_AT = 20,  // # of frames to wait before seeking\n    BUG_TURN_RATE = 1.5,  // in degrees\n    BUG_SPEED_FACTOR = 0.7,\n    BUG_HEALTH = 9,\n\n    // Robot parameters\n    ROBOT_HEALTH = 10000,\n    ROBOT_RELOAD = 70,\n    ROBOT_SALVO = 8,\n    ROBOT_PROBABILITY = 1 * 0.0001,\n\n    // Game synchronization - intro animation durations\n    START_FRAMES = 100,\n    ZOOM_IN_FRAMES = 50,\n\n    // Game synchronization - game event frame numbers\n    BONUSES_DROP_AT = 300,\n    BUGS_COME_AT = 500,\n    WEAPON_BONUS_AT = 800,\n    ROBOTS_COME_AT = 2200,\n\n    // How many frames a power-up bonus or animation lasts\n    SHIELD_FRAMES = 300,\n    FIRE_FRAMES = 200,\n    NUKE_FRAMES = 10,\n    EXPLOSION_FRAMES = 7,\n\n    // Shows current frame # if true\n    DEBUG = false\n;\n\n// Load up all images used\n// TODO: Crop images for tighter collision detection\nvar healthImage = getImage(\"cute/Heart\");\nvar blasterPlayerImage = getImage(\"avatars/leaf-green\");\nvar shotgunPlayerImage = getImage(\"avatars/leaf-green\");\nvar mgPlayerImage = getImage(\"avatars/leaf-green\");\nvar podImage = getImage(\"avatars/spunky-sam\");\nvar backgroundImage = getImage(\"space/background\");\nvar shotgunBonusImage = getImage(\"cute/GemOrange\");\nvar mgBonusImage = getImage(\"cute/GemGreen\");\nvar healthBonusImage = getImage(\"cute/Heart\");\nvar shieldBonusImage = getImage(\"avatars/leaf-green\");\nvar podBonusImage = getImage(\"avatars/leaf-blue\");\nvar fireBonusImage = getImage(\"avatars/leaf-red\");\nvar nukeBonusImage = getImage(\"avatars/leaf-yellow\");\nvar enemyBugImage = getImage(\"avatars/orange-juice-squid\");\nvar enemyRockImage = getImage(\"avatars/purple-pi\");\nvar enemyRobotImage = getImage(\"avatars/orange-juice-squid\");\nenemyRobotImage.width *= 2;\nenemyRobotImage.height *= 2;\n\n\n/////////////////////////////////////////////////////////////\n// Game variables (careful, changing these might break stuff)\n\n// Scale level of the game window\nvar canvasScale = STARTING_SCALE;\n\n// TODO: Question: should I just use strings instead of these\n//     psuedo-enums?\nvar Weapon = {\n    BLASTER: 0,\n    SHOTGUN: 1,\n    MG: 2,\n    POD: 3,\n    SHRAPNEL: 4,\n    ROBOT: 5\n};\n\nvar PowerUp = {\n    NUKE: -5,\n    POD: -4,\n    FIRE: -3,\n    SHIELD: -2,\n    HEALTH: -1,\n    SHOTGUN: Weapon.SHOTGUN,\n    MG: Weapon.MG\n};\n\nvar Enemy = {\n    ROCK: 0,\n    BUG: 1,\n    ROBOT: 2\n};\n\n// Adjusted canvas dimensions from scaling factor\nvar canvas = {\n    x: 0,\n    y: 0,\n    height: height * canvasScale,\n    width: width * canvasScale\n};\n\n// We use this to check when a projectile is way out of the\n// screen and so is safe to remove\nvar boundsCanvas = {\n    x: -200,\n    y: -200,\n    height: canvas.height + 400,\n    width: canvas.width + 400\n};\n\n// Information about the player -- initial values are here\nvar player = {\n    health: MAX_HEALTH,\n    x: -200,  // initially off-screen\n    y: 0,\n    width: 190,\n    height: 150,\n    weapon: Weapon.BLASTER,\n    image: blasterPlayerImage,\n    lastFired: -Infinity,\n    lastCollided: -Infinity,\n    gotShieldAt: -Infinity,\n    gotFireAt: -Infinity\n};\n\n// For keeping track of what mode (state) the game is in\nvar State = {\n    START: 0,\n    PLAYING: 1,\n    PAUSED: 2,\n    LOST: 3,\n    WON: 4\n};\nvar state = State.START;\n\n// Containers for game objects\nvar enemies = [],\n    explosions = [],\n    missiles = [],\n    pods = [],\n    powerUps = [],\n    nukes = [],\n    stars = [];\n\n// The frame number at particular state transitions\nframeCount = 0;  // Global frame counter\nvar finalFrame = 0;\nvar pausedFrame = 0;\n\n// Number of objects destroyed\nvar score = 0;\n\nvar gameOverMessages = {};\n\n// Our default font\n// TODO: Put this back when CS ppl fix their bug\n\n// Position of the scrolling background\nvar backgroundOffset = 0;\n\n// Whether the canvas ever had mouse focus\nvar hasHadFocus = false;\n\n\n/////////////////////////////////////////////////////////////\n// Utility functions\n\n/**\n * Gets the sign of a number.\n * @param {number} num The number.\n * @return {number} 1 if positive, -1 if negative, else 0.\n */\nvar sign = function(num) {\n    if (num > 0) {\n        return 1;\n    } else if (num < 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Gets if a point is within a bounding box.\n * @param {number} x The x-coordinate of the point.\n * @param {number} y The y-coordinate of the point.\n * @param {Object} box The bounding rectangle.\n * @return {boolean} Whether the point is within the box.\n */\nvar inBox = function(x, y, box) {\n    return (x >= box.x && x < box.x + box.width &&\n            y >= box.y && y < box.y + box.height);\n};\n\n// TODO: replace with built-in dist\n/**\n * Calculates the Euclidean distance between two points.\n * @param {number} x1 x-coordinate of the first point.\n * @param {number} y1 y-coordinate of the first point.\n * @param {number} x2 x-coordinate of the second point.\n * @param {number} y2 y-coordinate of the second point.\n * @return {number} Distance between the given points.\n */\nvar getDistance = function(x1, y1, x2, y2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n};\n\n/**\n * Gets the difference of two angles wrapped to [-180, 180].\n * @param {number} lhs The left-hand-side angle in degrees.\n * @param {number} rhs The right-hand-side angle in degrees.\n * @return {number} Difference in range [-180, 180].\n */\nvar angleDiff = function(lhs, rhs) {\n    var diff = lhs - rhs;\n\n    while (diff > 180) {\n        diff -= 360;\n    }\n    while (diff <= -180) {\n        diff += 360;\n    }\n\n    return diff;\n};\n\n/**\n * Gets the closest body to the given (x, y) coordinates.\n * @param {number} x\n * @param {number} y\n * @param {Array.<Object>} bodies Bodies to search through.\n * @return {Object} The closest body to the given point.\n */\nvar findClosest = function(x, y, bodies) {\n    var closestDist = Infinity;\n    var closestBody = null;\n    for (var i = 0; i < bodies.length; i += 1) {\n        var body = bodies[i];\n        var dist = getDistance(x, y, body.x, body.y);\n        if (dist < closestDist) {\n            closestDist = dist;\n            closestBody = body;\n        }\n    }\n    return closestBody;\n};\n\n\n/////////////////////////////////////////////////////////////\n// Projectiles\n\nvar createBody = function(x, y) {\n    return {\n        x: x,\n        y: y,\n        deathFrame: Infinity\n    };\n};\n\nvar createProjectile = function(x, y, dx, dy) {\n    var projectile = createBody(x, y);\n    projectile.dx = dx;\n    projectile.dy = dy;\n    return projectile;\n};\n\nvar updateProjectiles = function(projectiles) {\n    for (var i = 0; i < projectiles.length; i += 1) {\n        var body = projectiles[i];\n        body.x += body.dx;\n        body.y += body.dy;\n\n        // Delete old projectiles or out-of-frame projectiles\n        var inBounds = inBox(body.x, body.y, boundsCanvas);\n        if (body.deathFrame <= frameCount || !inBounds) {\n            projectiles.splice(i, 1);\n        }\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Player\n\n/** Change player position from mouse position. */\nvar movePlayer = function() {\n    player.x = mouseX * canvasScale - 96;\n    player.y = mouseY * canvasScale - 146;\n\n    player.x = constrain(player.x, 0, canvas.width - 100);\n    player.y = constrain(player.y, 0, canvas.height - 100);\n};\n\n/**\n * Change the player\'s weapon.\n * @param {Weapon} weapon The weapon to change to.\n */\nvar changeWeapon = function(weapon) {\n    if (weapon === Weapon.BLASTER) {\n        player.image = blasterPlayerImage;\n    } else if (weapon === Weapon.SHOTGUN) {\n        player.image = shotgunPlayerImage;\n    } else if (weapon === Weapon.MG) {\n        player.image = mgPlayerImage;\n    }\n    player.weapon = weapon;\n};\n\nvar getWeaponDelay = function() {\n    if (player.weapon === Weapon.BLASTER) {\n        return BLASTER_DELAY;\n    } else if (player.weapon === Weapon.SHOTGUN) {\n        return SHOTGUN_DELAY;\n    } else if (player.weapon === Weapon.MG) {\n        return MG_DELAY;\n    }\n};\n\nvar hasShield = function() {\n    return frameCount - player.gotShieldAt < SHIELD_FRAMES;\n};\n\nvar hasFire = function() {\n    return frameCount - player.gotFireAt < FIRE_FRAMES;\n};\n\n/** Show loss of health for a few frames after being hit. */\nvar drawPlayerImpact = function() {\n    var impactFrames = 15;\n    if (frameCount - player.lastCollided >= impactFrames) {\n        return;\n    }\n\n    // Draw an expanding ellipse that fades out\n    var progress = (frameCount - player.lastCollided) /\n            impactFrames;\n    var width = player.width + progress * 20;\n    var height = player.height + progress * 20;\n    noStroke();\n    fill(220, 70, 20, 200 - progress * 200);\n    ellipse(player.x + 89, player.y + 120, width, height);\n};\n\nvar drawPlayer = function() {\n    image(player.image, player.x, player.y);\n    if (hasShield()) {\n        var shieldLeft = 1.0 - (frameCount - player.gotShieldAt) / SHIELD_FRAMES;\n        if (shieldLeft > 0.2 || (frameCount / 2) % 2 === 0) {\n            strokeWeight(20);\n            stroke(103, 207, 124, 150);\n            fill(103, 207, 124, 100 * shieldLeft);\n            ellipse(player.x + 89, player.y + 120,\n                    player.width, player.height);\n        }\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Explosions\n\n/** Start an explosion animation at the given coordinate. */\nvar setExplosion = function(x, y, radius) {\n    var explosion = createBody(x, y);\n    if (radius === undefined) {\n        radius = 20;\n    }\n    explosion.radius = radius;\n    explosion.deathFrame = frameCount + EXPLOSION_FRAMES;\n    explosions.push(explosion);\n};\n\nvar drawExplosions = function() {\n    for (var i = explosions.length - 1; i >= 0; i -= 1) {\n        var explosion = explosions[i];\n        var aliveFor = 1 + EXPLOSION_FRAMES -\n                (explosion.deathFrame - frameCount);\n        var r1 = explosion.radius * aliveFor;\n        noStroke();\n        fill(237, 134, 70, 255 - aliveFor * 40);\n        ellipse(explosion.x, explosion.y, r1, r1);\n        var r2 = 0.7 * r1;\n        fill(237, 204, 70, 255 - aliveFor * 35);\n        ellipse(explosion.x, explosion.y, r2, r2);\n        if (frameCount >= explosion.deathFrame) {\n            explosions.splice(i, 1);\n        }\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Missiles\n\nvar createMissile = function(x, y, dx, dy, weapon, enemy) {\n    var missile = createProjectile(x, y, dx, dy);\n\n    // Set missile weapon and damage from weapon type\n    missile.weapon = weapon;\n    if (weapon === Weapon.BLASTER) {\n        missile.damage = BLASTER_DAMAGE;\n    } else if (weapon === Weapon.SHOTGUN) {\n        missile.damage = SHOTGUN_DAMAGE;\n    } else if (weapon === Weapon.MG) {\n        missile.damage = MG_DAMAGE;\n    } else if (weapon === Weapon.POD) {\n        missile.damage = POD_DAMAGE;\n    } else if (weapon === Weapon.SHRAPNEL) {\n        missile.damage = SHRAPNEL_DAMAGE;\n    } else if (weapon === Weapon.ROBOT) {\n        missile.trail = [];\n        missile.phase = random() * 360;\n    }\n\n    missile.enemy = enemy;\n\n    // If fire bullets bonus is active, make missile better\n    missile.onFire = false;\n    if (!missile.enemy && hasFire()) {\n        missile.onFire = true;\n        missile.damage += FIRE_DAMAGE;\n        missile.dx *= FIRE_SPEED_FACTOR;\n        missile.dy *= FIRE_SPEED_FACTOR;\n    }\n\n    missiles.push(missile);\n    return missile;\n};\n\nvar firePlayerMissiles = function() {\n    // Only fire on command\n    if (!mouseIsPressed && !keyIsPressed) {\n        return;\n    }\n\n    // Wait for the next round to be chambered\n    if (frameCount - player.lastFired < getWeaponDelay()) {\n        return;\n    }\n\n    var x = player.x + player.width * 0.7;\n    var y = player.y + player.height * 0.9;\n    var dx, dy;\n\n    if (player.weapon === Weapon.BLASTER) {\n        createMissile(x, y, 15, 0, player.weapon);\n    } else if (player.weapon === Weapon.SHOTGUN) {\n        for (var i = 0; i < SHOTGUN_PELLETS; ++i) {\n            var angle = SHOTGUN_SPREAD * (random() - 0.5);\n            var speed = SHOTGUN_SPEED + random() * 6;\n            dx = speed * cos(angle);\n            dy = speed * sin(angle);\n            createMissile(x, y, dx, dy, player.weapon);\n        }\n    } else if (player.weapon === Weapon.MG) {\n        dx = random() * 5 + MG_SPEED;\n        dy = (random() - 0.5) * MG_SPREAD;\n        createMissile(x, y, dx, dy, player.weapon);\n    }\n    player.lastFired = frameCount;\n};\n\nvar updateMissiles = function() {\n    for (var i = 0; i < missiles.length; i += 1) {\n        var missile = missiles[i];\n        if (missile.weapon === Weapon.ROBOT) {\n            missile.trail.push({\n                x: missile.x,\n                y: missile.y\n            });\n            missile.dy = (5 + random() * 5) *\n                    sin(missile.phase);\n            missile.dx += (random() - 0.5);\n            missile.phase += 5 + random() * 5;\n        }\n    }\n    updateProjectiles(missiles);\n};\n\nvar drawMissiles = function() {\n    for (var i = 0; i < missiles.length; i += 1) {\n        var missile = missiles[i];\n\n        if (missile.onFire) {\n            noStroke();\n            fill(223, 175, 80, 100);\n            pushMatrix();\n            translate(missile.x, missile.y);\n            rotate(atan2(missile.dy, missile.dx));\n            translate(-40, 0);\n            ellipse(0, 0, 120, 15);\n            popMatrix();\n        }\n\n        if (missile.weapon === Weapon.BLASTER) {\n            noStroke();\n            fill(179, 69, 36);\n            ellipse(missile.x, missile.y, 17, 15);\n        } else if (missile.weapon === Weapon.SHOTGUN) {\n            noStroke();\n            fill(255, 222, 92);\n            ellipse(missile.x, missile.y, 15, 15);\n        } else if (missile.weapon === Weapon.MG) {\n            noStroke();\n            fill(165, 207, 87);\n            ellipse(missile.x, missile.y, 22, 12);\n        } else if (missile.weapon === Weapon.POD) {\n            strokeWeight(2);\n            stroke(127, 200, 224, 200);\n            fill(127, 200, 224, 100);\n            ellipse(missile.x, missile.y, 15, 15);\n        } else if (missile.weapon === Weapon.SHRAPNEL) {\n            noStroke();\n            fill(29, 31, 31, 200);\n            ellipse(missile.x, missile.y, 13, 13);\n        } else if (missile.weapon === Weapon.ROBOT) {\n            noStroke();\n            var opacity = 220;\n            var trail = missile.trail;\n            for (var j = trail.length - 1; j >= 0; j -= 1) {\n                var puff = trail[j];\n                fill(220, 220, 220, opacity);\n                ellipse(puff.x, puff.y, 13, 13);\n                opacity *= 0.8;\n            }\n            strokeWeight(3);\n            stroke(20, 20, 20, 200);\n            fill(230, 230, 230, 220);\n            ellipse(missile.x, missile.y, 17, 17);\n        }\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Robot enemy\n\n/** Programs the robot to go towards the player */\nvar setRobotCourse = function(robot) {\n    robot.destX = canvas.width - 100;\n    robot.destY = player.y + player.height * 0.7;\n};\n\n/** Move a robot towards its programmed destination. */\nvar moveRobot = function(robot) {\n    if (robot.moveAt === frameCount) {\n        setRobotCourse(robot);\n    }\n    var deltaX = robot.destX - robot.x;\n    robot.dx = sign(deltaX) * sqrt(abs(deltaX));\n    var deltaY = robot.destY - robot.y;\n    robot.dy = sign(deltaY) * sqrt(abs(deltaY));\n};\n\nvar fireRobotMissiles = function(robot) {\n    // Gotta wait for missiles to reload first\n    if (frameCount - robot.lastFired < ROBOT_RELOAD) {\n        return;\n    }\n\n    // Don\'t shoot if we haven\'t arrived at the destination\n    var threshold = 5;\n    if (abs(robot.x - robot.destX) > threshold ||\n            abs(robot.y - robot.destY) > threshold) {\n        return;\n    }\n\n    // Fire off a volley\n    for (var i = 0; i < ROBOT_SALVO; i += 1) {\n        var dx = -20 - 10 * random();\n        createMissile(robot.x, robot.y, dx, 0, Weapon.ROBOT,\n                /* enemy */ true);\n    }\n    robot.lastFired = frameCount;\n\n    // Stay here, then move after a bit\n    robot.moveAt = max(frameCount,\n            frameCount + ROBOT_RELOAD - 20);\n};\n\n\n/////////////////////////////////////////////////////////////\n// Enemies\n\n/** Spawn a random enemy. */\nvar createEnemy = function() {\n    // Spawn an enemy somewhere on the right\n    var speedFactor = 1.0 + min(8,\n            ENEMY_SPEED_RATE * frameCount);\n    var x = canvas.width;\n    var y = random() * (canvas.height - 200) +  100;\n    var dx = speedFactor * (-ENEMY_BASE_SPEED - random() * 5);\n    var dy = speedFactor * ENEMY_BASE_SPEED * (random() - 0.5);\n    var enemy = createProjectile(x, y, dx, dy);\n\n    // Spawn robots after some point\n    if (frameCount >= ROBOTS_COME_AT &&\n            random() < ROBOT_PROBABILITY) {\n        enemy.type = Enemy.ROBOT;\n        enemy.image = enemyRobotImage;\n        enemy.health = ROBOT_HEALTH;\n        enemy.lastFired = frameCount;\n        setRobotCourse(enemy);\n    } else if (frameCount >= BUGS_COME_AT &&\n            random() < min(0.3, frameCount * 0.0001)) {\n        // Spawn more bugs as the game goes on\n        enemy.type = Enemy.BUG;\n        enemy.image = enemyBugImage;\n        enemy.dx *= BUG_SPEED_FACTOR;\n        enemy.dy *= BUG_SPEED_FACTOR;\n        enemy.health = BUG_HEALTH;\n        enemy.homesAt = frameCount + BUG_HOMES_AT;\n    } else {\n        enemy.type = Enemy.ROCK;\n        enemy.image = enemyRockImage;\n        enemy.health = ROCK_HEALTH;\n    }\n    enemy.health *= (1 + ENEMY_HEALTH_RATE * frameCount);\n\n    enemy.width = enemy.image.width;\n    enemy.height = enemy.image.height;\n    enemy.angle = 0;\n    enemy.angleSpeed = random() - 0.5;\n    enemies.push(enemy);\n    return enemy;\n};\n\n/** Turn a bug a few degrees towards the player. */\nvar moveBug = function(bug) {\n    var speed = sqrt(pow(bug.dx, 2) + pow(bug.dy, 2));\n    var targetAngle = atan2(player.y - bug.y,\n            player.x - bug.x) + (5 * (random() - 0.5));\n    var diff = angleDiff(targetAngle, bug.angle);\n    diff = constrain(diff, -BUG_TURN_RATE, BUG_TURN_RATE);\n    bug.angle += diff;\n    bug.dx = speed * cos(bug.angle);\n    bug.dy = speed * sin(bug.angle);\n};\n\nvar updateEnemies = function() {\n    // Don\'t create enemies before we\'re zoomed in\n    if (frameCount < START_FRAMES + ZOOM_IN_FRAMES) {\n        return;\n    }\n\n    // Possibly create some new enemies\n    var enemyChance = min(1, ENEMY_GROWTH_RATE * frameCount);\n    enemyChance -= random();\n    while (enemyChance > 0) {\n        createEnemy();\n        enemyChance -= random();\n    }\n\n    for (var i = enemies.length - 1; i >= 0; i -= 1) {\n        var enemy = enemies[i];\n\n        // Remove this enemy if it\'s dead\n        if (enemy.health <= 0) {\n            enemies.splice(i, 1);\n            continue;\n        }\n\n        if (enemy.type === Enemy.ROCK) {\n            enemy.angle += enemy.angleSpeed;\n        } else if (enemy.type === Enemy.BUG) {\n            enemy.angle = atan2(enemy.dy, enemy.dx);\n            if (frameCount >= enemy.homesAt) {\n                moveBug(enemy);\n            }\n        } else if (enemy.type === Enemy.ROBOT) {\n            moveRobot(enemy);\n            fireRobotMissiles(enemy);\n        }\n    }\n    updateProjectiles(enemies);\n};\n\nvar drawEnemies = function() {\n    for (var i = 0; i < enemies.length; i += 1) {\n        var enemy = enemies[i];\n        pushMatrix();\n        translate(enemy.x, enemy.y);\n        rotate(enemy.angle);\n        if (enemy.type === Enemy.BUG) {\n            scale(1, -1);\n        } else if (enemy.type === Enemy.ROBOT) {\n            scale(-1, 1);\n        }\n        translate(enemy.width * -0.5,\n                  enemy.height * -0.5);\n        image(enemy.image, 0, 0);\n        popMatrix();\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Pods - helpful orbiting ship pods\n\nvar createPod = function() {\n    var pod = createBody(0, 0);\n    pod.image = podImage;\n    pod.angle = 0;\n    pod.startFrame = frameCount;\n    pods.push(pod);\n    return pod;\n};\n\nvar updatePods = function() {\n    for (var i = 0; i < pods.length; i += 1) {\n        // Move a few degrees in a circle around the player\n        var pod = pods[i];\n        pod.angle = (pod.angle + 10) % 360;\n        var x = 140 * cos(pod.angle);\n        var y = 140 * sin(pod.angle);\n        pod.x = player.x + player.width / 2 + x;\n        pod.y = player.y + player.height / 2 + y;\n\n        // Fire missile towards closest enemy\n        if (frameCount % max(1, POD_DELAY) === 0) {\n            var enemy = findClosest(pod.x, pod.y, enemies);\n            if (enemy) {\n                var angle = atan2(enemy.y - pod.y,\n                        enemy.x - pod.x);\n                var dx = POD_MISSILE_SPEED * cos(angle);\n                var dy = POD_MISSILE_SPEED * sin(angle);\n                createMissile(pod.x, pod.y, dx, dy,\n                        Weapon.POD);\n            }\n        }\n    }\n};\n\nvar drawPods = function() {\n    for (var i = 0; i < pods.length; i += 1) {\n        var pod = pods[i];\n        image(pod.image, pod.x, pod.y, pod.image.width * 0.5,\n                pod.image.height * 0.5);\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Nuke explosions\n\nvar createNuke = function(x, y) {\n    var nuke = createBody(x, y);\n    nuke.deathFrame = frameCount + NUKE_FRAMES;\n    nuke.radius = 0;\n    nukes.push(nuke);\n\n    // Also set off shrapnel\n    for (var i = 0; i < NUKE_NUM_SHRAPNEL; i += 1) {\n        var angle = random() * 360;\n        var speed = 30 + random() * 20;\n        var dx = speed * cos(angle);\n        var dy = speed * sin(angle);\n        createMissile(x, y, dx, dy, Weapon.SHRAPNEL);\n    }\n\n    return nuke;\n};\n\nvar updateNukes = function() {\n    for (var i = 0; i < nukes.length; i += 1) {\n        var nuke = nukes[i];\n        nuke.radius += NUKE_RADIUS / NUKE_FRAMES;\n    }\n};\n\nvar drawNukes = function() {\n    for (var i = 0; i < nukes.length; i += 1) {\n        var nuke = nukes[i];\n        var progress = nuke.radius / NUKE_RADIUS;\n\n        // Draw a shockwave\n        strokeWeight(20);\n        stroke(255, 255, 255, 20);\n        fill(255, 255, 255, 20);\n        var blastRadius = nuke.radius + 10;\n        ellipse(nuke.x, nuke.y, blastRadius, blastRadius);\n\n        // Draw the flames\n        noStroke();\n        fill(220 - progress * 80,\n             200 - progress * 170,\n             30,\n             255 - 255 * progress);\n        var flameRadius = nuke.radius * 0.5;\n        ellipse(nuke.x, nuke.y, flameRadius, flameRadius);\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Background stars\n\n// Idea for these stars is totally ripped off from Ben\n// Kamen\'s awesome Boids - khanacademy.org/cs/boids/940061217\n\nvar createStar = function() {\n    var star = createProjectile(canvas.width + 20,\n            random() * canvas.height, 0, 0);\n    var radius = 2 + random() * 15;\n    star.width = radius;\n    star.height = radius;\n    star.color = color(200 + random() * 50,\n                       200 + random() * 50,\n                       180 + random() * 50,\n                       random() * 200\n    );\n    return star;\n};\n\nvar updateStars = function() {\n    var chance = 0.02 * sq(canvasScale);\n    chance -= random();\n    while (chance > 0) {\n        stars.push(createStar());\n        chance -= random();\n    }\n    var speed = floor(SCROLL_SPEED + 0.001 * frameCount);\n    for (var i = 0; i < stars.length; i += 1) {\n        var star = stars[i];\n        star.dx = -speed * canvasScale * (\n                0.3 + 0.01 * sq(star.width));\n    }\n    updateProjectiles(stars);\n};\n\nvar drawStars = function() {\n    noStroke();\n    for (var i = 0; i < stars.length; i += 1) {\n        var star = stars[i];\n        fill(star.color);\n        ellipse(star.x, star.y, star.width, star.height);\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Power ups\n\n/** Create a power up at the given coordinates. */\nvar createPowerUp = function(x, y) {\n    var powerUp = createProjectile(x, y, 0, 0);\n    powerUp.deathFrame = frameCount + POWER_UP_LIFETIME;\n    powerUp.scale = 1;\n\n    // Select and customize the bonus\n    var randVal = random();\n\n    // Give only weapon power-ups if we have a crappy one,\n    // but not too soon so player can feel the pain first\n    if (randVal < 0.01 || (\n            player.weapon === Weapon.BLASTER &&\n            frameCount >= WEAPON_BONUS_AT)) {\n        if (random() < 0.5) {\n            powerUp.type = PowerUp.MG;\n            powerUp.image = mgBonusImage;\n        } else {\n            powerUp.type = PowerUp.SHOTGUN;\n            powerUp.image = shotgunBonusImage;\n        }\n\n    // Less chance of another pod if we have lots of pods\n    } else if (randVal < 0.01 + 0.4 / pow(pods.length + 1, 2)) {\n        powerUp.type = PowerUp.POD;\n        powerUp.image = podBonusImage;\n\n    // Only drop health bonuses if we\'re not at full health\n    } else if (randVal < 0.06 && player.health < MAX_HEALTH) {\n        powerUp.type = PowerUp.HEALTH;\n        powerUp.image = healthBonusImage;\n\n    } else {\n        var choice = floor(random() * 15);\n        if (choice < 5) {\n            powerUp.type = PowerUp.SHIELD;\n            powerUp.image = shieldBonusImage;\n        } else if (choice < 10) {\n            powerUp.type = PowerUp.FIRE;\n            powerUp.image = fireBonusImage;\n        } else if (choice < 15) {\n            powerUp.type = PowerUp.NUKE;\n            powerUp.image = nukeBonusImage;\n        }\n    }\n\n    powerUps.push(powerUp);\n    return powerUp;\n};\n\nvar updatePowerUps = function() {\n    for (var i = 0; i < powerUps.length; ++i) {\n        var powerUp = powerUps[i];\n        powerUp.dx += random() - 0.57;\n        powerUp.dy += random() - 0.5;\n        if (powerUp.taken) {\n            powerUp.scale = max(0,\n                    1 - (frameCount - powerUp.taken) / 16);\n        }\n    }\n    updateProjectiles(powerUps);\n};\n\nvar drawPowerUps = function() {\n    for (var i = 0; i < powerUps.length; ++i) {\n        var powerUp = powerUps[i];\n\n        // Flash the power-up if it\'s about to die\n        if (powerUp.deathFrame - frameCount <= 20 &&\n                (frameCount / 2) % 2 === 0 &&\n                state === State.PLAYING) {\n            continue;\n        }\n\n        var scaledWidth = powerUp.image.width * powerUp.scale;\n        var scaledHeight = powerUp.image.height * powerUp.scale;\n\n        // Draw an aura to attract attention\n        var pulse = 25 * sin((frameCount % 50) / 50 * 180);\n        noStroke();\n        fill(255, 255, 180, 40 - pulse);\n        var centerX = powerUp.x + powerUp.image.width / 2;\n        var centerY = powerUp.y + powerUp.image.height / 2;\n        ellipse(centerX, centerY, scaledWidth + pulse,\n                scaledHeight + pulse);\n\n        var x = powerUp.x + (powerUp.image.width - scaledWidth) / 2;\n        var y = powerUp.y + (powerUp.image.height - scaledHeight) / 2;\n        image(powerUp.image, x, y, scaledWidth, scaledHeight);\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Game states\n\nvar gameOver = function() {\n    state = State.LOST;\n    finalFrame = frameCount;\n\n    // Randomly choose some messages to show\n    var verbs = [\n        \"You cleaned up\",\n        \"You obliterated\",\n        \"You vanquished\",\n        \"You took care of\",\n        \"You annihilated\",\n        \"You blew up\"\n    ];\n    var nouns = [\n        \"space hazards!\",\n        \"space bogeys!\",\n        \"problems!\",\n        \"near-Earth objects!\"\n    ];\n    var tips = [\n        \"Don\'t engage robots until you\'re\\n\" +\n            \"armed with fire bullets.\",\n        \"You can hold down the mouse button\\n\" +\n            \"or any keyboard key to fire continuously.\",\n        \"It\'s possible to win!\",\n        \"Click outside the game window to pause.\",\n        \"As enemies get faster and more furious,\\n\" +\n            \"always be armed with fire bullets and a shield\",\n        \"Get fire bullets (red leaf bonus) to make\\n\" +\n            \"the nuke (yellow leaf bonus) better.\"\n    ];\n\n    gameOverMessages = {\n        verb: verbs[floor(random() * verbs.length)],\n        noun: nouns[floor(random() * nouns.length)],\n        tip: tips[floor(random() * tips.length)]\n    };\n};\n\nvar nukeAllEnemies = function() {\n    for (var i = enemies.length - 1; i >= 0; i -= 1) {\n        var enemy = enemies[i];\n        createNuke(enemy.x, enemy.y);\n        score += 1;\n        enemies.pop();\n    }\n};\n\nvar pause = function() {\n    state = State.PAUSED;\n    pausedFrame = frameCount;\n};\n\nvar unpause = function() {\n    state = State.PLAYING;\n    frameCount = pausedFrame;\n};\n\nvar transitionStates = function() {\n    if (focused) {\n        hasHadFocus = true;\n    }\n\n    var winFrame = 9001;  // shh, it\'s a secret\n\n    if (state === State.PLAYING && !focused && hasHadFocus) {\n        pause();\n    } else if (state === State.PAUSED && focused) {\n        unpause();\n    } else if (state === State.START &&\n            frameCount > START_FRAMES) {\n        state = State.PLAYING;\n    } else if (state === State.PLAYING &&\n            frameCount >= winFrame) {\n        nukeAllEnemies();\n        if (frameCount >= winFrame + 100) {\n            state = State.WON;\n            finalFrame = frameCount;\n        }\n    }\n\n    if (state === State.PAUSED) {\n        frameCount = pausedFrame;\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Collisions\n\n/** Do damage to an enemy, possibly destroying it. */\nvar attackEnemy = function(enemy, damage, noBonus) {\n    enemy.health -= damage;\n    if (enemy.health > 0) {\n        return;\n    }\n\n    // Handle just defeated enemy\n    var radius = 20;\n    if (enemy.type === Enemy.ROBOT) {\n        radius = 100;\n    }\n    setExplosion(enemy.x, enemy.y, radius);\n    score += 1;\n\n    // Possibly drop a power up, but increase chance if\n    // player has a crappy weapon\n    var chance = POWER_UP_CHANCE;\n    if (player.weapon === Weapon.BLASTER) {\n        chance += 0.1;\n    }\n\n    if (noBonus !== true && frameCount >= BONUSES_DROP_AT &&\n            (enemy.type === Enemy.ROBOT ||\n             random() <= chance)) {\n        createPowerUp(enemy.x, enemy.y);\n    }\n};\n\n/** Potentially damage the player. */\nvar attackPlayer = function() {\n    if (!hasShield() && frameCount - player.lastCollided >\n            SAFE_AFTER_HIT_FRAMES) {\n        player.health -= 1;\n        player.lastCollided = frameCount;\n        if (player.health <= 0) {\n            gameOver();\n        }\n    }\n};\n\n/** Collide player\'s missiles against enemies. */\nvar collideFriendlyMissiles = function() {\n    for (var i = missiles.length - 1; i >= 0; i -= 1) {\n        var missile = missiles[i];\n        if (missile.enemy) {\n            // Ignore enemy missiles\n            continue;\n        }\n        for (var j = enemies.length - 1; j >= 0; j -= 1) {\n            var enemy = enemies[j];\n            if (inBox(missile.x, missile.y, enemy) &&\n                    enemy.health > 0) {\n                // Both missile and enemy wear out each other\n                var enemyHealth = enemy.health;\n                attackEnemy(enemy, missile.damage);\n                missile.damage -= enemyHealth;\n\n                // Remove this missile if it\'s all used up\n                if (missile.damage <= 0) {\n                    setExplosion(missile.x, missile.y, 10);\n                    missiles.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n};\n\n/** Collide enemies and enemy missiles against the player. */\nvar collidePlayer = function(bodies) {\n    for (var i = enemies.length - 1; i >= 0; i -= 1) {\n        var enemy = enemies[i];\n        if (inBox(enemy.x, enemy.y, player)) {\n            attackPlayer();\n            attackEnemy(enemy, 500, /* noBonus */ true);\n        }\n    }\n    for (var j = missiles.length - 1; j >= 0; j -= 1) {\n        var missile = missiles[j];\n        if (missile.enemy &&\n                inBox(missile.x, missile.y, player)) {\n            attackPlayer();\n            missiles.splice(j, 1);\n        }\n    }\n};\n\n/** Collide bonuses (receive them and take effect). */\nvar collidePowerUps = function() {\n    for (var i = powerUps.length - 1; i >= 0; i -= 1) {\n        var powerUp = powerUps[i];\n        if (inBox(powerUp.x, powerUp.y, player) &&\n                !powerUp.taken) {\n            if (powerUp.type === PowerUp.HEALTH) {\n                player.health += 1;\n            } else if (powerUp.type === PowerUp.SHIELD) {\n                player.gotShieldAt = frameCount;\n            } else if (powerUp.type === PowerUp.FIRE) {\n                player.gotFireAt = frameCount;\n            } else if (powerUp.type === PowerUp.POD) {\n                createPod();\n            } else if (powerUp.type === PowerUp.NUKE) {\n                createNuke(powerUp.x, powerUp.y);\n            } else {\n                changeWeapon(powerUp.type);\n            }\n            powerUp.taken = frameCount;\n        }\n        if (frameCount - powerUp.taken > 15) {\n            powerUps.splice(i, 1);\n        }\n    }\n};\n\n/** Damage enemies in the nuke\'s radius. */\nvar collideNukes = function() {\n    for (var i = nukes.length - 1; i >= 0; i -= 1) {\n        var nuke = nukes[i];\n        for (var j = 0; j < enemies.length; j += 1) {\n            var enemy = enemies[j];\n            if (getDistance(nuke.x, nuke.y, enemy.x, enemy.y) <= nuke.radius) {\n                attackEnemy(enemy, NUKE_DAMAGE);\n            }\n        }\n\n        if (frameCount >= nuke.deathFrame) {\n            nukes.splice(i, 1);\n        }\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Meta -- game information\n\n// All drawing functions here assume (0.5, 0.5) scaling\n\nvar drawScore = function() {\n    noStroke();\n    fill(0, 0, 0, 50);\n    rect(0, 0, canvas.width * 2, 60);\n    fill(239, 247, 232);\n    textSize(36);\n    text(\"Score: \" + score, 20, 40);\n};\n\nvar drawHealth = function() {\n    var x = 4 * (canvas.width - 30) / canvasScale;\n    for (var i = 0; i < min(player.health, 40); i += 1) {\n        pushMatrix();\n        scale(0.48, 0.48);\n        image(healthImage, x, -30);\n        popMatrix();\n        x -= 110;\n    }\n};\n\nvar updateBackground = function() {\n    var speed = floor(SCROLL_SPEED + 0.001 * frameCount);\n    backgroundOffset = (backgroundOffset + speed) % 800;\n};\n\nvar drawBackground = function() {\n    image(backgroundImage, -backgroundOffset + 799, 0);\n    image(backgroundImage, -backgroundOffset, 0);\n    fill(200 * sin(frameCount * 0.07) + 20,\n        200 * sin(frameCount * 0.09) + 20,\n        200 * sin(frameCount * 0.05) + 20,\n        50 + sin(frameCount * 0.2) * 40\n    );\n    rect(0, 0, canvas.width, canvas.height);\n};\n\nvar drawGameStart = function() {\n    var progress = (START_FRAMES - frameCount) / START_FRAMES;\n    var opacity = max(0, 255 * progress);\n    fill(255, 255, 255, opacity);\n    noStroke();\n    rect(0, 0, canvas.width * 2, canvas.height * 2);\n\n    fill(0, 0, 0);\n    var font = createFont(\"fantasy\", 20);\n    textFont(font, 40);\n    textSize(40);\n    text(\"Just click to fire.\", 250, 300);\n    textSize(200);\n    var count = floor(progress * 3) + 1;\n    text(count, 340, 500);\n};\n\nvar drawPaused = function() {\n    fill(255, 255, 255, 150);\n    noStroke();\n    rect(0, 0, canvas.width * 2, canvas.height * 2);\n\n    fill(0, 0, 0);\n    var font = createFont(\"fantasy\", 20);\n    textFont(font, 40);\n    textSize(100);\n    text(\"Don\'t Do It!\", 219, 258);\n    textSize(40);\n    text(\"Sal\'s in Trouble!\", 244, 339);\n};\n\nvar drawRestart = function(r, g, b, alpha) {\n    // Gratuitous restart button hint\n    pushMatrix();\n    textSize(35);\n    translate(625, 747);\n    rotate(-19);\n    fill(r, g, b, alpha);\n    text(\"Play again!\", 0, 0);\n    noFill();\n    stroke(r, g, b, alpha);\n    strokeWeight(3);\n    arc(66, 38, 55, 89, -13, 36);\n    fill(r, g, b, alpha);\n    triangle(98, 71, 79, 64, 81, 83);\n    popMatrix();\n};\n\nvar drawGameOver = function() {\n    var opacity = min(200, frameCount - finalFrame);\n    fill(0, 0, 0, opacity);\n    noStroke();\n    rect(0, 0, canvas.width * 2, canvas.height * 2);\n    fill(255, 255, 255, opacity);\n    var font = createFont(\"fantasy\", 20);\n    textFont(font, 50);\n    text(\"You\'ve let Sal Down!\", 100, 100);\n    textSize(40);\n    text(gameOverMessages.verb, 100, 200);\n    text(gameOverMessages.noun, 100, 520);\n\n    // Show a tip\n    fill(255, 255, 120, opacity * 0.6);\n    textSize(32);\n    text(\"Tip:\", 30, 600);\n    fill(255, 255, 120, opacity);\n    text(gameOverMessages.tip, 100, 600);\n    textSize(200);\n\n    // Have score count up to final score\n    fill(255, 255, 255, opacity);\n    text(min((frameCount - finalFrame) * 7, score),\n            100, 415);\n\n    drawRestart(100, 255, 100, opacity);\n};\n\nvar drawWin = function() {\n    var opacity = min(200, frameCount - finalFrame);\n    fill(255, 255, 255, opacity);\n    noStroke();\n    rect(0, 0, canvas.width * 2, canvas.height * 2);\n    fill(0, 0, 0, opacity);\n    var font = createFont(\"fantasy\", 20);\n    textFont(font, 50);\n    text(\"OMG, you won!!!11one0.999...\", 80, 100);\n    textSize(40);\n    text(\"For neutralizing\", 100, 200);\n    text(\"space invaders, you win this level!\", 80, 520);\n    textSize(200);\n    // Have score count up to final score\n    text(min((frameCount - finalFrame) * 23, score), 100,\n            415);\n\n    drawRestart(10, 60, 10, opacity);\n};\n\nvar drawDebug = function() {\n    fill(255, 255, 255);\n    textSize(36);\n    text(\"Frame \" + frameCount + \" Mouse (\" + mouseX +\n            \", \" + mouseY + \")\", 200, 40);\n};\n\n/** Draw game screens and general game info. */\nvar drawMeta = function() {\n    resetMatrix();\n    scale(0.5, 0.5);\n\n    if (state === State.PLAYING || state === State.PAUSED) {\n        drawHealth();\n        drawScore();\n    }\n\n    if (state === State.START) {\n        drawGameStart();\n    } else if (state === State.PAUSED) {\n        drawPaused();\n    } else if (state === State.LOST) {\n        drawGameOver();\n    } else if (state === State.WON) {\n        drawWin();\n    }\n\n    if (state === State.PLAYING) {\n        noCursor();\n    } else {\n        cursor();\n    }\n\n    if (DEBUG) {\n        drawDebug();\n    }\n};\n\n/** Set how zoomed out the screen is. */\nvar setScale = function(scaling) {\n    canvasScale = scaling;\n    canvas.height = height * scaling;\n    canvas.width = width * scaling;\n    boundsCanvas.width = canvas.width + 400;\n    boundsCanvas.height = canvas.height + 400;\n};\n\nvar updateScale = function() {\n    // Initially start from a large scale and zoom in\n    if (frameCount < START_FRAMES + ZOOM_IN_FRAMES) {\n        var progress = (frameCount - START_FRAMES) /\n                ZOOM_IN_FRAMES;\n        setScale(STARTING_SCALE + 2 * (1 - progress));\n    } else {\n        var frames = frameCount - START_FRAMES -\n                ZOOM_IN_FRAMES;\n        var newScale = min(4, STARTING_SCALE +\n                SCALE_INCREASE * frames);\n        setScale(newScale);\n    }\n};\n\n\n/////////////////////////////////////////////////////////////\n// Main game loop\n\nsetScale(STARTING_SCALE + 2);\n\nvar draw = function() {\n    transitionStates();\n\n    // Update game logic objects\n    if (state === State.PLAYING) {\n        updateScale();\n        movePlayer();\n        firePlayerMissiles();\n        updateEnemies();\n        updatePods();\n        updateNukes();\n        updateMissiles();\n        updatePowerUps();\n        updateBackground();\n        updateStars();\n\n        collidePlayer();\n        collidePowerUps();\n        collideFriendlyMissiles();\n        collideNukes();\n    } else if (state === State.START) {\n        updateStars();\n        updateStars();\n    }\n\n    // Reset transformation matrix for constant scaling (so\n    // we don\'t scale scales from the previous iterations)\n    resetMatrix();\n    drawBackground();\n    scale(1 / canvasScale, 1 / canvasScale);\n\n    // Draw game graphical elements.\n    drawStars();\n    drawPowerUps();\n    drawEnemies();\n    drawMissiles();\n    drawPods();\n    drawPlayerImpact();\n    drawPlayer();\n    drawNukes();\n    drawExplosions();\n\n    drawMeta();\n};";
window.liveEditor = new LiveEditor({
                el: $("#sample-live-editor"),
                code: code,
                width: 400,
                height: 400,
                editorHeight: "80%",
                autoFocus: true,
                workersDir: "../../build/workers/",
                externalsDir: "../../build/external/",
                imagesDir: "../../build/images/",
                soundsDir: "../../sounds/",
                execFile: outputUrl,
                jshintFile: "../../build/external/jshint/jshint.js",
                newErrorExperience: true,
            });
            liveEditor.editor.on("change", function() {
                window.localStorage["test-code"] = liveEditor.editor.text();
            });
            ScratchpadAutosuggest.init(liveEditor.editor.editor);
            </script>
        </body>
        </html>
        