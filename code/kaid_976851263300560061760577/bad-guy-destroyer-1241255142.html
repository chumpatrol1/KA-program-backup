<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Bad Guy Destroyer</title>
    <link rel="stylesheet" href="../../build/css/live-editor.core_deps.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.audio.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.tooltips.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.ui.css"/>
<style>
        body {
            padding: 20px;
        }
        h1 {
            padding: 0;
            margin: 0 0 20px 0;
        }
        #sample-live-editor {
            padding: 0;
        }
    </style>
</head>
<body>
    <h1>Bad Guy Destroyer</h1>
    <div id="sample-live-editor"></div>
    <script src="../../build/js/live-editor.core_deps.js"></script>
    <script src="../../build/js/live-editor.editor_ace_deps.js"></script>
    <script src="../../build/js/live-editor.audio.js"></script>
    <script src="../../build/js/live-editor.shared.js"></script>
    <script src="../../build/js/live-editor.tooltips.js"></script>
    <script src="../../build/js/live-editor.ui.js"></script>
    <script src="../../build/js/live-editor.editor_ace.js"></script>
    <script>
    var outputUrl = "../output.html";
var code = "/**Bad Guy Destroyer by David Elijah de Siqueira Campos McLaughlin\nOriginal size(400, 400);\nOriginally Created on 2012-12-20T02:28:53Z by kaid_976851263300560061760577\nLast Edited: 2012-12-20T02:28:53Z\nVotes/Spinoffs: 1/0\nOriginally Created: 2012-12-20T13:53:07Z from origin 1106141208 with similarity of 0.9993483882791342\nOriginal Link: https://www.khanacademy.org/computer-programming/bad-guy-destroyer/1241255142\nRetrieved On: 07-Nov-2022 (17:07:27.599093)**/\
";

code = code + "\n/** I think I\'m really close!\nDo NOT press SPACE until you\'ve read the instructions below:\n * \n * The name has changed.\n * Note: I think any old links will get you here.\n * \n * How to play:\n ** Click on a tower icon (the little people in the \n ** spaceships) in the lower left corner to select\n ** that tower. Then click the screen (note 1) to place the\n ** tower. The number shows the cost of the tower â€“ you\n ** only start with \"$\"350! (note 2) When you are ready,\n ** press SPACE to start. 10 rocks will appear on the screen,\n ** one by one, with a health of 45. Your towers will shoot\n ** them.  When ALL the rocks have spawned (note 3), you can\n ** press SPACE to spawn the next wave: 12 rocks and 3 bugs.\n ** Each time you kill an enemy, you get a small money gain,\n ** but that can REALLY add up.\n ** You can get information like tower ranges in the Game\n ** Constants section of the code.\n **\n ** UPGRADES: Click a TOWER (not the icons in the white area)\n ** to select it. Then you can press the 1, 2, and 3 keys\n ** on your keyboard to upgrade it, or press S to sell the\n ** tower for 60% (note 4) of the original cost.\n ** \n ** \n * NOTES:\n * Note 1: You cannot place a tower you cannot afford.\n ** To select a different tower icon, click the other icon.\n ** To cancel, click the same tower icon.\n * \n * Note 2: You can change the starting money.\n * \n * Note 3: You can spawn a new wave even when there are\n ** still enemies from the last wave on the track.\n * \n * Note 4: SELLING_RATIO is set at 3/5.\n * \n * \n * Regular and Fast towers only fire at the closest enemy \n ** in their range, but 360 towers (yellow ship) fire \n ** only if an enemy is close. They don\'t fire at a specific\n ** enemy, but rather in fixed directions (if it fires 8\n ** bullets, there is a 360 / 8, or 45, degree gap between\n ** the bullets).\n * \n * \n * Ideas for Spin-Offs:\n ** Try changing the map. Make a spiral, an up and down course,\n *** a \"meta-squiggle\" from Vi Hart\'s video \"Squiggle\n *** Inception\", or whatever you want.\n ** Make more towers! A \"freeze tower\", or maybe a really \n *** slow shooting tower that does huge damage, or anything.\n * \n ** Make more enemies! Maybe make one that gets angrier\n *** and goes faster the more you hit it. Or one that disables\n *** towers!\n ** Make new waves!\n * \n * Here\'s the wave list:\n * NOTE: You CANNOT change the waves here. To change them,\n * go to the end of the section Game variables, and you\'ll\n * see it.\n * \"x30\" means that pattern repeats 30 times.\n * \n * \n * Wave 1: 10 rocks.\n * Wave 2: 12 rocks and 3 bugs.\n * Wave 3: 20 rocks, then 5 bugs.\n * Wave 4: 30 rocks, 10 bugs.\n * Wave 5: 3 rocks and 3 bugs, x10.\n * Wave 6: 40 bugs.\n * Wave 7: 25 bugs and 20 rocks.\n * Wave 8: 1 strong, then 20 rocks, then 12 bugs.\n * Wave 9: 2 strongs, then 18 bugs.\n * Wave 10: 12 strongs.\n * Wave 11: 2 strongs, then 20 rocks, then 2 more strongs.\n * Wave 12: 2 rocks and 2 bugs, x10. Then 3 strong enemies. Then 15 more rocks.\n * Wave 13: 80 bugs.\n * Wave 14: 40 bugs and 60 rocks.\n * Wave 15: 120 rocks.\n * Wave 16: 20 rocks, 20 bugs, 1 strong, x4.\n * Wave 17: 120 rocks. Then 20 bugs. Then 30 more rocks.\n * Wave 18: 18 strongs, then 50 rocks.\n * Wave 19: 30 strongs.\n * Wave 20: 100 rocks, then 80 bugs.\n * Wave 21: 80 rocks, then 40 strongs.\n * Wave 22: 2 rocks, 2 bugs, and 1 strong, x20.\n * Wave 23: 80 rocks, 50 bugs, 30 strongs.\n * Wave 24: 1 rock, 2 bugs, 2 rocks, 2 bugs, 2 rocks, \n ** 2 strongs, 2 rocks, 1 bug, x15.\n * Wave 25: 50 strongs, 20 bugs, and 30 rocks.\n * Wave 26: 80 strongs.\n * Wave 27: 100 rocks, with a bug every 5 rocks.\n */\n\n\n\n\nbackground(0, 0, 0);\n\n///////////////////////////////////////////////////////////\n// Game constants. Try tweaking these!\nvar playerLives = 400, // Must be high because for every 1 health in the enemy reaching the end, you lose 1 life. So if an enemy hits the end with 33 health left, you lose 33 lives.\n    \n    money = 350,\n    \n    PATH_COLOR = color(0, 255, 0),\n    \n    SELLING_RATIO = 3 / 5,\n    // When you sell a tower (s), you get this much times\n    // the original cost.\n    \n    UPGRADE_CONSTANT = 1.5,\n    // When you upgrade a tower, if you upgrade the range\n    // or damage, it\'s multiplied by 1.5. If you upgrade\n    // the reload time, it is divided by 1.5.\n    \n    // 360 tower. Shoots in all directions. (yellow ship)\n    the360_TOWER_RANGE = 60,\n    the360_TOWER_DELAY = 40,\n    the360_TOWER_DAMAGE = 7, \n    // I noticed enemies were being hit with like 3 bullets\n    // at once, so I made the damage less.\n    the360_TOWER_COST = 115,\n    the360_TOWER_BULLETS = 8,\n    the360_TOWER_RANGEUPG_COST = 100,\n    the360_TOWER_DELAYUPG_COST = 75,\n    the360_TOWER_DAMAGEUPG_COST = 60,\n    \n    \n    // Regular tower (red ship)\n    REG_TOWER_DAMAGE = 15,\n    REG_TOWER_DELAY = 25,\n    REG_TOWER_COST = 54,\n    REG_TOWER_RANGE = 75,\n    REG_TOWER_RANGEUPG_COST = 70,\n    REG_TOWER_DELAYUPG_COST = 30,\n    REG_TOWER_DAMAGEUPG_COST = 45,\n    \n    \n    // Fast tower (rocket ship)\n    FAST_TOWER_DAMAGE = 6, \n    // Shoots fast, so you don\'t need much damage\n    FAST_TOWER_DELAY = 10,\n    FAST_TOWER_COST = 150,\n    FAST_TOWER_RANGE = 60,\n    FAST_TOWER_SPREAD = 10, // Spread of bullets, in degrees\n    FAST_TOWER_RANGEUPG_COST = 116,\n    FAST_TOWER_DELAYUPG_COST = 56,\n    FAST_TOWER_DAMAGEUPG_COST = 90,\n    \n    \n    // enemies\n    \n    ENEMY_DELAY = 30,\n    \n    ROCK_HEALTH = 40,\n    ROCK_SPEED = 2.5,\n    ROCK_MONEY_GAIN = 3,\n    \n    BUG_HEALTH = 25,\n    BUG_SPEED = 4,\n    BUG_MONEY_GAIN = 3,\n    \n    STRONG_HEALTH = 150,\n    STRONG_SPEED = 2,\n    STRONG_MONEY_GAIN = 7,\n    \n    STAR_HEALTH = 999,\n    STAR_SPEED = 0.4,\n    STAR_MONEY_GAIN = 100,\n    \n    // Difficulty ramps-how fast things get hard\n    ENEMY_HEALTH_GAIN = 0, // per wave\n    // What happens is the first wave they gain 1 health,\n    // then 2, and they always gain the last wave number.\n    \n    // Shows current frame number if true\n    DEBUG = false\n;\n\n\n////////////////////////////////////////////////////\n\n// The pictures for the towers and enemies.\n// Always use \"the360Tower\", not \"360tower\".\nvar regTowerImage =  getImage(\"space/beetleship\");\nvar fastTowerImage = getImage(\"space/rocketship\");\nvar the360TowerImage = getImage(\"space/octopus\");\n\n// Normal enemy. 40 health, 5 speed \nvar rockImage = getImage(\"cute/Rock\");\n// Weak, but fast. 25 health, 10 speed\nvar bugImage = getImage(\"cute/EnemyBug\");\n// Strong, but slow. 75 health, 3 speed.\nvar strongImage = getImage(\"avatars/mr-pants\");\n// This is \"the ultimate enemy\". 999 health, 0.4 speed.\nvar starImage = getImage(\"avatars/spunky-sam\");\n/** Note on the strong enemy: It used to be a robot, but the\n * picture didn\'t look good when I scaled it to fit, so now it\n * is Mr. Pants. */\n\n\n// Copied from Slither\n\nvar enemyStartX = 330; \nvar enemyStartY = -50; // off-screen\nvar path;\nvar direction = \"north\";\n\n// How far the path goes in each step\nvar stepSize = 49;\n\n\nvar drawTrack = function() {\n    path = \"SSSSSSSSLSSSLSRSLSSLSSRLLSSSSLLSRSLLSSSRSS\";\n    var xx = enemyStartX;\n    var yy = enemyStartY;\n    // The starting direction of the enemies\n    var direction = \"north\";\n    \n    strokeWeight(24);\n    stroke(PATH_COLOR);\n    for (var i = 0; i < path.length; i += 1) {\n        var bend = path[i];\n        if (bend === \"R\") {\n            if (direction === \"north\") {\n                direction = \"east\";\n            } else if (direction === \"east\") {\n                direction = \"south\";\n            } else if (direction === \"south\") {\n                direction = \"west\";\n            } else if (direction === \"west\") {\n                direction = \"north\";\n            }\n        } else if (bend === \"L\") {\n            if (direction === \"north\") {\n                direction = \"west\";\n            } else if (direction === \"east\") {\n                direction = \"north\";\n            } else if (direction === \"south\") {\n                direction = \"east\";\n            } else if (direction === \"west\") {\n                direction = \"south\";\n            }\n        }\n    \n        var nextX = xx;\n        var nextY = yy;\n        if (direction === \"north\") {\n            nextY += stepSize;\n        } else if (direction === \"east\") {\n            nextX += stepSize;\n        } else if (direction === \"south\") {\n            nextY -= stepSize;\n        } else if (direction === \"west\") {\n            nextX -= stepSize;\n        }\n    \n        line(xx, yy, nextX, nextY);\n        xx = nextX;\n        yy = nextY;\n    }\n\n};\n\n////////////////////////////////////////////////////\n// Game variables. Careful, changing these might break stuff!\nvar createBody = function(x, y) {\n    return {\n        x: x,\n        y: y\n    };\n};\n\nvar leftBound = -60, rightBound = 420, upperBound = -100,\n    lowerBound = 420;\n// upperBound must be less than enemyStartY\n\nvar State = {\n    SPLASH: 0,\n    GAME: 99,\n    WIN: 1,\n    LOSE: 2\n};\n\nvar gameState = State.SPLASH;\n\nvar waveActive = false;\n\nvar paused = false,\n    wave = 0,\n    help = false,\n    updateStep = 0,\n    currentWave = \"\",\n    score = 0,\n    winFrame = 0\n;\n    \n\nvar yyy, hhh;\n\nvar towerPicked = \"\";\n\nvar started = false;\n\n// Step counter for debug. Do not use for updating.\nvar debugStep = 0;\n\nvar Enemy = {\n    ROCK: 0,\n    BUG: 1,\n    STRONG: 2,\n    STAR: 3\n};\n\n\n\nvar Tower = {\n    REG: 0,\n    the360: 1,\n    FAST: 2\n};\n\nvar enemies = [],\n    towers = [],\n    missiles = []\n;\n\n\n\n/*****************************************************\n * WAVES\n * \n * \n * The strings are codes. Key: Rock = 0, Bug = 1, Strong = 2.\n * ALL waves MUST end with \"E\". E is for End.\n * \"x30\" means that pattern repeats 30 times.\n * \n * Edit: now you don\'t have to type E at the end.\n * \n * Wave 1: 10 rocks.\n * Wave 2: 12 rocks and 3 bugs.\n * Wave 3: 20 rocks, then 5 bugs.\n * Wave 4: 30 rocks, 10 bugs.\n * Wave 5: 3 rocks and 3 bugs, x10.\n * Wave 6: 40 bugs.\n * Wave 7: 25 bugs and 20 rocks.\n * Wave 8: 1 strong, then 20 rocks, then 12 bugs.\n * Wave 9: 2 strongs, then 18 bugs.\n * Wave 10: 12 strongs.\n * Wave 11: 2 strongs, then 20 rocks, then 2 more strongs.\n * Wave 12: 2 rocks and 2 bugs, x10. Then 3 strong enemies. Then 15 more rocks.\n * Wave 13: 80 bugs.\n * Wave 14: 40 bugs and 60 rocks.\n * Wave 15: 120 rocks.\n * Wave 16: 20 rocks, 20 bugs, 1 strong, x4.\n * Wave 17: 120 rocks. Then 20 bugs. Then 30 more rocks.\n * Wave 18: 18 strongs, then 50 rocks.\n * Wave 19: 30 strongs.\n * Wave 20: 100 rocks, then 80 bugs.\n * Wave 21: 80 rocks, then 40 strongs.\n * Wave 22: 2 rocks, 2 bugs, and 1 strong, x20.\n * Wave 23: 80 rocks, 50 bugs, 30 strongs.\n * Wave 24: 1 rock, 2 bugs, 2 rocks, 2 bugs, 2 rocks, \n ** 2 strongs, 2 rocks, 1 bug, x15.\n * Wave 25: 50 strongs, 20 bugs, and 30 rocks.\n * Wave 26: 80 strongs.\n * Wave 27: 100 rocks, with a bug every 5 rocks.\n */\n\n\n/** Note: On waves with more than 40 enemies, I use a +\n * to go to the next line. */\nvar waves = [\n   \"\", // Wave 0 is null\n   //    5     10    15    20    25    30    35    40\n   \"00000 00000E\", // wave 1\n   \"00000 00000 00111E\",// wave 2\n   \"00000 00000 00000 00000 11111E\",//wave 3\n   \"00000 00000 00000 00000 00000 00000 11111 11111E\",//wave 4\n   \"00011 10001 11000 11100 01110 00111 00011 10001\"+\n   \"11000 11100 01110 001113E\",//wave 5\n    \n    \n   \"11111 11111 11111 11111 11111 11111 11111 11111E\",//wave 6\n   \"11111 11111 11111 11111 11111 00000 00000 00000\"+\n   \"00000 00000E\",//wave 7\n  \"200000 00000 00000 00000 11111 11111 11E\",//wave 8\n   \"22111 11111 11111 11111E\",//wave 9\n   \"22222 22222 223E\",//wave 10\n    \n   \"22000 00000 00000 00000 0022E\",//wave 11\n   \"00110 01100 11001 10011 00110 01100 11001 10011\"+\n   \"22200 00000 00000 000E\",//wave 12\n   \"11111 11111 11111 11111 11111 11111 11111 11111\"+\n   \"11111 11111 11111 11111 11111 11111 11111 11111E\",//wave 13\n   \"11111 11111 11111 11111 11111 11111 11111 11111\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000E\",//wave 14\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 00000 00000 00000 000003\"+\n   \"E\",//wave 15\n   \n   \"00000 00000 00000 00000 11111 11111 11111 111112\"+\n   \"00000 00000 00000 00000 11111 11111 11111 111112\"+\n   \"00000 00000 00000 00000 11111 11111 11111 111112\"+\n   \"00000 00000 00000 00000 11111 11111 11111 111112\",//wave 16\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"11111 11111 11111 11111 00000 00000 00000 00000\"+\n   \"00000 00000E\",//wave 17\n   \"22222 22222 22222 222\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000\",//wave 18\n   \"22222 22222 22222 22222 22222 22222\",//wave 19\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 11111 11111 11111 11111\"+\n   \"11111 11111 11111 11111 11111 11111 11111 11111\"+\n   \"11111 11111 11111 111113E\",//wave 20\n   \n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"22222 22222 22222 22222 22222 22222 22222 22222\"+\n   \"22222 22222\",//wave 21\n   \"00112 00112 00112 00112 00112 00112 00112 00112\"+\n   \"00112 00112 00112 00112 00112 00112 00112 00112\"+\n   \"00112 00112 00112 00112\",//wave 22 I used copy+paste\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"00000 00000 00000 00000 00000 00000 00000 00000\"+\n   \"11111 11111 11111 11111 11111 11111 11111 11111\"+\n   \"11111 11111 22222 22222 22222 22222 22222 22222\",//wave 23\n   // wave 24 is sorted in groups of 6, not 5\n   \"010010 022001 010010 022001 010010 022001 010010 022001\"+\n   \"010010 022001 010010 022001 010010 022001 010010 022001\"+\n   \"010010 022001 010010 022001 010010 022001 010010 022001\"+\n   \"010010 022001 010010 022001 010010 022001\",//wave 24\n   \"22222 22222 22222 22222 22222 22222 22222 22222\"+\n   \"22222 22222 11111 11111 11111 11111 00000 00000\"+\n   \"00000 00000 00000 000003\",//wave 25\n   \n   \"22222 22222 22222 22222 22222 22222 22222 22222\"+\n   \"22222 22222 22222 22222 22222 22222 22222 22222\",//wave 26\n   \"000001000001000001000001000001000001000001000001\"+\n   \"000001000001000001000001000001000001000001000001\"+\n   \"000001000001000001000001\",//wave 27\n   \n   \n   \"E\"\n];\n\n\n\nfor (var i = 1; i < waves.length; i++) {\n    var wavei = waves[i];\n    if (wavei[wavei.length - 1] !== \"E\") {\n        waves[i] = waves[i] + \"E\";\n    }\n}\n\n\n\n\n\nvar createMissile = function(x, y, dx, dy, theTower) {\n    var missile = {};\n    \n    // Set missile weapon and damage from tower type\n    missile.weapon = theTower.type;\n    if (theTower.type === Tower.REG) {\n        missile.damage = REG_TOWER_DAMAGE;\n    } else if (theTower.type === Tower.the360) {\n        missile.damage = the360_TOWER_DAMAGE;\n    } else if (theTower.type === Tower.FAST) {\n        missile.damage = FAST_TOWER_DAMAGE;\n    }\n    \n    missile.x = x;\n    missile.y = y;\n    missile.dx = dx;\n    missile.dy = dy;\n    \n    missile.range = theTower.range + 25;\n    missile.dist = 0;\n    missiles.push(missile);\n    return missile;\n};\n\n\n\nvar updateMissiles = function() {\n    for (var i = 0; i < missiles.length; i += 1) {\n        var missile = missiles[i];\n        var dx = missile.dx,\n            dy = missile.dy;\n        missile.x += dx;\n        missile.y += dy;\n        \n        missile.dist += sqrt(dx*dx + dy*dy);\n        if (missile.dist >= missile.range) {\n            missiles.splice(i, 1);\n        }\n    }\n};\n\n\nvar drawMissiles = function() {\n    for (var i = 0; i < missiles.length; i += 1) {\n        var missile = missiles[i];\n        if (missile.weapon === Tower.REG) {\n            noStroke();\n            fill(201, 64, 26);\n            ellipse(missile.x, missile.y, 17, 15);\n        } else if (missile.weapon === Tower.the360) {\n            noStroke();\n            fill(255, 214, 66);\n            ellipse(missile.x, missile.y, 15, 15);\n        } else if (missile.weapon === Tower.FAST) {\n            noStroke();\n            fill(129, 207, 89);\n            ellipse(missile.x, missile.y, 12, 12);\n        }\n    }\n};\n\n\n\n \n// Now getting utility functions.\n\n/** getDistance\n * Will be useful to find if the closest enemy is in the range.\n */\nvar getDistance = function(x1, y1, x2, y2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n};\n\n/** drawRange(x, y, radius);\n * Draws the tower range as a circle.\n */\nvar drawRange = function(x, y, radius) {\n    stroke(255, 255, 255, 150);\n    strokeWeight(2);\n    fill(255, 255, 255, 70);\n    ellipse(x, y, radius * 2, radius * 2);\n};\n\n\n/**\n * Gets the closest body to the given (x, y) coordinates.\n * Will be useful for only firing at the closest enemy.\n */\nvar findClosest = function(x, y) {\n    var closestDist = Infinity;\n    var closestEnemy = null;\n    for (var i = 0; i < enemies.length; i += 1) {\n        var enemy = enemies[i];\n        var dist = getDistance(x, y, enemy.x, enemy.y);\n        if (dist < closestDist) {\n            closestDist = dist;\n            closestEnemy = enemy;\n        }\n    }\n    return closestEnemy;\n};\n\n/**\n * Gets the sign of a number.\n * Not sure if (and how) it can be useful.\n */\nvar sign = function(num) {\n    if (num > 0) {\n        return 1;\n    } else if (num < 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n};\n\n/////////////////////////////////////////////////////////////\n// More functions\n\n\n/**************************************************************\n * Enemies\n *************************************************************/\n\nvar createEnemy = function(enemyType) {\n    var newEnemy = {};\n    \n    if (enemyType === 0 || enemyType === \"0\") {\n        newEnemy.type = Enemy.ROCK;\n        newEnemy.image = rockImage;\n        newEnemy.health = ROCK_HEALTH;\n        newEnemy.speed = ROCK_SPEED;\n        newEnemy.moneyGain = ROCK_MONEY_GAIN;\n    } else if (enemyType === 1 || enemyType === \"1\") {\n        newEnemy.type = Enemy.BUG;\n        newEnemy.image = bugImage;\n        newEnemy.health = BUG_HEALTH;\n        newEnemy.speed = BUG_SPEED;\n        newEnemy.moneyGain = BUG_MONEY_GAIN;\n    } else if (enemyType === 2 || enemyType === \"2\") {\n        newEnemy.type = Enemy.STRONG;\n        newEnemy.image = strongImage;\n        newEnemy.health = STRONG_HEALTH;\n        newEnemy.speed = STRONG_SPEED;\n        newEnemy.moneyGain = STRONG_MONEY_GAIN;\n    } else if (enemyType === 3 || enemyType === \"3\") {\n        newEnemy.type = Enemy.STAR;\n        newEnemy.image = starImage;\n        newEnemy.health = STAR_HEALTH;\n        newEnemy.speed = STAR_SPEED;\n        newEnemy.moneyGain = STAR_MONEY_GAIN;\n    } else {\n        return;\n    }\n    \n    newEnemy.x = enemyStartX;\n    newEnemy.y = enemyStartY;\n    \n    newEnemy.distTraveled = 0;\n    newEnemy.distLeft = stepSize;\n    newEnemy.direction = direction;\n    newEnemy.segment = 0;\n    \n    enemies.push(newEnemy);\n    return newEnemy;\n};\n\n\nvar drawEnemies = function() {\n    for (var count = 0; count < enemies.length; count++) {\n        pushMatrix();\n        var thisEnemy = enemies[count];\n        var thisImage = thisEnemy.image;\n        if (thisEnemy.type === Enemy.STRONG) {\n            translate(thisEnemy.x - 30, thisEnemy.y - 40);\n        } else {\n            translate(thisEnemy.x - 25, thisEnemy.y - 56);\n        }\n        scale(0.5, 0.5); // See comment in draw loop\n        \n        image(thisImage, 0, 0);\n        textSize(30);\n        fill(0, 0, 0);\n        textAlign(CENTER, CENTER);\n        if (thisEnemy.type === Enemy.STRONG) {\n            text(round(thisEnemy.health), 60, 80);\n        } else {\n            text(round(thisEnemy.health), 50, 112);\n        }\n        popMatrix();\n        textAlign(LEFT, DOWN);\n    }\n};\n\n\n// It works somewhat, but the enemy is off-centered.\nvar updateEnemies = function() {\n    for (var a = 0; a < enemies.length; a++) {\n        var thisEnemy = enemies[a];\n        \n        thisEnemy.distTraveled += thisEnemy.speed;\n        thisEnemy.distLeft -= thisEnemy.speed;\n        if (thisEnemy.distLeft < 0) {\n            var bend = path[thisEnemy.segment + 1];\n            var go = thisEnemy.speed + thisEnemy.distLeft;\n            var back = thisEnemy.distLeft;\n            \n            if (bend === \"R\") {\n                if (thisEnemy.direction === \"north\") {\n                    thisEnemy.y += go;\n                    thisEnemy.direction = \"east\";\n                    thisEnemy.x -= back;\n                } else if (thisEnemy.direction === \"east\") {\n                    thisEnemy.x += go;\n                    thisEnemy.direction = \"south\";\n                    thisEnemy.y += back;\n                    \n                } else if (thisEnemy.direction === \"south\") {\n                    thisEnemy.y -= go;\n                    thisEnemy.direction = \"west\";\n                    thisEnemy.x += back;\n                } else if (thisEnemy.direction === \"west\") {\n                    thisEnemy.x -= go;\n                    thisEnemy.direction = \"north\";\n                    thisEnemy.y -= back;\n                }\n            } else if (bend === \"L\") {\n                if (thisEnemy.direction === \"north\") {\n                    thisEnemy.y += go;\n                    thisEnemy.direction = \"west\";\n                    thisEnemy.x += back;\n                } else if (thisEnemy.direction === \"east\") {\n                    thisEnemy.x += go;\n                    thisEnemy.direction = \"north\";\n                    thisEnemy.y -= back;\n                } else if (thisEnemy.direction === \"south\") {\n                    thisEnemy.y -= go;\n                    thisEnemy.direction = \"east\";\n                    thisEnemy.x -= back;\n                } else if (thisEnemy.direction === \"west\") {\n                    thisEnemy.x -= go;\n                    thisEnemy.direction = \"south\";\n                    thisEnemy.y += back;\n                }\n            }\n            thisEnemy.segment++;\n            thisEnemy.distLeft = stepSize;\n        } else {\n            var x = thisEnemy.x;\n            var y = thisEnemy.y;\n            var offX = enemyStartX % stepSize;\n            var offY = enemyStartY % stepSize;\n            var roundedX =round(x/stepSize)*stepSize + offX;\n            var roundedY =round(y/stepSize)*stepSize + offY;\n            if (thisEnemy.direction === \"north\") {\n                thisEnemy.y += thisEnemy.speed;\n                thisEnemy.x = roundedX;\n            }  else if (thisEnemy.direction === \"south\") {\n                thisEnemy.y -= thisEnemy.speed;\n                thisEnemy.x = roundedX;\n            } else if (thisEnemy.direction === \"east\") {\n                thisEnemy.x += thisEnemy.speed;\n                thisEnemy.y = roundedY;\n            } else if (thisEnemy.direction === \"west\") {\n                thisEnemy.x -= thisEnemy.speed;\n                thisEnemy.y = roundedY;\n            }\n        }\n        \n        if (thisEnemy.distTraveled >= path.length * stepSize) {\n            playerLives -= thisEnemy.health;\n            enemies.splice(a, 1);\n        }\n        \n        if (thisEnemy.health <= 0) {\n            enemies.splice(a, 1);\n            score++;\n        }\n    }\n};\n\n\n/*************************************************************\n * Towers\n ************************************************************/\n\nvar placeTower = function(x, y, towertype) {\n    if (towertype === \"\" || towerPicked === \"\") {\n        return;\n    }\n    \n    \n    var newTower = {};\n    if (towertype === \"reg\") {\n        if (money >= REG_TOWER_COST) {\n            newTower.type = Tower.REG;\n            newTower.x = mouseX;\n            newTower.y = mouseY;\n            newTower.lastFired = updateStep;\n            \n            newTower.angle = 0;\n            \n            newTower.damage = REG_TOWER_DAMAGE;\n            newTower.range = REG_TOWER_RANGE;\n            newTower.delay = REG_TOWER_DELAY;\n            \n            newTower.damageUpg = false;\n            newTower.rangeUpg = false;\n            newTower.delayUpg = false;\n            // Delay decreases on upgrade\n            \n            money -= REG_TOWER_COST;\n        } else {\n            // Trying to place a tower you can\'t afford negates\n            // your choice\n            towerPicked = \"\";\n            yyy = -100; hhh = 0;\n        }\n    } else if (towertype === \"the360\") {\n        if (money >= the360_TOWER_COST) {\n            resetMatrix();\n            newTower.type = Tower.the360;\n            newTower.x = mouseX;\n            newTower.y = mouseY;\n            newTower.lastFired = updateStep;\n            \n            newTower.damage = the360_TOWER_DAMAGE;\n            newTower.delay = the360_TOWER_DELAY;\n            newTower.range = the360_TOWER_RANGE;\n            \n            newTower.angle = 0;\n            \n            newTower.damageUpg = false;\n            newTower.rangeUpg = false;\n            newTower.delayUpg = false;\n            money -= the360_TOWER_COST;\n        } else {\n            towerPicked = \"\";\n            yyy= -100; hhh = 0;\n        }\n    } else {\n        // Fast tower\n        if (money >= FAST_TOWER_COST) {\n            // I hope this is OK\n            resetMatrix();\n            newTower.type = Tower.FAST;\n            newTower.x = mouseX;\n            newTower.y = mouseY;\n            newTower.lastFired = updateStep;\n            \n            newTower.delay = FAST_TOWER_DELAY;\n            newTower.range = FAST_TOWER_RANGE;\n            newTower.damage = FAST_TOWER_DAMAGE;\n            newTower.angle = 0;\n            \n            newTower.damageUpg = false;\n            newTower.rangeUpg = false;\n            newTower.delayUpg = false;\n            \n            money -= FAST_TOWER_COST;\n        } else {\n            towerPicked = \"\";\n            yyy = -100; hhh = 0;\n        }\n        \n    }\n    \n    \n    // Reset towerPicked\n    towerPicked = \"\";\n    yyy = -100;\n    hhh = 0;\n    \n    \n    towers.push(newTower);\n    //return newTower;\n};\n\nvar drawTowers = function() {\n    for(var count = 0; count < towers.length; count++) {\n        \n        var theTower = towers[count];\n        // Draw all towers above ranges\n        imageMode(CENTER);\n        if (theTower.type === Tower.REG) {\n            pushMatrix();\n            \n            translate(theTower.x, theTower.y);\n            scale(0.4, 0.4);\n            rotate(theTower.angle);\n            image(regTowerImage, 15, -25);\n            popMatrix();\n        } else if (theTower.type === Tower.the360) {\n            pushMatrix();\n            translate(theTower.x + 6.5, theTower.y + -4);\n            scale(0.4, 0.4);\n            image(the360TowerImage, 0, 0);\n            popMatrix();\n        } else if (theTower.type === Tower.FAST) {\n            pushMatrix();\n            translate(theTower.x + 4.5, theTower.y + -6.5);\n            rotate(theTower.angle);\n            scale(0.32, 0.4);\n            \n            image(fastTowerImage, 0, 0);\n            popMatrix();\n        }\n    }\n    imageMode(CORNER);\n};\n\nvar drawRanges = function() {\n    for(var count = 0; count < towers.length; count++) {\n        \n        var theTower = towers[count];\n        drawRange(theTower.x, theTower.y, theTower.range);\n    }\n};\n\n///////////////////////////////////////////////////////////////// Problem?\nvar fireTowerMissiles = function() {\n    for (var i = 0; i < towers.length; i++) {\n        var theTower = towers[i];\n        var fire = true;\n        \n        // Wait for the next round to be chambered\n        if(updateStep-theTower.lastFired < theTower.delay) {\n            fire = false;\n        }\n        \n        \n        // If no enemy is close, don\'t fire\n        if (enemies.length === 0) {\n            fire = false; \n            // If there are no enemies, don\'t fire\n        }\n    \n        var x1 = theTower.x;\n        var y1 = theTower.y;\n        var x2, y2;\n        var dx, dy, angle, enemy, distToEnemy, offx, offy;\n        if (fire) {\n           \n        if (theTower.type === Tower.REG) {\n            \n            // Image offsets\n            enemy = findClosest(x1 + 6, y1 - 7); \n                \n            if (enemy === null) {\n                \n            } else {\n                \n            \n              x2 = enemy.x; y2 = enemy.y;\n              distToEnemy = getDistance(x1+6,y1-7,x2,y2);\n\n              if (distToEnemy < theTower.range + 10) {\n// The +10 is to account for the thickness of the track.\n               angle = atan2(y2-(y1-7), x1-(x1+6));\n                \n                \n                dx = 8 * cos(angle);\n                dy = 8 * sin(angle);\n                createMissile(x1+6, y1-7, dx, dy, theTower);\n              }\n            }\n        } else if (theTower.type === Tower.the360) {\n            enemy = findClosest(x1, y1);\n            if (enemy === null) {\n                return;\n            }\n            x2 = enemy.x; y2 = enemy.y;\n            distToEnemy = getDistance(x1, y1, x2, y2);\n            if (distToEnemy < theTower.range + 10) {\n                \n            \n              for (var j = 0; j < 360; j += (360 / the360_TOWER_BULLETS)) {\n                  var speed = 6;\n                  dx = speed * cos(j);\n                  dy = speed * sin(j); \n                  /** Does NOT fire at the closest enemy! Just \n                   * fires in a fixed way every time!\n                   */\n                  createMissile(x1, y1, dx, dy, theTower);\n            }\n        }\n    } else if (theTower.type === Tower.FAST) {\n        enemy = findClosest(x1, y1);\n        if (enemy === null) {\n            return;\n        }\n        x2 = enemy.x; y2 = enemy.y;\n        distToEnemy = getDistance(x1, y1, x2, y2);\n        if (distToEnemy < theTower.range + 10) {\n            angle = atan2(y2 - y1, x2 - x1);\n            angle += random(-FAST_TOWER_SPREAD, FAST_TOWER_SPREAD);\n            switch (enemy.direction) {\n                case \"north\": offx = 0; offy = enemy.speed;\n                break;\n                case \"east\": offx = enemy.speed; offy = 0;\n                break;\n                case \"south\": offx=0; offy = -enemy.speed;\n                break;\n                case \"west\": offx = -enemy.speed; offy=0;\n                break;\n            }\n                dx = 10*cos(angle) + offx;\n                dy = 10*sin(angle) + offy;\n                createMissile(x1,y1, dx, dy, theTower);\n            }\n        \n            \n    }\n    theTower.lastFired = updateStep;\n    }\n    }\n};\n\nvar updateTowers = function() {\n    for (var count = 0; count < towers.length; count++) {\n        var thisTower = towers[count];\n        var x1 = thisTower.x, y1 = thisTower.y;\n        var range = thisTower.range + 10;\n        if (thisTower.type !== Tower.the360) {\n            var closeEnemy = findClosest(thisTower.x, thisTower.y);\n            if (closeEnemy === null) {\n            } else {\n                var x2 = closeEnemy.x, y2 = closeEnemy.y;\n                if (getDistance(x1, y1, x2, y2) < range) {\n                    var towerAngle = atan2(y2 - y1, x2 - x1);\n                    thisTower.angle = towerAngle;\n                }\n            }\n        }\n    }\n    fireTowerMissiles();\n    \n};\n\n\n/*************************************************************\n * Collisions\n * Need to check when a missile touches the enemy.\n * ...\n */\n\n/** This is the function that attacks an enemy... */\nvar attackEnemy = function(enemy, damage) {\n    enemy.health -= damage;\n    if (enemy.health > 0) {\n        return;\n    }\n    \n    // Gain money\n    if (enemy.type === Enemy.ROCK) {\n        money += ROCK_MONEY_GAIN;\n    } else if (enemy.type === Enemy.BUG) {\n        money += BUG_MONEY_GAIN;\n    } else if (enemy.type === Enemy.STRONG) {\n        money += STRONG_MONEY_GAIN;\n    }\n};\n\n\n/** ... and it\'s called in this function... */\nvar checkEnemyCollisions = function() {\n    for (var i = 0; i < enemies.length; i++) {\n        var enemy = enemies[i];\n        for (var j = 0; j < missiles.length; j++) {\n            var missile = missiles[j];\n            var collidesX = (abs(missile.x - enemy.x) < 20);\n            var collidesY = (abs(missile.y - enemy.y) < 20);\n            if (collidesX && collidesY) {\n                attackEnemy(enemy, missile.damage);\n                missiles.splice(j, 1);\n                \n            }\n        }\n    }\n};\n\n// Input\n// yyy and hhh are for the width and \n// height of the \"selection rectangle\".\nvar upgrade = false;\nvar towerToUpg = null;\nvar mouseClicked = function() {\n    if (mouseX < 100 && mouseY > 273) {\n        if (mouseY < 323) {\n            if (towerPicked === \"reg\") {\n                yyy = -100; hhh = 0;\n                towerPicked = \"\";\n                // Clicking the same tower twice negates\n                // your choice\n            } else {\n                yyy = 273; hhh = (323 - 273);\n                towerPicked = \"reg\";\n            }\n            \n        } else if (mouseY > 323 && mouseY < 363) {\n            \n            \n            if (towerPicked === \"the360\") {\n                yyy = -100; hhh = 0;\n                towerPicked = \"\";\n                // Clicking the same tower twice negates\n                // your choice\n            } else {\n                yyy = 323; hhh = (363 - 323);\n                towerPicked = \"the360\";\n            }\n        } else {\n            if (towerPicked === \"fast\") {\n                towerPicked = \"\";\n                yyy = -200; hhh = 0;\n            } else {\n                towerPicked = \"fast\";\n                yyy = 363; hhh = (400 - 363);\n            }\n            \n        }\n    upgrade = false;\n    } else {\n        upgrade = false;\n        towerToUpg = null;\n        yyy = -100; hhh = 1;\n        for (var i = 0; i < towers.length; i++) {\n            var theTower = towers[i];\n            var x = theTower.x, y = theTower.y;\n            if (abs(mouseX - x) < 15 && abs(mouseY - y) < 10) {\n                upgrade = true;\n                towerToUpg = theTower;\n            }\n        }\n        if (upgrade) {\n            \n        } else {\n            placeTower(mouseX, mouseY, towerPicked);\n            upgrade = false;\n            towerToUpg = null;\n        }\n        \n        \n    }    \n};\n\n\nvar towerToUpg;\nvar nextWave;\nvar keyPressed = function() {\n    if (!started && keyCode === 32) {\n        // 32 is the keyCode for space\n        started = true;\n        nextWave();\n    } else if (keyCode === SHIFT) {\n        frameRate(100); // Speed up game x2\n    } else if (started && keyCode === 32 && !waveActive) {\n        nextWave();\n    } else if (started && keyCode === 80) {\n        // 80 is the key code for P\n        paused = !paused;\n        // The frames still count up, but nothing else updates\n    } else if (keyCode === 72) {\n        // 72 is the keyCode for H\n        help = true;\n    } else if (keyCode === 49 || keyCode === 82) {\n        // 49 = 1 and 82 = R (Range)\n        if (towerToUpg !== null && upgrade) {\n            if (towerToUpg.type === Tower.REG) {\n                if (money >= REG_TOWER_RANGEUPG_COST) {\n                    if (!towerToUpg.rangeUpg) {\n                        towerToUpg.range *= UPGRADE_CONSTANT;\n                        towerToUpg.rangeUpg = true;\n                        upgrade = false;\n                        money -= REG_TOWER_RANGEUPG_COST;\n                    }\n                } else {\n                    upgrade = false;\n                }\n            } else if (towerToUpg.type === Tower.the360) {\n                if (money >= the360_TOWER_RANGEUPG_COST) {\n                    if (!towerToUpg.rangeUpg) {\n                        towerToUpg.range *= UPGRADE_CONSTANT;\n                        towerToUpg.rangeUpg = true;\n                        upgrade = false;\n                        money -= the360_TOWER_RANGEUPG_COST;\n                    }\n                }\n            } else if (towerToUpg.type === Tower.FAST) {\n                if (money >= FAST_TOWER_RANGEUPG_COST) {\n                    if (!towerToUpg.rangeUpg) {\n                        towerToUpg.range *= UPGRADE_CONSTANT;\n                        towerToUpg.rangeUpg = true;\n                        upgrade = false;\n                        money -= FAST_TOWER_RANGEUPG_COST;\n                    }\n                }\n            }\n        }\n        \n        upgrade = false;\n    } else if (keyCode === 50 || keyCode === 70) {\n        // 50 = 2 and 70 = F (Fire rate)\n        if (towerToUpg !== null && upgrade) {\n            if (towerToUpg.type === Tower.REG) {\n                if (money >= REG_TOWER_DELAYUPG_COST) {\n                    if (!towerToUpg.delayUpg) {\n                        towerToUpg.delay /= UPGRADE_CONSTANT;\n                        towerToUpg.delayUpg = true;\n                        money -= REG_TOWER_DELAYUPG_COST;\n                    }\n                } else {\n                    upgrade = false;\n                }\n            } else if (towerToUpg.type === Tower.the360) {\n                if (money >= the360_TOWER_DELAYUPG_COST) {\n                    if (!towerToUpg.delayUpg) {\n                        towerToUpg.delay /= UPGRADE_CONSTANT;\n                        towerToUpg.delayUpg = true;\n                        money -= the360_TOWER_DELAYUPG_COST;\n                    }\n                }\n            } else if (towerToUpg.type === Tower.FAST) {\n                if (money >= FAST_TOWER_DELAYUPG_COST) {\n                    if (!towerToUpg.delayUpg) {\n                        towerToUpg.delay /= UPGRADE_CONSTANT;\n                        towerToUpg.delayUpg = true;\n                        money -= FAST_TOWER_DELAYUPG_COST;\n                    }\n                }\n            }\n        }\n        upgrade = false;\n    } else if (keyCode === 51 || keyCode === 68) {\n        // 51 = 3 and 68 = D (Damage)\n        if (towerToUpg !== null && upgrade) {\n            if (towerToUpg.type === Tower.REG) {\n                if (money >= REG_TOWER_DAMAGEUPG_COST) {\n                    if (!towerToUpg.damageUpg) {\n                        towerToUpg.damage *= UPGRADE_CONSTANT;\n                        towerToUpg.damageUpg = true;\n                        money -= REG_TOWER_DAMAGEUPG_COST;\n                    } else {\n                        upgrade = false;\n                    }\n                } else {\n                    upgrade = false;\n                }\n            } else if (towerToUpg.type === Tower.the360) {\n                if (money >= the360_TOWER_DAMAGEUPG_COST) {\n                    if (!towerToUpg.damageUpg) {\n                        towerToUpg.damage *= UPGRADE_CONSTANT;\n                        towerToUpg.damageUpg = true;\n                        money -= the360_TOWER_DAMAGEUPG_COST;\n                    }\n                }\n            } else if (towerToUpg.type === Tower.FAST) {\n                if (money >= FAST_TOWER_DAMAGEUPG_COST) {\n                    if (!towerToUpg.damageUpg) {\n                        towerToUpg.damage *= UPGRADE_CONSTANT;\n                        towerToUpg.damageUpg = true;\n                        money -= FAST_TOWER_DAMAGEUPG_COST;\n                    }\n                }\n            }\n        }\n        \n        upgrade = false;\n    } else if (keyCode === 83) { // S for Sell\n        if (towerToUpg !== null) {\n            switch (towerToUpg.type) {\n                case Tower.REG:\n                    money += REG_TOWER_COST * SELLING_RATIO;\n                break;\n                case Tower.the360:\n                   money+=the360_TOWER_COST * SELLING_RATIO;\n                break;\n                case Tower.FAST:\n                    money += FAST_TOWER_COST * SELLING_RATIO;\n            }\n            for (var i = 0; i < towers.length; i++) {\n                if (towerToUpg === towers[i]) {\n                    towers.splice(i, 1);\n                }\n            }\n            towerToUpg = null;\n            upgrade = false;\n        }\n    }\n};\n\nvar keyReleased = function() {\n    if (keyCode === SHIFT) {\n        frameRate(50); // Back to normal\n    } else if (keyCode === 72) {\n        help = false;\n    }\n};\nframeRate(50);\n\n\n\n\n\n\n// Drawing.\n\nvar drawSplash = function() {\n    textSize(30);\n    fill(255, 255, 255);\n    text(\"The\", 100, 100);\n    pushMatrix();\n    translate(150, 180);\n    rotate(-20);\n    fill(51, 255, 0);\n    textSize(40);\n    text(\"Ultimate TD\", 0, 0);\n    popMatrix();\n    \n    pushMatrix();\n    translate(123, 211);\n    scale(0.5, 0.5);\n    image(fastTowerImage, 0, 0);\n    image(rockImage, 400, 15);\n    popMatrix();\n    \n    fill(0, 255, 0, 64);\n    noStroke();\n    ellipse(247, 275, 15, 15);\n    fill(0, 255, 0, 128);\n    ellipse(267, 275, 16, 16);\n    fill(0, 255, 0, 192);\n    ellipse(287, 275, 17, 17);\n    fill(0, 255, 0);\n    ellipse(307, 275, 18, 18);\n    \n    fill(255, 255, 255);\n    noStroke();\n    rect(150, 320, 100, 50, 10); \n    // the 5th parameter makes it a rounded rectangle\n    fill(0);\n    textSize(20);\n    textAlign(CENTER, CENTER);\n    text(\"Play\", 200, 345);\n    textAlign(LEFT, DOWN);\n    \n    if (mouseIsPressed && mouseX > 150 && mouseX < 250 &&\n        mouseY > 320 && mouseY < 370) {\n        gameState = State.GAME;\n    }\n};\n\n\nvar drawWin = function() {\n    background(0, 0, 0);\n    textSize(70);\n    fill(0, 255, 0);\n    textAlign(CENTER, CENTER);\n    text(\"You win!!\", 200, 50);\n    \n    textSize(20);\n    fill(255);\n    textAlign(LEFT, CENTER);\n    //This part is totally ripped off from Mercury Subspace.\n    text(\"For deleting\", 40, 150);\n    text(\"enemies, you win the answer: 42\", 40, 300);\n    \n    textSize(70);\n    text(min(updateStep - winFrame, score), 40, 225);\n    \n    textAlign(LEFT, DOWN);\n};\n\nvar drawInfo = function() {\n    fill(255);\n    noStroke();\n    rect(0, 0, 125, 80);\n    fill(0);\n    textSize(12);\n        text(\"Money: \"+money, 10, 14);\n        text(\"Wave: \"+wave, 10, 29);\n        text(\"Lives: \"+round(playerLives), 10, 44);\n    if (!started) {\n        text(\"Press SPACE\\nto start!\", 10, 59);\n    } else {\n        text(\"Press SPACE for\\nthe next wave!\", 10, 59);\n    }\n    if (DEBUG) {\n        textSize(12);\n        fill(255, 255, 255);\n        rect(0, 47, 125, 33);\n        fill(0, 0, 0);\n        text(\"Frame: \"+debugStep, 10, 59);\n        text(\"Mouse: (\"+mouseX+\", \"+mouseY+\")\", 10, 73);\n    }\n};\n\nvar drawTowerInfo = function() {\n    textSize(15);\n    fill(255);\n    rect(0, 273, 100, 127);\n    image(regTowerImage, -8, 251, 80, 80);\n    image(the360TowerImage, 0, 302, 70, 70);\n    pushMatrix();\n    scale(0.3, 0.4);\n    image(fastTowerImage, -4, 842);\n    popMatrix();\n    fill(0);\n    text(REG_TOWER_COST, 64, 307);\n    text(the360_TOWER_COST, 64, 352);\n    text(FAST_TOWER_COST, 64, 391);\n    noFill();\n    strokeWeight(5);\n    stroke(0, 0, 255);\n    rect(0, yyy, 100, hhh);\n};\ndrawTrack();\n\n\nvar drawUpgrades = function() {\n    if (towerToUpg === null  ||  !upgrade) {\n        return;\n    }\n    stroke(255, 0, 0);\n    fill(0, 0, 255, 50);\n    ellipse(towerToUpg.x, towerToUpg.y, 60, 60);\n    \n    stroke(255, 255, 255);\n    strokeWeight(3);\n    line(326, 0, 326, 400);\n    noStroke();\n    fill(0, 0, 0, 167);\n    rect(328, 0, 100, 500);\n    fill(255, 255, 0);\n    textSize(12);\n    text(\"UPGRADES\\n    Do NOT\\n  click these\\n   Press the\\n keys on the\\n   keyboard\", 328, 42);\n    var upgDelay = towerToUpg.delayUpg;\n    var upgRange = towerToUpg.rangeUpg;\n    var upgDamage = towerToUpg.damageUpg;\n    \n    // RANGE\n    \n    switch (towerToUpg.type) {\n        case Tower.REG: \n            if (upgRange || money < REG_TOWER_RANGEUPG_COST) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Range (1)\\nCost: \"+REG_TOWER_RANGEUPG_COST+\"\\nPress 1 to\\nupgrade\", 338, 138);\n        break;\n        case Tower.the360: \n            if(upgRange || money<the360_TOWER_RANGEUPG_COST) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Range (1)\\nCost: \"+the360_TOWER_RANGEUPG_COST+\"\\nPress 1 to\\nupgrade\", 338, 138);\n            break;\n        \n        case Tower.FAST: \n            if (upgRange || money < FAST_TOWER_RANGEUPG_COST) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Range (1)\\nCost: \"+FAST_TOWER_RANGEUPG_COST+\"\\nPress 1 to\\nupgrade\", 338, 138);\n            break;\n    }\n    \n    // DELAY\n    \n    switch (towerToUpg.type) {\n        case Tower.REG: \n            if(upgDelay || money < REG_TOWER_DELAYUPG_COST) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Delay (2)\\nCost: \"+REG_TOWER_DELAYUPG_COST+\"\\nPress 2 to\\nupgrade\", 338, 225);\n        break;\n        case Tower.the360: \n            if(upgDelay || money<the360_TOWER_DELAYUPG_COST) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Delay (2)\\nCost: \"+the360_TOWER_DELAYUPG_COST+\"\\nPress 2 to\\nupgrade\", 338, 225);\n            break;\n        \n        case Tower.FAST: \n            if (upgDelay || money < FAST_TOWER_DELAYUPG_COST) {\n                fill (255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Delay (2)\\nCost: \"+FAST_TOWER_DELAYUPG_COST+\"\\nPress 2 to\\nupgrade\", 338, 255);\n            break;\n    }\n    \n    // DAMAGE\n    \n    switch (towerToUpg.type) {\n        case Tower.REG: \n            if(upgDamage || money < REG_TOWER_DAMAGEUPG_COST) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Damage (3)\\nCost: \"+REG_TOWER_DAMAGEUPG_COST+\"\\nPress 3 to\\nupgrade\", 331, 325);\n        break;\n        case Tower.the360: \n            if(upgDamage || money<the360_TOWER_DAMAGEUPG_COST){\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Damage (3)\\nCost: \"+the360_TOWER_DAMAGEUPG_COST+\"\\nPress 3 to\\nupgrade\", 331, 325);\n            break;\n        \n        case Tower.FAST: \n            if(upgDamage || money <FAST_TOWER_DAMAGEUPG_COST) {\n                fill(255, 0, 0);\n            } else {\n                fill(0, 255, 0);\n            }\n            text(\"Damage (3)\\nCost: \"+FAST_TOWER_DAMAGEUPG_COST+\"\\nPress 3 to\\nupgrade\", 331, 325);\n            break;\n    }\n};\n\n\nvar progress = 0; // which enemy in the wave\nnextWave = function() {\n    wave++;\n    currentWave = waves[wave];\n    waveActive = true;\n    progress = 0;\n    \n    ROCK_HEALTH += (wave - 1);\n    BUG_HEALTH += (wave - 1);\n    STRONG_HEALTH += (wave - 1);\n    \n};\n\nvar timer = function() {\n    if (!waveActive) {\n        return;\n    }\n    if (updateStep % ENEMY_DELAY === 0) {\n        var enemyCode = currentWave[progress];\n        if (enemyCode === \"E\") {\n            waveActive = false;\n            money += (30 + round(wave/2));\n        } else if (enemyCode === \" \") {\n            enemyCode = currentWave[progress+1];\n            if (enemyCode === \"E\") {\n                waveActive = false;\n                money += (30 + round(wave/2));\n            } else {\n                progress++;\n                createEnemy(enemyCode);\n            }\n        } else {\n            createEnemy(enemyCode);\n        }\n        progress++;\n    }\n};\n\n\nvar transitionStates = function() {\n    if (gameState === State.GAME && playerLives <= 0) {\n        \n    } else if (gameState === State.GAME && \n        wave === waves[waves.length - 1]) {\n        gameState = State.WIN;\n    }\n};\n\n/** MAIN GAME LOOP */\n\n/************************************************************\n * All the updating functions (updateEnemies, updateTowers, \n * etc) go in this function, update().\n * All the drawing functions (drawEnemies, drawTowers, etc)\n * go in drawGame();\n ************************************************************/\n\nvar update = function() {\n    updateTowers();\n    \n    updateEnemies();\n    updateMissiles();\n    \n    checkEnemyCollisions();\n    \n    timer();\n    \n    updateStep++; \n    /** For updating purposes. Do not use debugStep or\n     * frameCount in any update command (e.g. \n     * fireTowerMissles).\n     */\n};\n\nvar drawGame = function() {\n    drawTrack();\n    drawRanges();\n    drawEnemies();\n    drawTowers();\n    drawMissiles();\n    \n    drawInfo();\n    drawTowerInfo();\n    drawUpgrades();\n};\n\n\n// The draw loop!\nvar draw = function() {\n    background(0, 0, 0);\n    if (gameState === State.GAME) {\n        drawInfo();\n        drawTowerInfo();\n        drawGame();\n    } else if (gameState === State.SPLASH) {\n        drawSplash();\n    } else if (gameState === State.WIN) {\n        drawWin();\n    }\n    \n    \n    // Don\'t update if paused\n    if (!paused && gameState === State.GAME) {\n        update(); \n        // update() has an internal step counter called updateStep. Don\'t use frameCount or debugStep.\n    }\n    \n    \n    /**\n     * The optimal scale for drawing enemies is (0.5, 0.5).\n     * It\'s okay that the image is bigger than the track\n     * thickness.\n     * \n     * Images are actually 26 pixels to the right\n     * and 53 pixels below the x and y parameters of\n     * the image(image, x, y) function. So you want to draw\n     * the image at the point (x - 50, y - 112) after scaling\n     * to 50%. Or use translate(x - 25, y - 56) before scaling.\n     */\n    \n    \n    \n    debugStep++; // Debug only!\n    \n    \n    if(paused) {\n        textSize(100);\n        fill(255, 0, 0);\n        text(\"Paused\", 30, 230);\n    }\n};";
window.liveEditor = new LiveEditor({
                el: $("#sample-live-editor"),
                code: code,
                width: 400,
                height: 400,
                editorHeight: "80%",
                autoFocus: true,
                workersDir: "../../build/workers/",
                externalsDir: "../../build/external/",
                imagesDir: "../../build/images/",
                soundsDir: "../../sounds/",
                execFile: outputUrl,
                jshintFile: "../../build/external/jshint/jshint.js",
                newErrorExperience: true,
            });
            liveEditor.editor.on("change", function() {
                window.localStorage["test-code"] = liveEditor.editor.text();
            });
            ScratchpadAutosuggest.init(liveEditor.editor.editor);
            </script>
        </body>
        </html>
        