<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Birds Flock Together</title>
    <link rel="stylesheet" href="../../build/css/live-editor.core_deps.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.audio.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.tooltips.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.ui.css"/>
<style>
        body {
            padding: 20px;
        }
        h1 {
            padding: 0;
            margin: 0 0 20px 0;
        }
        #sample-live-editor {
            padding: 0;
        }
    </style>
</head>
<body>
    <h1>Birds Flock Together</h1>
    <div id="sample-live-editor"></div>
    <script src="../../build/js/live-editor.core_deps.js"></script>
    <script src="../../build/js/live-editor.editor_ace_deps.js"></script>
    <script src="../../build/js/live-editor.audio.js"></script>
    <script src="../../build/js/live-editor.shared.js"></script>
    <script src="../../build/js/live-editor.tooltips.js"></script>
    <script src="../../build/js/live-editor.ui.js"></script>
    <script src="../../build/js/live-editor.editor_ace.js"></script>
    <script>
    var outputUrl = "../output.html";
var code = "/**Birds Flock Together by David Elijah de Siqueira Campos McLaughlin\nOriginal size(400, 400);\nOriginally Created on 2012-11-12T19:07:18Z by kaid_976851263300560061760577\nLast Edited: 2012-11-12T19:07:18Z\nVotes/Spinoffs: 1/0\nOriginally Created: 2012-09-29T12:45:53Z from origin 940061217 with similarity of 0.9816839895724008\nOriginal Link: https://www.khanacademy.org/computer-programming/birds-flock-together/1061079363\nRetrieved On: 07-Nov-2022 (17:07:19.394131)**/\
";

code = code + "\n// This is a bunch of birds flying around together\n// as a flock. It\'s called \"boids.\"\n//\n// It\'s pretty cool, because each boid is only following a\n// very simple set of three rules -- and neat flocking behavior\n// emerges.\n//\n// Each boid simply tries to:\n//    * Move to the center of the flock\n//    * Fly in the same direction as the flock\n//    * Avoid running into other boids\n//\n// Use your mouse to make the birds fly away if they get\n// too close to each other.\n//\n// Read more at http://www.kfish.org/boids and\n// http://www.coderholic.com/javascript-boids, which this is\n// modeled after.\n\n// The number of birds (\"boids\") flying around the screen\nvar numBoids = 50;\n\n// Initial image size for each boid\nvar boidSize = 50;\n\n// Top speed for each boid\nvar maxVelocity = 5;\n\n// How close can boids get to each other before they try\n// to fly away to avoid colliding?\nvar minSafeDistance = 1;\n\n// x, y, and z boundaries for each boid. Our boids fly\n// in three dimensions.\nvar minY = 10;\nvar maxY = 400;\nvar minX = 0;\nvar maxX = 400;\nvar minZ = 50;\nvar maxZ = 350;\n\n// How strongly should your boids try to follow the direction\n// of the rest of the flock? Try adjusting this number and\n// watch how the boids behave.\nvar followFlockTendency = 0.35;\n\n// How strongly should your boids try to get to the center of\n// the flock? Try adjusting this number and see how closely\n// the boids will stick together. What happens if you make this\n// number 0.95?\nvar aimAtFlockCenterTendency = 0.35;\n\n// Load up all the images used\nvar backgroundImage = getImage(\"space/background\");\nvar boidImage1 = getImage(\"space/rocketship\");\nvar boidImage2 = getImage(\"space/octopus\");\nvar boidImage3 = getImage(\"space/beetleship\");\nvar tallTreeImage = getImage(\"cute/TreeTall\");\nvar shortTreeImage = getImage(\"cute/TreeShort\");\nvar uglyTreeImage = getImage(\"cute/TreeUgly\");\nvar starImage = getImage(\"cute/Blank\");\nvar mouseImage = getImage(\"cute/EnemyBug\");\n\n// Create each boid. Each boid stores its current position\n// and its current velocity.\nvar boids = [];\nfor (var i = 0; i < numBoids; i += 1) {\n    boids[boids.length] = {\n        n: i,\n        x: random(minX, maxX),\n        y: random(minY, maxY),\n        z: random(minZ, maxZ),\n        xVelocity: random(-1 * maxVelocity, maxVelocity),\n        yVelocity: random(-1 * maxVelocity, maxVelocity),\n        zVelocity: random(-1 * maxVelocity, maxVelocity)\n    };\n}\n\n// Return the distance between two points (dX, dY, and dZ\n// are the differences between x, y, and z coordinates of the\n// two points).\nvar distance = function(dX, dY, dZ) {\n    return sqrt((dX * dX) + (dY * dY) + (dZ * dZ)) * 1.0;\n};\n\n// Return the distance between two boids\nvar distanceBetween = function(boidA, boidB) {\n    return distance(\n        boidA.x - boidB.x,\n        boidA.y - boidB.y,\n        boidA.z - boidB.z\n        );\n};\n\n// Are these two boids two close to each other? They don\'t\n// want to collide.\nvar areBoidsTooClose = function(boid, otherBoid, safeDist) {\n    return distanceBetween(boid, otherBoid) < safeDist;\n};\n\n// This function is called once per animation for each boid.\n// It makes the boid slightly adjust its direction to follow\n// the same flight direction as the rest of the flock.\nvar followFlock = function(boid) {\n    var xVelocityFlock = 0;\n    var yVelocityFlock = 0;\n    var zVelocityFlock = 0;\n    \n    // Find the average x, y, and z velocity for all other\n    // boids in the flock.\n    for (var i = 0; i < numBoids; i += 1) {\n        var otherBoid = boids[i];\n        if (otherBoid.n !== boid.n) {\n            xVelocityFlock += otherBoid.xVelocity;\n            yVelocityFlock += otherBoid.yVelocity;\n            zVelocityFlock += otherBoid.zVelocity;\n        }\n    }\n    \n    xVelocityFlock = xVelocityFlock / numBoids;\n    yVelocityFlock = yVelocityFlock / numBoids;\n    zVelocityFlock = zVelocityFlock / numBoids;\n    \n    // Compute the distance between this boid\'s speed and\n    // the rest of the flock\'s average speed...\n    var dist = distance(\n        xVelocityFlock, yVelocityFlock, zVelocityFlock);\n    if (dist === 0) {\n        return;\n    }\n    \n    // ...and use that distance to adjust this boid\'s speed.\n    boid.xVelocity += (xVelocityFlock / dist) * followFlockTendency;\n    boid.yVelocity += (yVelocityFlock / dist) * followFlockTendency;\n    boid.zVelocity += (zVelocityFlock / dist) * followFlockTendency;\n};\n\n// This function is called once per animation for each boid.\n// It makes the boid slightly adjust its direction to head\n// into the center of the flock.\nvar aimAtCenterOfFlock = function(boid) {\n    var xFromCenter = 0;\n    var yFromCenter = 0;\n    var zFromCenter = 0;\n    \n    // Find the average position of the rest of the flock\n    // so this boid can move into the center.\n    for (var i = 0; i < numBoids; i += 1) {\n        var otherBoid = boids[i];\n        if (otherBoid.n !== boid.n) {\n            xFromCenter += boid.x - otherBoid.x;\n            yFromCenter += boid.y - otherBoid.y;\n            zFromCenter += boid.z - otherBoid.z;\n        }\n    }\n    \n    xFromCenter = xFromCenter / numBoids;\n    yFromCenter = yFromCenter / numBoids;\n    zFromCenter = zFromCenter / numBoids;\n    \n    // Compute the distance between this boid\'s position and\n    // the center of the flock...\n    var dist = distance(xFromCenter, yFromCenter, zFromCenter);\n    if (dist === 0) {\n        return;\n    }\n    \n    // ...and use that distance to adjust this boid\'s position.\n    boid.xVelocity += (xFromCenter / dist) * -1 * aimAtFlockCenterTendency;\n    boid.yVelocity += (yFromCenter / dist) * -1 * aimAtFlockCenterTendency;\n    boid.zVelocity += (zFromCenter / dist) * -1 * aimAtFlockCenterTendency;\n};\n\n// This function is called once per animation for each boid.\n// It makes the boid avoid running into other boids.\nvar avoidOtherBoids = function(boid) {\n    var xAdjustment = 0;\n    var yAdjustment = 0;\n    var zAdjustment = 0;\n    \n    // Check every other boid...\n    for (var i = 0; i < numBoids; i += 1) {\n        var otherBoid = boids[i];\n        if (otherBoid.n !== boid.n) {\n            \n            // ...and make sure this boid isn\'t flying too\n            // close.\n            var isTooClose = areBoidsTooClose(\n                boid, otherBoid, minSafeDistance);\n            \n            // If flying too close, adjust this boid\'s velocity\n            // so it\'ll fly away from the dangerous collision.\n            if (isTooClose) {\n                var dX = boid.x - otherBoid.x;\n                var dY = boid.y - otherBoid.y;\n                var dZ = boid.z - otherBoid.z;\n                var sqrtSafeDist = sqrt(minSafeDistance);\n                \n                if (dX < 0) {\n                    dX = -sqrtSafeDist - dX;\n                }\n                else {\n                    dX = sqrtSafeDist - dX;\n                }\n                \n                if (dY < 0) {\n                    dY = -sqrtSafeDist - dY;\n                }\n                else {\n                    dY = sqrtSafeDist - dY;\n                }\n                \n                if (dZ < 0) {\n                    dZ = -sqrtSafeDist - dZ;\n                }\n                else {\n                    dZ = sqrtSafeDist - dZ;\n                }\n                \n                xAdjustment += dX;\n                yAdjustment += dY;\n                zAdjustment += dZ;\n            }\n        }\n    }\n    \n    // Finally, adjust this boid\'s velocity to avoid all\n    // possible collisions.\n    var soften = minSafeDistance / numBoids * 2.0;\n    boid.xVelocity -= xAdjustment / soften;\n    boid.yVelocity -= yAdjustment / soften;\n    boid.zVelocity -= zAdjustment / soften;\n};\n\n// This function is called once per animation for each boid.\n// It makes the boid avoid the mouse (if the mouse is\n// actively being used).\nvar isMouseActive = false;\nvar avoidMouse = function(boid) {\n    // If the mouse isn\'t being used, don\'t do anything.\n    if (!isMouseActive) {\n        return;\n    }\n    \n    var xAdjustment = 0;\n    var yAdjustment = 0;\n    \n    // When the mouse is being used, we treat it as a \"boid\"\n    // for others to avoid (even though it looks like a rock).\n    var mouseBoid = {\n        x: mouseX,\n        y: mouseY,\n        z: boid.z\n    };\n    \n    // Is this boid too close to the mouse?\n    var mouseSafeDistance = minSafeDistance * 0;\n    var isTooClose = areBoidsTooClose(\n                boid, mouseBoid, mouseSafeDistance);\n                \n    // If this boid is too close to the mouse, adjust this\n    // boid\'s velocity so it\'ll fly away from the big dangerous\n    // rock.\n    if (isTooClose) {\n        var dX = boid.x - mouseBoid.x;\n        var dY = boid.y - mouseBoid.y;\n        var sqrtSafeDist = sqrt(mouseSafeDistance);\n                \n        if (dX < 0) {\n            dX = -sqrtSafeDist - dX;\n        }\n        else {\n            dX = sqrtSafeDist - dX;\n        }\n                \n        if (dY < 0) {\n            dY = -sqrtSafeDist - dY;\n        }\n        else {\n            dY = sqrtSafeDist - dY;\n        }\n        \n        xAdjustment += dX;\n        yAdjustment += dY;\n    }\n    \n    boid.xVelocity -= xAdjustment / 1.2;\n    boid.yVelocity -= yAdjustment / 1.2;\n};\n\n// This function is called once per animation for each boid.\n// It keeps the boid within the bounds of the picture.\nvar keepBoidWithinBounds = function(boid) {\n    // If this boid is outside the X coordinates of our image,\n    // make it fly the other direction so it\'ll come back.\n    if (boid.x > maxX) {\n        boid.x = maxX;\n        boid.xVelocity = -1 * boid.xVelocity;\n    }\n    if (boid.x < minX) {\n        boid.x = minX;\n        boid.xVelocity = -1 * boid.xVelocity;\n    }\n    \n    // If this boid is outside the Y coordinates of our image,\n    // make it fly the other direction so it\'ll come back.\n    if (boid.y > maxY) {\n        boid.y = maxY;\n        boid.yVelocity = -1 * boid.yVelocity;\n    }\n    if (boid.y < minY) {\n        boid.y = minY;\n        boid.yVelocity = -1 * boid.yVelocity;\n    }\n    \n    // If this boid is outside the Z coordinates of our image,\n    // make it fly the other direction so it\'ll come back.\n    if (boid.z > maxZ) {\n        boid.z = maxZ;\n        boid.zVelocity = -1 * boid.zVelocity;\n    }\n    if (boid.z < minZ) {\n        boid.z = minZ;\n        boid.zVelocity = -1 * boid.zVelocity;\n    }\n};\n\n// This function is called once per animation for each boid.\n// It makes sure the boid isn\'t going too fast.\nvar restrictVelocity = function(boid) {\n    boid.xVelocity = min(boid.xVelocity, maxVelocity);\n    boid.yVelocity = min(boid.yVelocity, maxVelocity);\n    boid.zVelocity = min(boid.zVelocity, maxVelocity);\n};\n\n// This function is called once per animation for each boid.\n// It runs all the simple rules that create flocking behavior\n// and adjusts the position of the boid for the next step of\n// the animation.\nvar positionBoid = function(boid) {\n    // Simple rule #1: follow the flock\'s flight direction\n    followFlock(boid);\n    \n    // Simple rule #2: aim into the center of the flock\n    aimAtCenterOfFlock(boid);\n    \n    // Simple rule #3: avoid collision with other boids\n    avoidOtherBoids(boid);\n    \n    // Make sure nobody is going to get a speeding ticket for\n    // flying too fast\n    restrictVelocity(boid);\n    \n    boid.x += boid.xVelocity;\n    boid.y += boid.yVelocity;\n    boid.z += boid.zVelocity;\n    \n    // Make sure all boids are flying within the image\n    keepBoidWithinBounds(boid);\n};\n\n// At each step of the animation, this draws the boid at its\n// new position.\nvar drawBoid = function(boid) {\n    // Mix up a few different boid images\n    var boidImage = boidImage1;\n    if (boid.n % 2 === 0) {\n        boidImage = boidImage2;\n    }\n    else if (boid.n % 3 === 0) {\n        boidImage = boidImage3;\n    }\n    \n    // Use the boid\'s z coordinate to get a 3d effect.\n    // If the boid is far away, make the image small.\n    // If the boid is up close, make the image big.\n    var baseZ = (maxZ - minZ) / 1.4;\n    var size = boidSize * (boid.z / baseZ);\n    \n    image(boidImage, boid.x - size / 2, boid.y - size/2, size, size);\n};\n\n// This draws the mouse\'s icon (a big rock you can use to\n// swat away the boids) if the mouse is being actively used.\nvar lastMouseX = -1;\nvar lastMouseY = -1;\nvar framesMouseHasNotMoved = -1;\nvar hasMouseMovedOnce = false;\nvar drawMouse = function() {\n    isMouseActive = false;\n    \n    // If the mouse is off the screen, don\'t draw the rock.\n    if (mouseX < minX && mouseX > maxX) {\n        return;\n    }\n    if (mouseY < minY && mouseY > maxY) {\n        return;\n    }\n    \n    if (lastMouseX === mouseX && lastMouseY === mouseY) {\n        // If the mouse hasn\'t moved in a while, don\'t draw it.\n        if (framesMouseHasNotMoved > 35) {\n            return;\n        }\n        framesMouseHasNotMoved += 1;\n    } else {\n        if (lastMouseX >= 0 || lastMouseY >= 0) {\n            hasMouseMovedOnce = true;\n            framesMouseHasNotMoved = 0;\n        }\n    }\n\n    // If the mouse has moved at least once, draw the rock.\n    if (hasMouseMovedOnce) {\n        image(mouseImage, mouseX - 25, mouseY - 55, 50, 80);\n        isMouseActive = true;\n    }\n    lastMouseX = mouseX;\n    lastMouseY = mouseY;\n};\n\n// This draws the background and trees, as well as the moving\n// star.\nvar starPos = 10.0;\nvar drawBackground = function() {\n    // Draw the background\n    image(backgroundImage, 0, 0);\n    \n    // Draw the white background stars\n    stroke(255, 255, 255);\n    ellipse(100, 100, 3, 3);\n    ellipse(127, 193, 4, 4);\n    ellipse(184, 68, 2, 2);\n    ellipse(26, 184, 3, 3);\n    ellipse(284, 91, 3, 3);\n    ellipse(358, 148, 4, 4);\n    ellipse(86, 272, 2, 2);\n    ellipse(221, 203, 3, 3);\n    ellipse(130, 100, 3, 3);\n    ellipse(337, 193, 4, 4);\n    ellipse(284, 78, 2, 2);\n    ellipse(276, 284, 3, 3);\n    ellipse(24, 91, 3, 3);\n    ellipse(158, 248, 4, 4);\n    ellipse(36, 212, 2, 2);\n    ellipse(241, 3, 3, 3);\n    \n    // Draw the big rotating star\n    starPos += 0.2;\n    if (starPos > 200) {\n        starPos = 0;\n    }\n    rotate(-1 * starPos);\n    image(starImage, -9, 285);\n    resetMatrix();\n\n    // Draw the forest\n    image(uglyTreeImage, -20, 270);\n    image(tallTreeImage, 20, 255);\n    image(tallTreeImage, 70, 265);\n    image(tallTreeImage, 178, 251);\n    image(shortTreeImage, 130, 290);\n    image(shortTreeImage, 230, 260);\n    image(shortTreeImage, 281, 321);\n    image(tallTreeImage, 330, 250);\n};\n\nvar draw = function() {\n    // At every step of the animation, draw the background...\n    drawBackground();\n    \n    // ...then draw the mouse\'s rock\n    drawMouse();\n    \n    // ...then reposition and draw every boid.\n    for (var i = 0; i < numBoids; i += 1) {\n        positionBoid(boids[i]);\n        drawBoid(boids[i]);\n    }\n};";
window.liveEditor = new LiveEditor({
                el: $("#sample-live-editor"),
                code: code,
                width: 400,
                height: 400,
                editorHeight: "80%",
                autoFocus: true,
                workersDir: "../../build/workers/",
                externalsDir: "../../build/external/",
                imagesDir: "../../build/images/",
                soundsDir: "../../sounds/",
                execFile: outputUrl,
                jshintFile: "../../build/external/jshint/jshint.js",
                newErrorExperience: true,
            });
            liveEditor.editor.on("change", function() {
                window.localStorage["test-code"] = liveEditor.editor.text();
            });
            ScratchpadAutosuggest.init(liveEditor.editor.editor);
            </script>
        </body>
        </html>
        