<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Challenge:  Modeling Accretion Disks</title>
    <link rel="stylesheet" href="../../build/css/live-editor.core_deps.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.audio.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.tooltips.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.ui.css"/>
<style>
        body {
            padding: 20px;
        }
        h1 {
            padding: 0;
            margin: 0 0 20px 0;
        }
        #sample-live-editor {
            padding: 0;
        }
    </style>
</head>
<body>
    <h1>Challenge:  Modeling Accretion Disks</h1>
    <div id="sample-live-editor"></div>
    <script src="../../build/js/live-editor.core_deps.js"></script>
    <script src="../../build/js/live-editor.editor_ace_deps.js"></script>
    <script src="../../build/js/live-editor.audio.js"></script>
    <script src="../../build/js/live-editor.shared.js"></script>
    <script src="../../build/js/live-editor.tooltips.js"></script>
    <script src="../../build/js/live-editor.ui.js"></script>
    <script src="../../build/js/live-editor.editor_ace.js"></script>
    <script>
    var outputUrl = "../output.html";
var code = "/**Challenge:  Modeling Accretion Disks by David Elijah de Siqueira Campos McLaughlin\nOriginal size(400, 400);\nOriginally Created on 2012-11-29T17:28:58Z by kaid_976851263300560061760577\nLast Edited: 2012-11-29T17:28:58Z\nVotes/Spinoffs: 5/2\nOriginally Created: 2012-11-29T18:28:14Z from origin 1180451277 with similarity of 0.9981508700393533\nOriginal Link: https://www.khanacademy.org/computer-programming/challenge-modeling-accretion-disks/1183055533\nRetrieved On: 07-Nov-2022 (17:06:51.810625)**/\
";

code = code + "\n/***********************************************************\n * A roughly spherical cloud of particles collapsing\n * and coalescing under its own gravity.\n * \n * Doesn\'t really form a spinning disc, perhaps because\n * particle rotation is not considered and there is no \n * \"viscosity\". Maybe with a billion particles it would work.\n * Or maybe it needs non-merging collisions.\n * \n * Use the mouse to rotate the universe\n * More controls are available at the bottom of the screen on mouseover.\n * \n * Note that scaling does no affect particle size to make \n * it easier to follow particles at extreme scales.\n***********************************************************/\n\nvar numParticles = 400;\nvar initialMassRange = [1, 32];\nvar initialMaxDistance = 800;\n\nvar GRAVITATIONAL_CONSTANT = 0.05;\n\n// How close particles have to be for a collision\nvar collisionThreshold = 3;\n\n// How much mass a particle needs for it to become a star\nvar sunThreshold = 200;\n\nvar backgroundColour = color(30, 30, 40);\nvar particleColour = color(240, 240, 220);\nvar sunColour = color(255, 153, 0);\nvar myFont = createFont(\"times\", 12);\n\nvar toolbarHeight = 50;\nvar sliderX = 20;\nvar sliderY = 382;\nvar sliderWidth = 100;\n\nvar rotateRate = 1; // Speed of rotation using mouse\n\nvar running = true;\nvar mouseOverButton = false;\nvar currentX = false;\nvar currentY = false;\nvar currentScale = 2;\nvar maxScale = 20;\nvar totalMass = 0;\n\nvar Particle = function(x, y, z, m) {\n    this.position = [x, y, z];\n    this.velocity = [random()-0.5,\n                     random()-0.5,\n                     random()-0.5];\n                     \n    this.mass = m;\n    this.combineWith = [];\n    \n    // Radius is the cube root of mass\n    this.getRadius = function() {\n        this.radius = pow(this.mass, 1/3);\n    };\n    \n    this.getRadius();\n    \n    this.draw = function() {\n        // Particles are darker the further away they are\n        var d = (this.position[2] + 400) / 700;\n        if (d < 0.05) { d = 0.05; }\n        else if (d > 1) { d = 1; }\n        \n        var c;\n        if (this.mass < sunThreshold) {\n            c = lerpColor(backgroundColour, \n                          particleColour, d);\n        } else {\n            c = sunColour;\n        }\n        fill(c);\n        //fill(particleColour);\n        \n        var r = this.radius * currentScale;\n        \n        if (r < 1) {\n            point(this.position[0], this.position[1]);\n        } else {\n            ellipse(this.position[0], this.position[1],\n            r, r);\n        }\n    };\n    \n    this.move = function() {\n        this.position[0] += this.velocity[0];\n        this.position[1] += this.velocity[1];\n        this.position[2] += this.velocity[2];\n    };\n    \n    this.attract = function(that) {\n        var dx = this.position[0] - that.position[0];\n        var dy = this.position[1] - that.position[1];\n        var dz = this.position[2] - that.position[2];\n        var d2 = dx * dx + dy * dy + dz * dz;\n        var d = sqrt(d2);\n        \n        if (d < (this.radius + that.radius) * collisionThreshold) {\n            this.combineWith.push(that);\n            return;\n        }\n        \n        var force = this.mass * that.mass / d2;\n        force *= GRAVITATIONAL_CONSTANT;\n        var accel1 = force / this.mass;\n        var accel2 = force / that.mass;\n        \n        dx /= d;\n        dy /= d;\n        dz /= d;\n        \n        this.velocity[0] -= accel1 * dx;\n        this.velocity[1] -= accel1 * dy;\n        this.velocity[2] -= accel1 * dz;\n        \n        that.velocity[0] += accel2 * dx;\n        that.velocity[1] += accel2 * dy;\n        that.velocity[2] += accel2 * dz;\n    };\n    \n    this.mergeWith = function(that) {\n        var totalMass = this.mass + that.mass;\n        var proportion = this.mass / totalMass;\n        \n        for (var i=0; i<3; i++) {\n            this.position[i] = this.position[i] * proportion + \n                               that.position[i] * (1 - proportion);\n            this.velocity[i] = this.velocity[i] * proportion + \n                               that.velocity[i] * (1 - proportion);\n        }\n\n        this.mass = totalMass;\n        this.getRadius();\n        this.combineWith = [];\n\n    };\n};\n\nvar initialiseParticles = function(n) {\n    var particles = [];\n    var massRange = initialMassRange[1]-initialMassRange[0];\n    totalMass = 0;\n    \n    for (var i=0; i<n; i++) {\n        var maxD = initialMaxDistance;\n        var x = random() * maxD - maxD / 2;\n        \n        maxD -= abs(x);\n        var y = random() * maxD - maxD /2;\n        \n        maxD -= abs(y);\n        var z = random() * maxD - maxD /2;\n        \n        var m = initialMassRange[0] + random() * massRange;\n        totalMass += m;\n        \n        particles.push(new Particle(x, y, z, m));\n    }\n    \n    return particles;\n};\n\nvar particles = initialiseParticles(numParticles);\n\n// Adjust to keep centred on the centre of mass\n// But maybe this never changes\nvar centreParticles = function(particles) {\n    var mid = [0, 0, 0];\n    var i;\n    \n    for (var d=0; d<3; d++) {\n        for (i=0; i<particles.length; i++) {\n            mid[d] += particles[i].mass * particles[i].position[d];\n        }\n        \n        mid[d] /= totalMass;\n        \n        for (i=0; i<particles.length; i++) {\n            particles[i].position[d] -= mid[d];\n        }\n    }\n\n    resetMatrix();\n    translate(200, 200);\n    scale(1/currentScale, 1/currentScale);\n};\n\nvar drawSlider = function(x, y) {\n    strokeWeight(1);\n    fill(20, 20, 50);\n    \n    textFont(myFont, 14);\n    textSize(14);\n    text(\"Scale 1:\" + round(currentScale * 10)/10, x, y-16);\n    \n    rect(x, y, sliderWidth, 3, 4);\n    stroke(160, 160, 160);\n    line(x + 1, y, x + sliderWidth - 2, y);\n\n    fill(180, 180, 180);\n    stroke(50, 50, 50);\n    var proportion = (currentScale - 0.5) / (maxScale - 0.5);\n    var buttonX = x + sliderWidth * proportion - 5;\n    \n    rect(buttonX, y-7, 10, 16, 3);\n    line(buttonX + 3, y - 2, buttonX + 7, y - 2);\n    line(buttonX + 3, y + 1, buttonX + 7, y + 1);\n    line(buttonX + 3, y + 4, buttonX + 7, y + 4);\n};\n\nvar handleMouseEvents = function() {\n    var y = 400 - toolbarHeight;\n    mouseOverButton = false;\n    \n    if (mouseY > y) {\n        resetMatrix();\n        \n        fill(200, 200, 200, 100);\n        rect(0, y, 400, toolbarHeight);\n        \n        strokeWeight(2);\n        stroke(200, 200, 200);\n        line(0, y, 400, y);\n        \n        drawSlider(sliderX, sliderY);\n        fill(20, 20, 50);\n        textAlign(LEFT, CENTER);\n        text(\"Number of bodies: \" + particles.length,\n             240, y+toolbarHeight/2);\n        \n        strokeWeight(1);\n        fill(200, 200, 200, 100);\n        \n        // Mouseover effect\n        if (mouseX > 190 && mouseX < 210) {\n            fill(240, 240, 240);\n            mouseOverButton = true;\n        }\n        \n        if (running) {\n            // Pause button\n            rect(193, y + 12, 5, toolbarHeight-24, 5);\n            rect(202, y + 12, 5, toolbarHeight-24, 5);\n        } else {\n            triangle(192, y + 15,\n                     208, y + toolbarHeight/2,\n                     192, y + toolbarHeight - 15);\n        }\n    }\n};\n\nvar rotateY3D = function(theta){\n    var ct = cos(theta);\n    var st = sin(theta);\n    var x, z;\n    \n    for (var i = 0; i < particles.length; i+=1) {\n        var p = particles[i];\n        x = p.position[0];\n        z = p.position[2];\n        p.position = [ct * x + st * z,\n                      p.position[1],\n                      -st * x + ct * z];\n        \n        x = p.velocity[0];\n        z = p.velocity[2];\n        p.velocity = [ct * x + st * z,\n                      p.velocity[1],\n                      -st * x + ct * z];\n    }\n};\n\nvar rotateX3D = function(theta){\n    var ct = cos(theta);\n    var st = sin(theta);\n    var y, z;\n    \n    for (var i = 0; i < particles.length; i+=1) {\n        var p = particles[i];\n        y = p.position[1];\n        z = p.position[2];\n        p.position = [p.position[0],\n                      ct*y - st*z,\n                      st*y + ct*z];\n        y = p.velocity[1];\n        z = p.velocity[2];\n        p.velocity = [p.velocity[0],\n                      ct*y - st*z,\n                      st*y + ct*z];\n    }\n};\n\nvar sortByZ = function(a, b) {\n    return a.position[2] - b.position[2];\n};\n\nvar draw = function() {\n    var i, j;\n    \n    if (running) {\n        // Gravitational attraction\n        for (i=0; i<particles.length; i++) {\n            for (j=i+1; j<particles.length; j++) {\n                particles[i].attract(particles[j]);\n            }\n        }\n        \n        // Combining particles\n        var particles_to_remove = [];\n        for (i=0; i<particles.length; i++) {\n            for (j=0; j<particles[i].combineWith.length; j++) {\n                var p = particles[i].combineWith[j];\n                particles[i].mergeWith(p);\n                particles_to_remove.push(particles.indexOf(p));\n            }\n        }\n        \n        // Remove particles\n        particles_to_remove.sort();\n        for (i=0; i<particles_to_remove.length; i++) {\n            particles.splice(particles_to_remove[i], 1);\n        }\n        particles_to_remove = [];\n        \n        // Moving\n        for (i=0; i<particles.length; i++) {\n            particles[i].move();\n        }\n        //particles.sort(sortByZ);\n    }\n    \n    centreParticles(particles);\n    background(backgroundColour);\n    noStroke();\n\n    for (i=0; i<particles.length; i++) {\n        particles[i].draw();\n    }\n    \n    handleMouseEvents();\n};\n\nvar mouseClicked = function() {\n    if (mouseOverButton) {\n        if (running) { running = false; }\n        else { running = true; }   \n    }\n};\n\nvar mouseDragged = function() {\n    if (!mouseIsPressed) {\n        currentX = false;\n        return;\n    }\n    \n    if (mouseY < 400 - toolbarHeight) {\n        // Rotate universe\n        if (currentX !== false) {\n            rotateY3D(-(currentX - mouseX) * rotateRate);\n            rotateX3D( (currentY - mouseY) * rotateRate);\n        }\n        currentX = mouseX;\n        currentY = mouseY;\n    } else if (mouseX > sliderX &&\n               mouseX < sliderX + sliderWidth &&\n               mouseY > sliderY - 7 &&\n               mouseY < sliderY + 9) {\n        // Drag slider for scale\n            var proportion = (mouseX - sliderX)/sliderWidth;\n            currentScale = 0.3 + proportion * (maxScale - 0.3);\n    }\n\n};\n\nvar mouseReleased = function () {\n    currentX = false;\n};\n\nvar mouseOut = function(){\n    mouseY = 0;\n    currentX = false;\n    mouseIsPressed = false;\n};";
window.liveEditor = new LiveEditor({
                el: $("#sample-live-editor"),
                code: code,
                width: 400,
                height: 400,
                editorHeight: "80%",
                autoFocus: true,
                workersDir: "../../build/workers/",
                externalsDir: "../../build/external/",
                imagesDir: "../../build/images/",
                soundsDir: "../../sounds/",
                execFile: outputUrl,
                jshintFile: "../../build/external/jshint/jshint.js",
                newErrorExperience: true,
            });
            liveEditor.editor.on("change", function() {
                window.localStorage["test-code"] = liveEditor.editor.text();
            });
            ScratchpadAutosuggest.init(liveEditor.editor.editor);
            </script>
        </body>
        </html>
        