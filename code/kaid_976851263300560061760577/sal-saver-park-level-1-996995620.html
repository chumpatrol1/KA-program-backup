<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Sal Saver: Park Level 1</title>
    <link rel="stylesheet" href="../../build/css/live-editor.core_deps.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.audio.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.tooltips.css"/>
    <link rel="stylesheet" href="../../build/css/live-editor.ui.css"/>
<style>
        body {
            padding: 20px;
        }
        h1 {
            padding: 0;
            margin: 0 0 20px 0;
        }
        #sample-live-editor {
            padding: 0;
        }
    </style>
</head>
<body>
    <h1>Sal Saver: Park Level 1</h1>
    <div id="sample-live-editor"></div>
    <script src="../../build/js/live-editor.core_deps.js"></script>
    <script src="../../build/js/live-editor.editor_ace_deps.js"></script>
    <script src="../../build/js/live-editor.audio.js"></script>
    <script src="../../build/js/live-editor.shared.js"></script>
    <script src="../../build/js/live-editor.tooltips.js"></script>
    <script src="../../build/js/live-editor.ui.js"></script>
    <script src="../../build/js/live-editor.editor_ace.js"></script>
    <script>
    var outputUrl = "../output.html";
var code = "/**Sal Saver: Park Level 1 by David Elijah de Siqueira Campos McLaughlin\nOriginal size(400, 400);\nOriginally Created on 2012-11-12T19:09:03Z by kaid_976851263300560061760577\nLast Edited: 2012-11-12T19:09:03Z\nVotes/Spinoffs: 1/0\nOriginally Created: 2012-08-25T21:33:27Z from origin 939844470 with similarity of 0.981990295597297\nOriginal Link: https://www.khanacademy.org/computer-programming/sal-saver-park-level-1/996995620\nRetrieved On: 07-Nov-2022 (17:07:05.309144)**/\
";

code = code + "\n//To win, Kill all enimies and get to \"Sal\". \n\n// CONTROLS: Why don\'t you check out the keyPressed and keyReleased functions? ;-)\n\nvar drawBackground = function() {\n    background(216, 245, 252);\n};\n\nvar TILE_HEIGHT = 43;\nvar TILE_WIDTH = 100;\n\nvar SCREEN_ROWS = 7;\nvar SCREEN_COLS = 4;\n\nvar TILE_MAP = [\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n[0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 1],\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n];\nvar TILE_MAP_ROWS = TILE_MAP.length;\nvar TILE_MAP_COLS = TILE_MAP[0].length;\n\n// enemies\nvar ENEMY_MAP = [\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0],\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0]\n];\n\nvar GRAVITY = 2;\n\n// tile access\n// -----------\nvar tileFor = function(tX, tY) {\n    if (typeof tX === \"object\") {\n        // someone passed in tileFor([tX, tY])\n        tY = tX[1];\n        tX = tX[0];\n    }\n\n    if (tY < TILE_MAP_ROWS && tX < TILE_MAP_COLS && tY >= 0 && tX >= 0) {\n        return TILE_MAP[tY][tX];\n    } else if (tY < 0) {\n        // this tile is above the screen, so it\'s open space\n        return 0;\n    } else {\n        // this tile is impassable\n        return -1;\n    }\n};\n\n// turns some point (x, y) into the (tX, tY) covering that point\nvar tileCoordsForPoint = function(x, y) {\n    if (typeof x === \"object\") {\n        // passed [x, y]\n        y = x[1];\n        x = x[0];\n    }\n    return [floor(x / TILE_WIDTH), floor(y / TILE_HEIGHT)];\n};\n\nvar tileForPoint = function(x, y) {\n    var tileCoords = tileCoordsForPoint(x, y),\n    tX = tileCoords[0],\n    tY = tileCoords[1];\n    \n    return tileFor(tX, tY);\n};\n\nvar rectIntersectsRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {\n    return ( ((x1 <= x2) && (x2 <= x1 + w1)) ||\n             ((x2 <= x1) && (x1 <= x2 + w2)) ) &&\n           ( ((y1 <= y2) && (y2 <= y1 + h1)) ||\n             ((y2 <= y1) && (y1 <= y2 + h2)) );\n};\n\nvar rectIntersectsTile = function(x, y, w, h, tX, tY) {\n    return rectIntersectsRect(x, y, w, h,\n    \n        tX * TILE_WIDTH,\n        tY * TILE_HEIGHT,\n        tX * TILE_WIDTH + TILE_WIDTH,\n        tY * TILE_HEIGHT + TILE_HEIGHT);\n};\n\nvar dudeIntersectsTile = function(dude, tX, tY) {\n    return rectIntersectsTile(\n        dude.x + dude.cXOffset,\n        dude.y + dude.cYOffset,\n        dude.cWidth,\n        dude.cHeight,\n        \n        tX, tY);\n};\n\nvar dudeIntersectsDude = function(dude1, dude2) {\n    return rectIntersectsRect(\n        dude1.x + dude1.cXOffset,\n        dude1.y + dude1.cYOffset,\n        dude1.cWidth,\n        dude1.cHeight,\n        \n        dude2.x + dude2.cXOffset,\n        dude2.y + dude2.cYOffset,\n        dude2.cWidth,\n        dude2.cHeight);\n};\n\nvar t = 0;\n\nvar scrollX = 0, scrollY = 0;\n\nvar animMap = {};\n\nvar tileImages = {\n    1: getImage(\"cute/GrassBlock\"),\n    2: getImage(\"cute/WoodBlock\"),\n    3: getImage(\"cute/PlainBlock\"),\n    4: getImage(\"cute/Rock\"),\n    5: getImage(\"cute/CharacterBoy\")\n    \n};\n\nvar animFor = function(tX, tY) {\n    if (tY in animMap && tX in animMap[tY]) {\n        var anim = animMap[tY][tX];\n\n        if (anim.type === \"powerup\") {\n            anim.yOffset = anim.t*anim.t - 6*anim.t;\n\n            if (anim.t > 0 && anim.yOffset === 0) {\n                delete animMap[tY][tX];\n            }\n        }\n        \n        anim.t += 1;\n\n        return anim;\n    }\n};\n\nvar drawTile = function(tX, tY) {\n    var anim = animFor(tX, tY);\n    if (anim) {\n        image(tileImages[anim.tile], TILE_WIDTH * tX + scrollX + anim.xOffset, TILE_HEIGHT * tY + scrollY + anim.yOffset);\n\n    } else {\n        var tileImage = tileImages[tileFor(tX, tY)];\n\n        if (!tileImage) {\n            return;\n        }\n\n        image(tileImages[tileFor(tX, tY)], TILE_WIDTH * tX + scrollX, TILE_HEIGHT * tY + scrollY);\n    }\n};\n\nvar dudeImages = {\n    1: getImage(\"cute/GemBlue\"),\n    2: getImage(\"cute/EnemyBug\"),\n    3: getImage(\"cute/Rock\"),\n    4: getImage(\"cute/CharacterBoy\")\n    \n};\n\nvar powerImages = {\n    \"armed\": getImage(\"avatars/leaf-blue\")\n};\n\nvar hero = {\n    // these are properties that all kinds of characters have\n    // including the hero\n    x: 0,\n    y: 0,\n\n    xVelocity: 0,\n    yVelocity: 0,\n\n    wounded: false,\n    lastWounded: 0,\n\n    cXOffset: 20,\n    cWidth: TILE_WIDTH - 40,\n    cYOffset: 0,\n    cHeight: TILE_HEIGHT,\n\n    im: 1,\n\n    // only the hero has the following properties, though\n    jump: 0, // increases as you hold down JUMP, so a brief tap !== a long press\n    running: false,\n\n    facesLeft: false,\n    ySway: 0,\n    \n    power: \"none\",\n    dead: false\n};\n\nvar hitPowerup = function(tX, tY) {\n    if (!(tY in animMap)) {\n        animMap[tY] = {};\n    }\n\n    animMap[tY][tX] = {\n        tile: tileFor(tX, tY),\n        type: \"powerup\",\n\n        xOffset: 0,\n        yOffset: 0,\n        \n        t: 0\n    };\n    \n    if (hero.power === \"none\") {\n        hero.power = \"armed\";\n    }\n};\n\nvar drawDude = function(dude) {\n    var mod;\n    \n    if (dude.wounded && round(t / 3) % 2 === 0) {\n        return;\n    }\n    \n    if (dude.xVelocity !== 0) {\n        if (dude.xVelocity < 0) {\n            dude.facesLeft = true;\n        } else if (dude.xVelocity > 0) {\n            dude.facesLeft = false;\n        }\n        \n        if (dude.yVelocity === 0) {\n            if (dude.ySway === 0) {\n                dude.ySway = 1;\n            } else {\n                if (dude.running) {\n                    mod = 3;\n                } else {\n                    mod = 4;\n                }\n                \n                if ((t % mod) === 0) {\n                    dude.ySway = -dude.ySway;\n                }\n            }\n        }\n    } else {\n        dude.ySway = 0;\n    }\n    \n    var img = dudeImages[dude.im];\n\n    var dying = dude.dead && (dude.y + scrollY) < height;\n    \n    if (dying) {\n        pushMatrix();\n        dude.rotation += 1;\n        \n        rotate(dude.rotation);\n    }\n    \n    if (dude.facesLeft) {\n        pushMatrix();\n        scale(-1, 1);\n        image(img, -(dude.x + scrollX + img.width), dude.y + scrollY + dude.ySway);\n        popMatrix();\n    } else {\n        image(img, dude.x + scrollX, dude.y + scrollY + dude.ySway);\n    }\n\n    if (dude.power && dude.power !== \"none\") {\n        image(powerImages[dude.power], dude.x + scrollX, dude.y + scrollY + dude.ySway);\n    }\n    \n    if (dying) {\n        popMatrix();\n    }\n};\n\n// sectumsempra\n// ------------\nvar enemies = [];\n\nvar loadEnemy = function(id, tX, tY) {\n    var im;\n    \n    if (id === 0) {\n        return;\n    }\n    \n    enemies.push({\n        x: tX * TILE_WIDTH,\n        y: tY * TILE_HEIGHT,\n        \n        xVelocity: 0,\n        yVelocity: 0,\n        \n        wounded: false,\n        \n        im: id,\n        \n        ySway: 0,\n        \n        cXOffset: 0,\n        cWidth: TILE_WIDTH,\n        cYOffset: 0,\n        cHeight: TILE_HEIGHT\n    });\n};\n\nvar loadEnemies = function() {\n    for (var tY = 0; tY < TILE_MAP_ROWS; tY += 1) {\n        for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n            if (ENEMY_MAP[tY][tX] !== 0) {\n                loadEnemy(ENEMY_MAP[tY][tX], tX, tY);\n            }\n        }\n    }\n};\n\nloadEnemies();\n\nvar drawEnemies = function() {\n    for (var i = 0; i < enemies.length; i += 1) {\n        drawDude(enemies[i]);\n    }\n};\n\n\n// drawing\n// -------\nvar drawMapBelowHero = function() {\n    var heroRow = max(floor(hero.y / TILE_HEIGHT), 0);\n    // have to draw rows at the bottom first, and go upward\n    for (var tY = TILE_MAP_ROWS - 1; tY >= heroRow; tY -= 1) {\n        for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n            drawTile(tX, tY);\n        }\n    }\n};\nvar drawMapAboveHero = function() {\n    // have to draw rows at the bottom first, and go upward\n    var heroRow = floor(hero.y / TILE_HEIGHT);\n    \n    if (heroRow >= 0) {\n        for (var tY = heroRow; tY >= 0; tY -= 1) {\n            for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n                drawTile(tX, tY);\n            }\n        }\n    }\n};\n\n// collisions\n// ----------\n\n// tiles adjacent to dudes\nvar tileCoordsAdj = function(dude, dir, amt) {\n    var x, y;\n    amt = amt || 1;\n\n    if (dir === \"left\") {\n        x = dude.x + dude.cXOffset - amt;\n        y = dude.y + dude.cYOffset;\n    } else if (dir === \"right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth + amt;\n        y = dude.y + dude.cYOffset;\n    } else if (dir === \"below left\") {\n        x = dude.x + dude.cXOffset;\n        y = dude.y + dude.cYOffset + dude.cHeight + amt;\n    } else if (dir === \"below right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth;\n        y = dude.y + dude.cYOffset + dude.cHeight + amt;\n    } else if (dir === \"above left\") {\n        x = dude.x + dude.cXOffset;\n        y = dude.y + dude.cYOffset - amt;\n    } else if (dir === \"above right\") {\n        x = dude.x + dude.cXOffset + dude.cWidth;\n        y = dude.y + dude.cYOffset - amt;\n    }\n    \n    return tileCoordsForPoint(x, y);\n};\n\nvar tileAdj = function(dude, dir, amt) {\n    return tileFor(tileCoordsAdj(dude, dir, amt));\n};\n\n// tile checks\nvar tileIsBlocking = function(tile) {\n    return tile !== 0;\n};\n\nvar tileIsPowerup = function(tile) {\n    return tile === 3;\n};\n\nvar tileAdjIsBlocking = function(dude, dir, amt) {\n    if (dir === \"left\" || dir === \"right\") {\n        return tileIsBlocking(tileAdj(dude, dir, amt));\n\n    } else if (dir === \"below\" || dir === \"above\") {\n        return tileIsBlocking(tileAdj(dude, dir + \" left\", amt)) ||\n            tileIsBlocking(tileAdj(dude, dir + \" right\", amt));\n    }\n};\n\nvar checkXCollisions = function(dude) {\n    // FIXME jump into block above you bug\n    if (tileAdjIsBlocking(dude, \"left\") && dude.xVelocity < 0) {\n        dude.xVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"left\") && !tileAdjIsBlocking(dude, \"right\")) {\n            dude.x += 1;\n        }\n    } else if (tileAdjIsBlocking(dude, \"right\") && dude.xVelocity > 0) {\n        dude.xVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"right\") && !tileAdjIsBlocking(dude, \"left\")) {\n            dude.x -= 1;\n        }\n    }\n};\n\nvar checkYCollisions = function(dude) {\n    var tal, tar;\n    var curTile = tileCoordsForPoint(dude.x, dude.y);\n    if (tileAdjIsBlocking(dude, \"below\") && dude.yVelocity > 0) {\n        dude.yVelocity = 0;\n        while (tileAdjIsBlocking(dude, \"below\")) {\n            dude.y -= 1;\n        }\n    } else if (tileAdjIsBlocking(dude, \"above\") && dude.yVelocity < 0) {\n        dude.yVelocity = dude.yVelocity * -1/2;\n\n        tal = tileCoordsAdj(dude, \"above left\");\n        if (tileIsPowerup(tileFor(tal))) {\n            hitPowerup(tal[0], tal[1]);\n        } else {\n            tar = tileCoordsAdj(dude, \"above right\");\n            if (tileIsPowerup(tileFor(tal))) {\n                hitPowerup(tar[0], tar[1]);\n            }\n        }\n\n        while (tileAdjIsBlocking(dude, \"above\")) {\n            dude.y += 1;\n        }\n    }\n};\n\n// input\n// -----\nvar keyJump = false, keyLeft = false, keyRight = false;\nvar keyPressed = function() {\n    if (keyCode === 32) { // 32 is the keyCode for space\n        keyJump = true;\n    } else if (keyCode === SHIFT) {\n        hero.running = true;\n    } else if (keyCode === LEFT) {\n        keyLeft = true;\n    } else if (keyCode === RIGHT) {\n        keyRight = true;\n    }\n};\nvar keyReleased = function() {\n    if (keyCode === 32) {\n        keyJump = false;\n    } else if (keyCode === SHIFT) {\n        hero.running = false;\n    } else if (keyCode === LEFT) {\n        keyLeft = false;\n    } else if (keyCode === RIGHT) {\n        keyRight = false;\n    }\n};\n\n// hero update stuff\n// -----------------\nvar maxHeroSpeed = function() {\n    if (hero.running) {\n        return 15;\n    } else {\n        return 9;\n    }\n};\n\nvar updateHeroXVelocity = function() {\n    if (keyRight) {\n        if (hero.xVelocity < 0) {\n            hero.xVelocity = 0;\n        }\n        hero.xVelocity += 1;\n    } else if (keyLeft) {\n        if (hero.xVelocity > 0) {\n            hero.xVelocity = 0;\n        }\n        hero.xVelocity -= 1;\n    } else {\n        if (hero.xVelocity > 0) {\n            hero.xVelocity -= 0.5;\n        } else if (hero.xVelocity < 0) {\n            hero.xVelocity += 0.5;\n        }\n    }\n\n    if (hero.xVelocity > maxHeroSpeed()) {\n        hero.xVelocity = 9;\n    } else if (hero.xVelocity < -maxHeroSpeed()) {\n        hero.xVelocity = -9;\n    }\n};\n\nvar updateHeroYVelocity = function() {\n    if (keyJump) {\n        if (hero.yVelocity === 0 && tileAdjIsBlocking(hero, \"below\", 2)) {\n            hero.jump = 1;\n        }\n            \n        if (hero.jump > 0 && hero.jump < 10) {\n            hero.jump += 1;\n            hero.yVelocity -= 6;\n        }\n    }\n\n    if (!keyJump || hero.jump >= 10) {\n        hero.jump = 0;\n    }\n    \n    if (hero.yVelocity < -18) { // max jump speed\n        hero.yVelocity = -18;\n    } else if (hero.yVelocity > 30) { // terminal velocity\n        // (this is as fast as you can ever fall)\n        hero.yVelocity = 30;\n    }\n};\n\nvar killHero = function() {\n    hero.yVelocity -= 100;\n    hero.dead = true;\n};\n\nvar woundHero = function() {\n    hero.wounded = true;\n    hero.lastWounded = t;\n    \n    if (hero.power !== \"none\") {\n        hero.power = \"none\";\n    } else {\n        killHero();\n    }\n};\n\nvar checkEnemyCollisions = function() {\n    // this is intentionally under hero stuff,\n    // because it\'s centered around the hero\n    // (I guess it\'s arguable)\n    if (hero.wounded) {\n        return;\n    }\n    \n    for (var i = 0; i < enemies.length; i += 1) {\n        if (dudeIntersectsDude(hero, enemies[i])) {\n            if (hero.yVelocity > 0) {\n                // enemy\'s being jumped on\n                hero.yVelocity -= 30;\n                enemies.splice(i, 1);\n            } else {\n                // enemy hit us!\n                woundHero();\n            }\n        }\n    }    \n};\n\nvar updateHero = function() {\n    updateHeroXVelocity();\n    updateHeroYVelocity();\n    \n    hero.yVelocity += GRAVITY;\n    \n    hero.x += hero.xVelocity;\n    hero.y += hero.yVelocity;\n\n    checkXCollisions(hero);\n    checkYCollisions(hero);\n    \n    checkEnemyCollisions();\n};\n\nvar scroll = function() {\n    if ((hero.x + scrollX > width / 2 && hero.xVelocity > 0) ||\n        (hero.x + scrollX < width / 2 && hero.xVelocity < 0)) {\n        scrollX -= floor(hero.xVelocity);\n    }\n\n    if ((hero.y + scrollY > height / 2 && hero.yVelocity > 0) ||\n        (hero.y + scrollY < height / 2 && hero.yVelocity < 0)) {\n        //scrollY -= floor(hero.yVelocity);\n    }\n};\n\n// enemy update\n// ------------\nvar updateEnemies = function() {\n    var enemy;\n    for (var i = 0; i < enemies.length; i += 1) {\n        enemy = enemies[i];\n\n        enemy.yVelocity += GRAVITY;\n        \n        enemy.x += enemy.xVelocity;\n        enemy.y += enemy.yVelocity;\n\n        checkXCollisions(enemy);\n        checkYCollisions(enemy);\n    }\n};\n\n// game-wide updates\n// -----------------\nvar update = function() {\n    updateHero();\n    updateEnemies();\n\n    scroll();\n};\n\nvar drawDebugInfo = function(scaleFactor) {\n    // TODO make this function clean\n    // (it was never intended to be permanent)\n    \n    // draw a minimap of everything at 1/10 scale\n    // draw the whole tilemap\n    noStroke();\n    fill(255, 255, 255);\n    rect(0, 0, TILE_MAP_COLS*TILE_WIDTH*scaleFactor, TILE_MAP_ROWS*TILE_HEIGHT*scaleFactor);\n    \n    for (var tY = 0; tY < TILE_MAP_ROWS; tY += 1) {\n        for (var tX = 0; tX < TILE_MAP_COLS; tX += 1) {\n            if (tileFor(tX, tY) !== 0) {\n                fill(0, 0, 0);\n                rect(tX*TILE_WIDTH*scaleFactor, tY*TILE_HEIGHT*scaleFactor, TILE_WIDTH*scaleFactor, TILE_HEIGHT*scaleFactor);\n            }\n        }\n    }\n    \n    fill(0, 0, 255);\n    rect(hero.x*scaleFactor, hero.y*scaleFactor, TILE_WIDTH*scaleFactor, TILE_HEIGHT*scaleFactor);\n    \n    fill(255, 0, 0);\n    for (var i = 0; i < enemies.length; i += 1) {\n        rect(enemies[i].x*scaleFactor, enemies[i].y*scaleFactor, TILE_WIDTH*scaleFactor, TILE_HEIGHT*scaleFactor);\n    }\n    \n    // draw the onscreen part\n    noFill();\n    stroke(0, 0, 255);\n    rect(-scrollX*scaleFactor, -scrollY*scaleFactor, SCREEN_COLS*TILE_WIDTH*scaleFactor, SCREEN_ROWS*TILE_HEIGHT*scaleFactor);\n};\n\nvar timer = function() {\n    if (hero.wounded && t - hero.lastWounded > 60) {\n        hero.wounded = false;\n    }\n    t += 1;\n};\n\nvar draw = function() {\n    update();\n    \n    drawBackground();\n    drawMapBelowHero();\n    drawEnemies();\n    drawDude(hero);\n    drawMapAboveHero();\n    \n    drawDebugInfo(1/10);\n\n    timer();\n};\n";
window.liveEditor = new LiveEditor({
                el: $("#sample-live-editor"),
                code: code,
                width: 400,
                height: 400,
                editorHeight: "80%",
                autoFocus: true,
                workersDir: "../../build/workers/",
                externalsDir: "../../build/external/",
                imagesDir: "../../build/images/",
                soundsDir: "../../sounds/",
                execFile: outputUrl,
                jshintFile: "../../build/external/jshint/jshint.js",
                newErrorExperience: true,
            });
            liveEditor.editor.on("change", function() {
                window.localStorage["test-code"] = liveEditor.editor.text();
            });
            ScratchpadAutosuggest.init(liveEditor.editor.editor);
            </script>
        </body>
        </html>
        