/****************************************************
 * Click and drag shape to move it.
 * Click a shape to select and bring up the edit menu.
 * Click and drag the bounding box to scale the shape.
 * 
 * TODO:
 *  Functions
 *      Tooltip bar
 *      Change cursor
 *      Box cursors to show we can scale/rotate
 *      Rotate
 *      Move to front/back
 *      Controls for opacity
 *      Confirm delete shape
 *      Undo/Redo
 *      Control to change background
 *      Selected number of sides and side length for new shapes
 *      Snap and align
 *      Multi-select shapes
 *      Zoom in and out
 * 
 * Fixes
 *      Dragging control point of non-face doesn't work
 *      Clicking off swatch should not close toolbar
 *      Clicking to add point doesn't work if another shape on top 
 *      Show current colour on swatch with circle

 * Improvements
 *      Move brightness control onto swatch
 *      Move mode to canvas
 *      Only test for dragging in the draw loop
 *      Use consistent naming for coordinate (obj vs arr)
 * 
*****************************************************/

// Add saved shapes here
var shapes = [
	{p:[[208,58],[433,54],[460,232],[377.2,273.1],[316,357.5],[263,268],[192,224]],r:5,f:-10499940,s:-12950490,sw:4,name:'face'},
	{p:[[252,124],[225,150],[315,150]],f:-3664381,s:-16777216,name:'eye1'},
	{p:[[400,122],[328,149],[423,149]],f:-3666427,s:-16777216,name:'eye2'}
];

// Standard colours and variables
var BACKGROUND = color(250, 250, 250);
var WARN_COLOR = color(200, 0, 0);
var CONTROL_ARMS = color(10, 10, 10, 120);

var WHITE = color(255, 255, 255);
var BLUE = color(64, 95, 237);
var PINK = color(255, 0, 175);
var GREEN = color(28, 173, 123);
var ORANGE = color(255, 165, 0);
var TEXTCOL = color(20, 20, 20);
var TOOLBAR = color(230, 230, 230, 200);

var sansFont = createFont("sans", 14);
var serifFont = createFont("serif", 16);

strokeJoin(ROUND);
var POINT_SIZE = 12;
var POINT_SIZE2 = POINT_SIZE * POINT_SIZE;

var toolbars;
var showing = {};

var shortcuts = {
    '1': 'Shape',
    '2': 'Rotate',
    '3': 'Points',
    '4': 'Color',
};

/*****************************************************
 *  General functions
******************************************************/

var callForEach = function(arr, func) {
    for (var i = 0, len = arr.length; i < len; i++) {
        arr[i][func]();
    }
};

var removeFromArray = function(arr, element) {
    var index = arr.indexOf(element);
    if (index > -1) {
        arr.splice(index, 1);
    }
};

var swatch;
var createSwatch = function(n, brightness) {
    loadPixels();
    var px = imageData.data;
    
    var ni = 1 / n;
    var x, y, h, s, r, g, b, i, f, p, q, t;
    var index;
    
    //var s = 0.5;          // Saturation
    var v = brightness;     // Brightness
    
    for (x = 0; x < n; x++) {
        h = ni * x;     // Hue along x-axis
        for (y = 0; y < n; y++) {
            s = ni * y; // Saturation along y-axis
            //v = ni * y; // Brightness along y-axis
            i = floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            index = x + (y * width) << 2;
            px[index++] = r * 0xFF | 0;
            px[index++] = g * 0xFF | 0;
            px[index++] = b * 0xFF | 0;
        }
    }
    updatePixels();
    return get(0, 0, n, n);
};

/*****************************************************
 *      GUI
******************************************************/
{
/****************************************************
 * Generic GUI component from which other elements
 * inherit
 * The default object is basically a button
*****************************************************/
{
var GUI_Component = function(x, y, w, h, name, updateFunction) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.name = name;
    
    if (updateFunction) {
        this.trigger = updateFunction.bind(this);
    }
    
    this.selected = false;
    this.disabled = false;
    this.transition = 0;
};

GUI_Component.prototype.draw = function() {
    var y = this.y + this.h;
    fill(20);
    stroke(20);
    strokeWeight(2);
    if (this.mouseOver()) {
        line(this.x + 5, y, this.x + this.w - 5, y);
    }
    
    textFont(sansFont, 14);
    textAlign(CENTER, BASELINE);
    text(this.name, this.x + this.w / 2, y - 2);
};

GUI_Component.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h);
};

GUI_Component.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
    return this.selected;
};

GUI_Component.prototype.mouseDragged = function() {};

GUI_Component.prototype.mouseReleased = function() {
    if (this.selected && !this.disabled && this.mouseOver()) {
        this.trigger();
    }
    this.selected = false;
};

GUI_Component.prototype.trigger = function() {
    // To be over-written
};

GUI_Component.prototype.fade = function() {
    if (this.selected || this.mouseOver()) {
        this.transition = min(10, this.transition + 1);
    } else {
        this.transition = max(0, this.transition - 1);
    }
};
}
/****************************************************
 *  GUI Button
*****************************************************/
{
var Button = function(x, y, w, h, params) {
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    
    this.textCol = params.textCol || color(20);
    this.defaultCol = color(230, 230, 230, 200);
    this.highlightCol = params.highlightCol || color(210, 210, 210, 250);
    this.disabledFunc = params.disabledFunc;
    
    this.tx = x + w * 0.5;
    this.ty = y + h * 0.5 + 1;
    this.stroke = params.stroke || color(200);
    
    if (params.filled) {
        this.highlightCol = params.filled;
        this.stroke = params.filled;
        this.defaultCol = color(0, 0, 0, 1);
        
        Object.defineProperty(this, 'textCol', {
            get: function() {
                return lerpColor(this.highlightCol, WHITE, this.transition * 0.1);
            }
        });
    }
};
Button.prototype = Object.create(GUI_Component.prototype);

Button.prototype.draw = function() {
    this.fade();
    this.disabled = this.disabledFunc && this.disabledFunc();
    
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition * 0.1));
        strokeWeight(1);
        stroke(200);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 19);
    
    fill(this.disabled ? 120 : this.textCol);
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.tx, this.ty);
};

}   // Button
{
var CheckBox = function(x, y, w, h, name) {
    Button.call(this, x, y, w, h, { name: name });
    this.box = this.h - 6;
    this.bx = this.x + 5;
    this.by = this.y + 3;
};
CheckBox.prototype = Object.create(Button.prototype);

CheckBox.prototype.trigger = function() {
    showing[this.name] = !showing[this.name];  
};

CheckBox.prototype.draw = function() {
    this.fade();
    
    if (this.transition) {
        noStroke();
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        rect(this.x, this.y, this.w, this.h + 1, 4);
    }
    
    fill(20);
    textFont(sansFont, 13);
    textAlign(LEFT, CENTER);
    text(this.name, this.x + this.box + 9, this.y + this.h/2 + 1);
    
    noFill();
    stroke(10);
    strokeWeight(1);
    rect(this.bx, this.y + 3, this.box, this.box);

    if (showing[this.name]) {
        line(this.bx + 1, this.by + 1, this.bx + this.box, this.by + this.box);
        line(this.bx + this.box, this.by + 1, this.bx + 1, this.by + this.box);
    }
};
}   // Checkbox
{
var RadioButton = function(x, y, w, h, name, trigger) {
    Button.call(this, x, y, w, h, {name: name, trigger: trigger});
    this.r = this.h - 6;
    this.cx = this.x + this.r / 2 + 5;
    this.cy = this.y + this.h / 2;
    this.marked = false;
};
RadioButton.prototype = Object.create(Button.prototype);

RadioButton.prototype.draw = function() {
    this.fade();
    
    if (this.transition) {
        noStroke();
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        rect(this.x, this.y, this.w, this.h + 1, 4);
    }
    
    fill(10);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    text(this.name, this.cx + this.r /2 + 4, this.cy + 1);
    
    noFill();
    stroke(10);
    strokeWeight(1);
    ellipse(this.cx, this.cy, this.r, this.r);
    
    if (this.marked) {
        fill(10);
        ellipse(this.cx, this.cy, this.r / 2, this.r / 2);
    }
};
}   // Radio button
{
var Swatch = function(x, y, w, h, params) {
    params.trigger = function() {
        this.showSwatch = !this.showSwatch;
    };
    
    Button.call(this, x, y, w, h, params);
    
    this.setValue(params.color || color(255, 0, 0));

    this.defaultCol = color(250);
    this.updateFunction = params.update;
    
    if (this.updateFunction) { this.updateFunction(); }
    
    this.size = 128;
    this.showSwatch = false;
    this.sx = this.x + this.w + 20;
    this.sy = min(this.y - 4, height - this.size - 28);
    this.sx2 = this.sx + this.size;
    this.sy2 = this.sy + this.size;
};
Swatch.prototype = Object.create(Button.prototype);

Swatch.prototype.draw = function() {
    this.fade();
    
    fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
    noStroke();
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 8);
    
    var my = this.y + this.h / 2;
    
    fill(20);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    var txt = this.name + ":";
    text(txt, this.x + 5, my + 1);
    
    strokeWeight(1);
    stroke(20);
    fill(this.value);
    rect(this.x + textWidth(txt) + 10, my - 8, 16, 16);
    
    // TODO: make a swatch object
    if (this.showSwatch) {
        // Shadow
        noStroke();
        fill(0, 0, 0, 50);
        rect(this.sx + 2, this.sy + 2, this.size + 2, this.size + 29);
        fill(0);
        //rect(this.sx, this.sy, SWATCHSIZE, SWATCHSIZE + 30);
        image(swatch, this.sx, this.sy);
        
        // Overlay with shade for brightness
        fill(0, 0, 0, 255 - this.bri * 255);
        rect(this.sx, this.sy, this.size, this.size);

        noFill();
        strokeWeight(1);
        stroke(255);
        ellipse(this.sx + this.hue * this.size, this.sy + this.sat * this.size, 5, 5);
        
        strokeWeight(2);
        stroke(0);
        rect(this.sx - 1, this.sy - 1, this.size + 2, this.size + 2);
        
        if (this.mouseOverSwatch()) {
            colorMode(HSB);
            var hue = norm(mouseX, this.sx, this.sx2);
            var sat = norm(mouseY, this.sy, this.sy2);
            fill(hue * 255, sat * 255, this.bri * 255);
            rect(this.sx - 1, this.sy2 + 1, this.size + 2, 24);
            colorMode(RGB);
        } else {
            textAlign(CENTER, CENTER);
            fill(0);
            rect(this.sx - 1, this.sy2 + 1, this.size + 2, 24);
            fill(255);
            text("Pick a color", this.sx + this.size / 2, this.sy2 + 12);
        }
    }
};

// Set colour based on current HSB
Swatch.prototype.updateColor = function() {
    colorMode(HSB);
    this.value = color(this.hue * 255, this.sat * 255, this.bri * 255);
    colorMode(RGB);
    return this.value;
};

// Set colour using passed int value
Swatch.prototype.setValue = function(color) {
    this.value = color;
    this.hue = hue(this.value) / 255;
    this.sat = saturation(this.value) / 255;
    this.bri = brightness(this.value) / 255;
};

Swatch.prototype.findColor = function() {
    this.hue = norm(mouseX, this.sx, this.sx2);
    this.sat = norm(mouseY, this.sy, this.sy2);
};

Swatch.prototype.mouseOverSwatch = function() {
    return mouseX >= this.sx && mouseX <= this.sx2 &&
           mouseY >= this.sy && mouseY <= this.sy2;
};

Swatch.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h) ||
            (this.showSwatch && this.mouseOverSwatch());
};

Swatch.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
    
    if (!this.selected && this.showSwatch) {
        this.showSwatch = false;
    }

    return this.selected;
};

Swatch.prototype.mouseReleased = function() {
    if (this.showSwatch && this.mouseOverSwatch()) {
        this.findColor();
        this.updateColor();
        if (this.updateFunction) {
            this.updateFunction(this.value);
        }
    } else if (this.selected && this.mouseOver()) {
        this.trigger();
    } else {
        this.showSwatch = false;
    }
};
}   // Swatch
/****************************************************
 * GUI Slider
*****************************************************/
{
var Slider = function(x, y, w, h, params) {
    // Size of ball
    this.ballR = 12;
    this.ballD = this.ballR * 2;
    
    x += this.ballR;
    w -= this.ballR * 2;
    
    var h = this.ballD + (params.name ? 16 : 0);
    y += h - this.ballR;
    
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    
    this.x2 = x + w;
    this.fill = params.fill || color(240);
    this.stroke = params.stroke || color(180);
    
    this.min = params.min || 0;
    this.max = params.max === undefined ? 1 : params.max;
    this.value = params.now === undefined ? this.min : params.now;
    this.decimalPlaces = params.decimalPlaces === undefined ? 0 : params.decimalPlaces;
    this.setValue(this.value);
    this.trigger();
};
Slider.prototype = Object.create(GUI_Component.prototype);

Slider.prototype.draw = function() {
    if (this.name) {
        fill(20);
        textSize(13);
        textAlign(CENTER, BASELINE);
        text(this.name,  this.x + this.w / 2, this.y - 15);
        //text(this.name + ": " + this.value,  this.x + this.w / 2, this.y - 14);
    }
    
    this.fade();
    fill(lerpColor(color(this.fill), color(this.stroke), this.transition / 10));
    stroke(this.stroke);
    strokeWeight(3);
    line(this.x, this.y, this.x2, this.y);
    ellipse(this.bx, this.y, this.ballD, this.ballD);
    
    fill(20);
    textSize(12);
    textAlign(CENTER, CENTER);
    text("" + this.value, this.bx, this.y);
};

Slider.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.bx, this.y) < this.ballR;
};

Slider.prototype.mousePressed = function() {
    if (this.mouseOver()) {
        this.selected = true;
        return true;
    }
};

Slider.prototype.mouseDragged = function() {
    if (this.selected) {
        this.bx = constrain(mouseX, this.x, this.x2);
        var p = pow(10, this.decimalPlaces);
        this.value = round(map(this.bx, this.x, this.x2, this.min, this.max) * p) / p;
        this.trigger();
        return true;
    }
};

Slider.prototype.mouseReleased = function() {
    this.selected = false;
};

Slider.prototype.setValue = function(v) {
    this.value = constrain(v, this.min, this.max);
    this.bx = map(this.value, this.min, this.max, this.x, this.x2);
};
}
/*********************************************
 * GUI Label
**********************************************/
{
var Label = function(x, y, w, h, name, params) {
    this.x1 = x + 8;
    this.x2 = x + w - 8;
    this.y = y + h - 2;
    this.y2 = y + h / 2;
    this.name = name;
    
    this.fontSize = params.fontSize || 16;
    this.underline = !params.noUnderline;
    this.alignH = params.alignH || CENTER;
    this.alignV = params.alignV || CENTER;
    
    this.x = this.alignH === CENTER ? x + w / 2: this.x1;
};

Label.prototype.draw = function() {
    fill(20);
    textFont(sansFont, this.fontSize);
    textAlign(this.alignH, this.alignV);
    text(this.name, this.x, this.y2);
    
    if (this.underline) {
        strokeWeight(1);
        stroke(20);
        line(this.x1, this.y, this.x2, this.y);
    }
};
}
/*****************************************************
 *      Toolbar
 *  Like GUI but is displayed and has methods for adding
 * components like buttons and sliders.
******************************************************/
{
var Toolbar = function(x, y, w) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = 8;
    this.components = [];
    this.labels = [];
};

Toolbar.prototype.draw = function() {
    fill(250);
    strokeWeight(1);
    stroke(180);
    rect(this.x, this.y, this.w, this.h, 8);
   
    this.labels.forEach(function(p) { p.draw(); });
    this.components.forEach(function(p) { p.draw(); });
};

Toolbar.prototype.add = function(type, params) {
    params = params || {};
    var h = params.h || 20;
    var component = new type(this.x + 5, this.y + this.h, this.w - 10, h, params);
    this.components.push(component);
    this.h += component.h + 8;
    return component;
};

Toolbar.prototype.addLabel = function(name, params) {
    params = params || {};
    var h = params.h || 20;
    this.labels.push(new Label(this.x, this.y + this.h, this.w, h, name, params));
    this.h += h + 8;
};

Toolbar.prototype.addOptions = function(options) {
    var x = this.x + 3;
    var y = this.y + this.h + 2;
    var w = this.w - 6;
    var h = 22;
    
    for (var opt in options) {
        var button = new CheckBox(x, y, w, h, opt);
        this.components.push(button);
        y += h + 5;
        this.h += h + 5;
    }
    
    this.h += 2;
};

Toolbar.prototype.addRadioButtons = function(options, trigger, defaultOption) {
    var x = this.x + 3;
    var y = this.y + this.h + 2;
    var w = this.w - 6;
    var radioButtons = [];
    
    var triggerFunction = function() {
        if (!this.marked) {
            this.marked = true;
            
            // Deselected other buttons
            for (var i = 0; i < radioButtons.length; i++) {
                if (radioButtons[i] !== this) {
                    radioButtons[i].marked = false;
                }
            }
        }
        if (trigger) { trigger(this.name); }
    };
    
    for (var i = 0; i < options.length; i++) {
        var button = new RadioButton(x, y, w, 22, options[i], triggerFunction);
        radioButtons.push(button);
        y += 27;
        this.h += 27;
    }
    
    radioButtons[defaultOption || 0].trigger();
    
    this.components = this.components.concat(radioButtons);
    this.h += 2;
};

Toolbar.prototype.mousePressed = function() {
    // Check mouse is over a component
    for (var i = this.components.length; i--;) {
        if (this.components[i].mousePressed()) {
            this.active = this.components[i];
            return true;
        }
    }
    
    return mouseX > this.x && mouseX < this.x + this.w &&
           mouseY > this.y && mouseY < this.y + this.h;
};

Toolbar.prototype.mouseReleased = function() {
    callForEach(this.components, 'mouseReleased');
    this.active = false;
};

Toolbar.prototype.mouseDragged = function() {
    if (this.active) {
        this.active.mouseDragged();
    }
};
}
/*************************************************
 *      Tabbed Toolbar
**************************************************/
{
var TabbedToolbar = function(x, y, w, tabs, trigger) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = 24;
    
    this.tabX = x;
    this.toolbarWidth = w;
    this.toolbarX = x;
    
    this.toolbars = [];
    this.tabs = [];
    this.currentTab = -1;
    this.components = [];
    this.labels = [];
    
    this.trigger = function() {
        if (trigger) {
            var name = this.tabs[this.currentTab].name;
            trigger(name);
        }
    };
    
    if (tabs) {
        this.addTabs(tabs);
    }
};

TabbedToolbar.prototype = Object.create(Toolbar.prototype);

TabbedToolbar.prototype.draw = function() {
    // Background
    noStroke();
    fill(250);
    rect(this.x, this.y, this.w, this.h, 8);
    
    // Tab background
    fill(200);
    rect(this.x, this.y, this.w, 24, 8);
    rect(this.x, this.y + 12, this.w, 12);
    
    textFont(sansFont, 13);
    textAlign(LEFT, BASELINE);
    var tx = this.x;
    var ty = this.y + 22;
    
    // Draw tab
    if (this.currentTab !== -1) {
        var tab = this.tabs[this.currentTab];
        fill(250);
        noStroke();
        var x = max(this.x, tab.x - 1);
        rect(x, tab.y, tab.w + 1, 30, 6);
    }

    // Outline
    strokeWeight(1);
    stroke(180);
    noFill();
    rect(this.x, this.y, this.w, this.h, 8);

    this.components.forEach(function(p) { p.draw(); });
    this.labels.forEach(function(p) { p.draw(); });
};

TabbedToolbar.prototype.changeTab = function(n) {
    this.currentTab = n;
    this.components = this.tabs.concat(this.toolbars[n].components);
    this.labels = this.toolbars[n].labels;
    this.h = this.toolbars[n].h + 24;
    
};

TabbedToolbar.prototype.addTab = function(name) {
    textFont(sansFont, 14);
    var w = textWidth(name) + 10;
    var index = this.tabs.length;
    var self = this;
    
    this.tabs.push(
        new GUI_Component(this.tabX, this.y + 1, w, 18,
            name, function() {
                self.changeTab(index);
            }
        )
    );
    
    this.toolbars.push(
        new Toolbar(this.toolbarX, this.y + 24, this.toolbarWidth));
    this.tabX += w;
    
    // Stretch toolbar
    if (this.tabX - 5 > this.w) {
        this.w = this.tabX - 5;
        this.toolbarX = this.x + round((this.w - this.toolbarWidth) * 0.5);
        
        for (var i = 0; i < this.toolbars.length; i++) {
            this.toolbars[i].x = this.toolbarX;
        }
    }
};

TabbedToolbar.prototype.addTabs = function(names) {
    for (var i = 0; i < names.length; i++) {
        this.addTab(names[i]);
    }
    this.changeTab(0);
};

TabbedToolbar.prototype.addTo = function(name, element, params) {
    var index = -1;
    
    for (var i = 0; i < this.tabs.length; i++) {
        if (this.tabs[i].name === name) {
            index = i;
            break;
        }
    }
    
    if (index === -1) { return; }
    
    var toolbar = this.toolbars[index];
    var component = toolbar.add(element, params);
    
    // Make sure components are visible
    this.changeTab(0);
    
    return component;
};
}
}
/*****************************************************
 * DraggablePoint
 * A freely draggable point with a position and colour.
******************************************************/
{
var DraggablePoint = function(x, y, update) {
    this.x = x;
    this.y = y;
    this.update = update;
    this.color = ORANGE;
    this.animation = 0;
};

DraggablePoint.prototype.draw = function() {
    if (this.dragging || this.mouseOver()) {
        if (this.animation < 5) {
            this.animation++;
        }
    } else {
        this.animation = 0;
    }

    strokeWeight(1);
    stroke(BACKGROUND);
    if (this.selected) {
        fill(PINK);
    } else {
        fill(this.color);
    }
    
    var r = POINT_SIZE + this.animation;
    ellipse(this.x, this.y, r, r);
};

DraggablePoint.prototype.mouseOver = function() {
    return (mouseX - this.x) * (mouseX - this.x) + (mouseY - this.y) * (mouseY - this.y) <= POINT_SIZE2;
};
}
/*****************************************************
 *      Polygon
 * A collection of points, joined by control arms
 * A curve is drawn between the points using subdivsion.
******************************************************/
{
var Polygon = function(params) {
    // Add control points
    this.controlPoints = params.p.map(function(p) {
        return new DraggablePoint(p[0], p[1], this.updateShape.bind(this));
    }, this);
    
    // Handles for bounding box
    this.boxPoints = [
        new DraggablePoint(0, 0, this.updateScalePoint.bind(this)),
        new DraggablePoint(1, 0, this.updateScalePoint.bind(this)),
        new DraggablePoint(1, 1, this.updateScalePoint.bind(this)),
        new DraggablePoint(0, 1, this.updateScalePoint.bind(this))
    ];
    
    // Will be either controlPoints or boxPoints
    this.handles = [];
    
    this.selectedPoint = false;
    this.draggingPoint = false;
    this.addPointCoord = false;
    
    this.translateX = 0;
    this.translateY = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    
    this.resolution = params.r || 0;
    this.fill = params.f || GREEN;
    this.fillBrightness = brightness(this.fill);
    this.stroke = params.s || color(0);
    this.strokeBrightness = brightness(this.stroke);
    this.strokeWeight = params.sw || 0;
    
    this.name = params.name;
    this.updateShape();
};

Polygon.prototype.updateShape = function() {
    this.updateCurvePoints();
    this.findBoundingBox();
};

Polygon.prototype.updateScalePoint = function() {
    this.scaleX = this.draggingPoint.x / this.startX;
    this.scaleY = this.draggingPoint.y / this.startY;
    
    // Update bounding box
    if (this.draggingPoint.x > 0) {
        this.minX = 0;
        this.maxX = this.draggingPoint.x;
    } else {
        this.minX = this.draggingPoint.x;
        this.maxX = 0;
    }
    
    if (this.draggingPoint.y > 0) {
        this.maxY = this.draggingPoint.y;
    } else {
        this.minY = this.draggingPoint.y;
    }
    
    this.updateBoxPoints();
};

Polygon.prototype.updateBoxPoints = function() {
    // Compare diagonal points to see which way shape is flipped
    if (this.boxPoints[0].x < this.boxPoints[2].x) {
        this.boxPoints[0].x = this.minX;
        this.boxPoints[3].x = this.minX;
        this.boxPoints[1].x = this.maxX;
        this.boxPoints[2].x = this.maxX;
    } else {
        this.boxPoints[1].x = this.minX;
        this.boxPoints[2].x = this.minX;
        this.boxPoints[0].x = this.maxX;
        this.boxPoints[3].x = this.maxX;
    }
    
    if (this.boxPoints[0].y < this.boxPoints[2].y) {
        this.boxPoints[0].y = this.minY;
        this.boxPoints[1].y = this.minY;
        this.boxPoints[2].y = this.maxY;
        this.boxPoints[3].y = this.maxY;
    } else {
        this.boxPoints[3].y = this.minY;
        this.boxPoints[2].y = this.minY;
        this.boxPoints[1].y = this.maxY;
        this.boxPoints[0].y = this.maxY;
    }
    
    this.centerX = (this.minX + this.maxX) * 0.5;
    this.centerY = (this.minY + this.maxY) * 0.5;
};

Polygon.prototype.findBoundingBox = function() {
    var points = this.curvePoints;
    this.minX = points[0][0];
    this.minY = points[0][1];
    this.maxX = this.minX;
    this.maxY = this.minY;
    
    var p;
    for (var i = 1; i < points.length; i++) {
        p = points[i];
        
        if (p[0] < this.minX) { this.minX = p[0]; }
        else if (p[0] > this.maxX) { this.maxX = p[0]; }
        
        if (p[1] < this.minY) { this.minY = p[1]; }
        else if (p[1] > this.maxY) { this.maxY = p[1]; }
    }
    
    this.updateBoxPoints();
};

// Calculate the points for the subdivided curve
Polygon.prototype.updateCurvePoints = function() {
    this.curvePoints = [];
    var q = pow(2, this.resolution);
    var q2 = q * q;
    var n = this.controlPoints.length;
    var p1 = this.controlPoints[n - 2];
    var p2 = this.controlPoints[n - 1];
    var p3, a, b, c, s, t, x, y, i;
    
    for (i = 0; i < n; i++) {
        p3 = this.controlPoints[i];
        
        for (t = 0; t < q; t++) {
            s = q - t - 1;
            a = (s * s + s) * 0.5;
            c = (t * t + t) * 0.5;
            b = q2 - a - c;
            
            x = (p1.x * a + p2.x * b + p3.x * c) / q2;
            y = (p1.y * a + p2.y * b + p3.y * c) / q2;
            this.curvePoints.push([x, y]);
        }
        
        p1 = p2;
        p2 = p3;
    }
};

Polygon.prototype.drawSelected = function() {
    // Should be overwritten
    //println("No drawSelected mode for mode " + this.mode);
};

Polygon.prototype.setMode = function(mode) {
    this.mode = mode;
    if (mode === 'Points') {
        this.drawSelected = this.drawControlElements;
        this.handles = this.controlPoints;
    } else {
        this.drawSelected = this.drawSelectionBox;
        if (mode === 'Shape') {
            this.handles = this.boxPoints;
        } else {
            this.handles = [];
        }
    }
};

Polygon.prototype.draw = function() {
    pushMatrix();
    translate(this.translateX, this.translateY);
    scale(this.scaleX, this.scaleY);

    if (this.strokeWeight) {
        stroke(this.stroke);
        strokeWeight(this.strokeWeight);
    } else {
        noStroke();
    }

    fill(this.fill);
    beginShape();
    for (var i = this.curvePoints.length; i--;) {
        var p = this.curvePoints[i];
        vertex(p[0], p[1]);
    }
    endShape(CLOSE);
    
    popMatrix();
    
    this.addPointCoord = false;
};

Polygon.prototype.drawSelectionBox = function() {
    pushMatrix();
    translate(this.translateX, this.translateY);
    
    var x = this.minX;
    var y = this.minY;
    
    noFill();
    strokeWeight(1);
    stroke(CONTROL_ARMS);
    rect(x, y, this.maxX - x, this.maxY - y);
    
    // Center point
    var r = 10;
    var r2 = 0.5 * r + 3;
    var r3 = r2 + 6;
    var cx = this.centerX;
    var cy = this.centerY;
    ellipse(cx + 0.5, cy + 0.5, r, r);
    line(cx, cy - r2, cx, cy - r3);
    line(cx, cy + r2, cx, cy + r3);
    line(cx - r2, cy, cx - r3, cy);
    line(cx + r2, cy, cx + r3, cy);
    
    for (var i = this.handles.length; i--;) {
        this.handles[i].draw();
    }
    
    popMatrix();
};

Polygon.prototype.drawControlElements = function() {
    pushMatrix();
    translate(this.translateX, this.translateY);
    
    this.drawControlArms();
    this.drawControlPoints();
    
    if (!this.draggingPoint) {
        this.drawControlPointAddition();
    }
    
    popMatrix();
};

Polygon.prototype.drawControlArms = function() {
    stroke(CONTROL_ARMS);
    strokeWeight(1);
    var i, n = this.controlPoints.length;
    var p1, p2 = this.controlPoints[n - 1];
    
    for (i = 0; i < n; i++) {
        p1 = this.controlPoints[i];
        line(p1.x, p1.y, p2.x, p2.y);
        p2 = p1;
    }
};

Polygon.prototype.drawControlPoints = function() {
    for (var i = this.controlPoints.length; i--;) {
        this.controlPoints[i].draw();
    }
};

Polygon.prototype.drawControlPointAddition = function() {
    // Show point where a control point could be added
    
    var x = mouseX;
    var y = mouseY;
    var i, n = this.controlPoints.length;
    
    // Check whether mouse isn't too close to a control point
    for (i = n; i--;) {
        if (this.controlPoints[i].mouseOver()) {
            return;
        }
    }
    
    // Test whether mouse is within a certain distance from a control arm
    
    var p1, p2 = this.controlPoints[n - 1];
    var lx, ly, mx, my, w, px, py;
    
    for (i = 0; i < n; i++) {
        p1 = this.controlPoints[i];
        
        // Project (x, y) onto line p1 - p2
        lx = p1.x - p2.x;
        ly = p1.y - p2.y;
        mx = x - p2.x;
        my = y - p2.y;
        w = (mx * lx + my * ly ) / (lx * lx + ly * ly);
        
        if (w > 0 && w < 1) {
            px = p1.x * w + p2.x * (1 - w);
            py = p1.y * w + p2.y * (1 - w);
            
            // Check mouse is within 8 units of the line
            if ((px - x) * (px - x) + (py - y) * (py - y) <= 64) {
                this.addPointCoord = {
                    x: px, y: py, index: i
                };
                
                stroke(PINK);
                strokeWeight(2);
                fill(PINK + (180 << 24));
                ellipse(px, py, 16, 16);
                break;
            }
        }
        
        p2 = p1;
    }
    
};

Polygon.prototype.drawCurvePoints = function() {
    for (var i = 0; i < this.curvePoints.length; i++) {
        this.curvePoints[i].draw();
    }
};

Polygon.prototype.pointInside = function(x, y) {
    // Bounding box test
    if (x < this.minX || x > this.maxX ||
        y < this.minY || y > this.maxY) {
            return false;
    }
    
    var inside = false;
    var n = this.curvePoints.length;
    var p1, p2 = this.curvePoints[n - 1];
    for (var i = 0; i < n; i++) {
        p1 = this.curvePoints[i];
        
        if (((p1[1] > y) !== (p2[1] > y)) &&
             (x < (p2[0] - p1[0]) * (y - p1[1]) / (p2[1] - p1[1]) + p1[0])) {
           inside = !inside;
        }
        p2 = p1;
    }
    return inside;
};

Polygon.prototype.addPointAt = function(p) {
    var newPoint = new DraggablePoint(p.x, p.y);
    this.controlPoints.splice(p.index, 0, newPoint);
    this.updateCurvePoints();
};

Polygon.prototype.deletePoint = function() {
    if (this.selectedPoint !== false && this.controlPoints.length > 3) {
        this.controlPoints.splice(this.selectedPoint, 1);
        this.updateShape();
        this.selectedPoint = false;
    }
};

Polygon.prototype.getShapeAsString = function() {
    var s = "\t{p:[";
    
    for (var i = 0; i < this.controlPoints.length; i++) {
        var p = this.controlPoints[i];
        s += (i ? "," : "") + "[" + round(p.x * 10) / 10 + "," + (p.y * 10) / 10 + "]";
    }
    
    s += "]";
    
    if (this.resolution) {
        s += ",r:" + this.resolution;
    }
    
    s += ",f:" + this.fill;
    s += ",s:" + this.stroke;
    
    if (this.strokeWeight) {
        s += ",sw:" + this.strokeWeight;
    }
    
    s += "}";
    
    return s;
};

Polygon.prototype.exportShapeAsPJS = function() {
    var s = "";
    
    if (this.strokeWeight) {
        s += "strokeWeight(" + this.strokeWeight + ");\n";
        s += "stroke(" + red(this.stroke) + ", " + green(this.stroke) + ", " + blue(this.stroke) + ");\n";
    } else {
        s += "noStroke();\n";
    }
    
    s += "fill(" + red(this.fill) + ", " + green(this.fill) + ", " + blue(this.fill) + ");\n";
    s += "beginShape();\n";
    
    var oldX, oldY;
    for (var i = 0; i < this.curvePoints.length; i++) {
        var p = this.curvePoints[i];
        var x = round(p[0] * 10) / 10;
        var y = round(p[1] * 10) / 10;
        
        if (oldX !== x || oldY !== y) {
            s += "vertex(" + x + ","  + y + ");\n";
        }
        
        oldX = x;
        oldY = y;
    }
    s += "endShape(CLOSE);";
    return s;
};

Polygon.prototype.exportToSVG = function() {
    var s = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + width + ' ' + height + '">\n';

    var r = red(this.color);
    var g = green(this.color);
    var b = blue(this.color);
    var c = "rgb(" + r + ", " + g + ", " + b + ");";
    
    s += '\t<path style="stroke:' + c + 'stroke-width:3px;fill:' + c + ';fill-opacity:0.5" d="M';
    for (var i = 0; i < this.curvePoints.length; i++) {
        var p = this.curvePoints[i];
        var x = round(100 * p[0]) / 100;
        var y = round(100 * p[1]) / 100;
        s += x  + ","  + y + " ";
        if (!i) { s += "L"; }
    }
    s += 'z"/>\n</svg>';
    println(s);
};

Polygon.prototype.translate = function(dx, dy) {
    for (var i = this.curvePoints.length; i--;) {
        this.curvePoints[i][0] += dx;
        this.curvePoints[i][1] += dy;
    }
    
    for (var i = this.controlPoints.length; i--;) {
        this.controlPoints[i].x += dx;
        this.controlPoints[i].y += dy;
    }
    
    this.minX += dx;
    this.maxX += dx;
    this.minY += dy;
    this.maxY += dy;
    this.centerX += dx;
    this.centerY += dy;
    this.updateBoxPoints();
};

Polygon.prototype.scale = function(sx, sy) {
    for (var i = this.curvePoints.length; i--;) {
        this.curvePoints[i][0] *= sx;
        this.curvePoints[i][1] *= sy;
    }
    
    for (var i = this.controlPoints.length; i--;) {
        this.controlPoints[i].x *= sx;
        this.controlPoints[i].y *= sy;
    }

    this.updateShape();
};

Polygon.prototype.mouseOver = function() {
    return this.pointInside(mouseX, mouseY);
};

Polygon.prototype.mousePressed = function() {
    this.canAddPoint = this.addPointCoord;
    
    if (this.mode === 'Points') {
        for (var i = this.handles.length; i--;) {
            if (this.handles[i].mouseOver()) {
                this.draggingPoint = this.handles[i];
                this.draggingPoint.dragging = true;
                return true;
            }
        }
    } else {
        for (var i = this.handles.length; i--;) {
            if (this.handles[i].mouseOver()) {
                this.draggingPoint = this.handles[i];
                this.draggingPoint.dragging = true;
                
                // Scale using the opposite point as the origin
                var origin = this.boxPoints[(i + 2) % 4];
                this.translateX = origin.x;
                this.translateY = origin.y;
                this.translate(-origin.x, -origin.y);
                this.startX = this.draggingPoint.x;
                this.startY = this.draggingPoint.y;
                return true;
            }
        }
    }
};

Polygon.prototype.mouseDragged = function() {
    // Don't drag shape if we're going to add a point
    if (this.canAddPoint) { return; }
    
    var dx = mouseX - pmouseX;
    var dy = mouseY - pmouseY;
    
    if (this.draggingPoint) {
        this.draggingPoint.x += dx;
        this.draggingPoint.y += dy;
        this.draggingPoint.update();
    } else {
        this.translateX += dx;
        this.translateY += dy;
    }
};

Polygon.prototype.mouseReleased = function() {
    // Permenantly scale shape
    this.scale(this.scaleX, this.scaleY);
    this.scaleX = 1;
    this.scaleY = 1;
    
    // Permenantly translate shape
    this.translate(this.translateX, this.translateY);
    this.translateX = 0;
    this.translateY = 0;
    
    // Deselect dragged a point
    if (this.draggingPoint) {
        this.draggingPoint.dragging = false;
        this.draggingPoint = false;
    }
    
    // Test whether we have selected a control point
    this.selectedPoint = false;
    for (var i = 0; i < this.controlPoints.length; i++) {
        if (this.controlPoints[i].mouseOver()) {
            this.selectedPoint = i;
            this.controlPoints[i].selected = true;
        } else {
            this.controlPoints[i].selected = false;
        }
    }
    
    if (this.addPointCoord && this.canAddPoint) {
        this.addPointAt(this.addPointCoord);
    }
};
}
/*****************************************************
 *      TargetShape
 * Wrapper for the shape currently selected. Allows
 * the toolbars to target the correct shape easily.
******************************************************/

var TargetShape = {
    shape: null,
    toolbars: {},
    
    set: function(shape) {

        this.shape = shape;
        
        // Set values of toolbars to target shape's values
        for (var t in this.toolbars) {
            this.toolbars[t].setValue(shape[t]);
        }
    },
    
    setMode: function(mode) {
        if (this.shape) {
            this.shape.setMode(mode);
        }
    },
    
    // Set the property of the target shape equal to the toolbar value
    updateProperty: function(property) {
        var toolbar = this.toolbars[property];
        if (this.shape && toolbar) {
            this.shape[property] = toolbar.value;
        }
    }
};

/*****************************************************
 *      Canvas
 * Contains all the shapes and functions for dealing
 * with them
******************************************************/

var canvas = {
    shapes: [],
    selected: false,
    
    init: function(shapes) {
        for (var i = 0, n = shapes.length; i < n; i++) {
            this.addShape(shapes[i], true);
        }
    },
    
    draw: function() {
        // Draw shapes
        for (var i = 0; i < this.shapes.length; i++) {
            this.shapes[i].draw();
        }
        
        // Highlight selected shape
        if (this.selected) {
            this.selected.drawSelected();
        }
    },
    
    addShape: function(shapeData, initialShapes) {
        if (!shapeData) {
            shapeData = {
                p: [[360,150],[260,300],[460,300]]
            };
        }
        
        if (shapeData.p && shapeData.p.length > 2) {
            var polygon = new Polygon(shapeData);
            this.shapes.push(polygon);
            if (!initialShapes) {
                this.selectShape(polygon);
                return polygon;
            }
        }
    },
    
    copyShape: function(shape) {
        this.clipboard = {
            r: shape.resolution,
            f: shape.fill,
            s: shape.stroke,
            sw: shape.strokeWeight,
        };
        
        this.clipboard.p = shape.controlPoints.map(
            function(p) { return [p.x, p.y]; }
        );
    },
    
    pasteShape: function() {
        if (this.clipboard) {
            var shape = this.addShape(this.clipboard);
            shape.translate(10, 10);
        }
    },
    
    moveShapeZ: function(shape, dir) {
        var index = this.shapes.indexOf(shape);
        if (index > -1) {
            index += dir;
            if (index > -1 && index < this.shapes.length) {
                this.shapes[index - dir] = this.shapes[index];
                this.shapes[index] = shape;
            }
        }
    },
    
    deleteShape: function(shape) {
        removeFromArray(this.shapes, shape);
        this.deselectShape();
    },
    
    getShapeAtPoint: function(x, y) {
        // Go in reverse order to select top shape first
        for (var i = this.shapes.length; i--;) {
            if (this.shapes[i].canAddPoint ||
                this.shapes[i].pointInside(x, y)) {
                return this.shapes[i];
            }
        }
    },
    
    selectShape: function(shape) {
        if (toolbars && this.selected !== shape) {
            this.selected = shape;
            TargetShape.set(shape);
            toolbars.showToolbar('shape');
        }
    },
    
    deselectShape: function() {
        this.selected = false;
        toolbars.hideToolbar('shape');
    },
    
    saveShapeCode: function() {
        // Save shapes in a form that can be pasted at the top of this curve
        
        var s = "var shapes = [\n";
        var n = this.shapes.length;
        
        for (var i = 0; i < n; i++) {
            s += this.shapes[i].getShapeAsString();
            s += (i < n - 1) ? ",\n" : "\n";
        }
        
        s += "];";
        
        println(s);
    },
    
    exportShapesAsPJS: function() {
        // Save shapes in a form that can be pasted at the top of this curve
        
        var s = "";
        var n = this.shapes.length;
        
        for (var i = 0; i < n; i++) {
            s += this.shapes[i].exportShapeAsPJS();
            s += (i < n - 1) ? "\n" : "";
        }
        
        println(s);
    },
    
    mousePressed: function() {
        // If a shape if already and we select one of its control points, quit now.
        if (this.selected && this.selected.mousePressed()) {
            return;
        }
        
        // Otherwise test for hitting a new shape
        var selected = this.getShapeAtPoint(mouseX, mouseY);
        if (selected) {
            this.selectShape(selected);
            selected.mousePressed();
        } else {
            this.deselectShape();
        }
    },
    
    mouseDragged: function() {
        if (this.selected) {
            this.selected.mouseDragged();
        }
    },
    
    mouseReleased: function() {
        if (this.selected) {
            this.selected.mouseReleased();
        }
    }
};

/**************************************
 * Object to handle multiple toolbars
***************************************/

toolbars = {
    units: {},
    showing: [],
    
    init: function() {
        // Main toolbar
        var mainToolbar = new Toolbar(5, 5, 120);
        mainToolbar.add(Button, {
            name: "Add shape",
            trigger: canvas.addShape.bind(canvas),
        });
        mainToolbar.add(Button, {
            name: "Save canvas",
            trigger: canvas.saveShapeCode.bind(canvas),
        });
        mainToolbar.add(Button, {
            name: "Export as PJS",
            trigger: canvas.exportShapesAsPJS.bind(canvas),
        });
        mainToolbar.add(Button, {
            name: "Restart",
            filled: WARN_COLOR,
            trigger: function() { Program.restart(); },
        });
        this.units.main = mainToolbar;
        
        // Shape toolbar
        // TODO: auto position this?
        var shapeToolbar = new TabbedToolbar(
            5, height - 235, 120,
            ["Shape", "Points", "Color"],
            function(mode) {
                TargetShape.setMode(mode);
            }
        );
        
        // Map shape property to toolbar that controls it
        var toolbars = TargetShape.toolbars;
       
        toolbars.resolution = shapeToolbar.addTo('Shape', Slider, {
            max: 5,
            name: "Subdivisions",
            trigger: function() {
                var target = TargetShape.shape;
                if (target && target.resolution !== this.value) {
                    target.resolution = this.value;
                    target.updateCurvePoints();
                }
            }
        });
        
        shapeToolbar.addTo('Shape', Button, {
            name: "Move down",
            trigger: function() {
                canvas.moveShapeZ(TargetShape.shape, -1);
            },
            disabledFunc: function() {
                return canvas.shapes.indexOf(TargetShape.shape) === 0;
            }
        });
        shapeToolbar.addTo('Shape', Button, {
            name: "Move up",
            trigger: function() {
                canvas.moveShapeZ(TargetShape.shape, 1);
            },
            disabledFunc: function() {
                return canvas.shapes.indexOf(TargetShape.shape) === canvas.shapes.length - 1;
            }
        });
        shapeToolbar.addTo('Shape', Button, {
            name: "Copy Shape",
            trigger: function() {
                canvas.copyShape(TargetShape.shape);
            },
        });
        shapeToolbar.addTo('Shape', Button, {
            name: "Paste Shape",
            trigger: function() {
                canvas.pasteShape();
            },
        });
        shapeToolbar.addTo('Shape', Button, {
            name: "Delete Shape",
            filled: WARN_COLOR,
            trigger: function() {
                canvas.deleteShape(TargetShape.shape);
            },
        });
        
        shapeToolbar.addTo('Points', Button, {
            name: "Delete Point",
            filled: WARN_COLOR,
            trigger: function() {
                TargetShape.shape.deletePoint();
            },
            disabledFunc: function() {
                return !TargetShape.shape.selectedPoint;
            }
        });
        
        toolbars.strokeWeight = shapeToolbar.addTo('Color', Slider, {
            max: 20,
            name: "Stroke weight",
            trigger: function() {
                TargetShape.updateProperty('strokeWeight');
            }
        });
        toolbars.stroke = shapeToolbar.addTo('Color', Swatch, {
            name: "Stroke",
            color: color(100, 100, 100),
            update: function() {
                TargetShape.updateProperty('stroke');
            }
        });
        toolbars.strokeBrightness = shapeToolbar.addTo('Color', Slider, {
            name: "Stroke brightness",
            max: 255,
            trigger: function() {
                toolbars.stroke.bri = this.value / 255;
                toolbars.stroke.updateColor();
                TargetShape.updateProperty('stroke');
            }
        }); 
        
        toolbars.fill = shapeToolbar.addTo('Color', Swatch, {
            name: "Fill",
            color: color(200, 0, 0),
            update: function() {
                TargetShape.updateProperty('fill');
            }
        });
        toolbars.fillBrightness = shapeToolbar.addTo('Color', Slider, {
            name: "Fill brightness",
            max: 255,
            trigger: function() {
                toolbars.fill.bri = this.value / 255;
                toolbars.fill.updateColor();
                TargetShape.updateProperty('fill');
            }
        });
        
        this.units.shape = shapeToolbar;
        
        this.showing = [ this.units.main ];
    },
    
    draw: function() {
        for (var i = this.showing.length; i--;) {
            this.showing[i].draw();
        }
    },
    
    showToolbar: function(toolbarName) {
        var toolbar = this.units[toolbarName];
        
        if (toolbar) {
            // Add toolbar if it's not showing
            if (this.showing.indexOf(toolbar) === -1) {
                this.showing.push(toolbar);
            }
            
            toolbar.trigger();
        } else {
            println('No toolbar called ' + toolbarName);
        }
    },
    
    hideToolbar: function(toolbarName) {
        var toolbar = this.units[toolbarName];
        
        if (toolbar) {
            removeFromArray(this.showing, toolbar);
        } else {
            println('No toolbar called ' + toolbarName);
        }
    },
    
    mousePressed: function() {
        for (var i = this.showing.length; i--;) {
            if (this.showing[i].mousePressed()) {
                this.active = this.showing[i];
                return true;
            }
        }
    },
    
    mouseDragged: function() {
        if (this.active) {
            this.active.mouseDragged();
        }
    },
    
    mouseReleased: function() {
        if (this.active) {
            this.active.mouseReleased();
            this.active = false;
        }
    }
};

/**************************************
 *      Initialisation
***************************************/

toolbars.init();
canvas.init(shapes);

/**************************************
 *      Main loop
***************************************/

draw = function() {
    if (!swatch) { swatch = createSwatch(128, 1); }
    background(BACKGROUND);
    canvas.draw();
    toolbars.draw();
};

/**************************************
 *      Event handling
***************************************/
{
mousePressed = function() {
    if (!toolbars.mousePressed()) {
        canvas.mousePressed();
    }
};

mouseDragged = function() {
    if (toolbars.active) {
        toolbars.mouseDragged();
    } else {
        canvas.mouseDragged();
    }
};

mouseReleased = function() {
    if (toolbars.active) {
        toolbars.mouseReleased();
    } else {
        canvas.mouseReleased();
    }
};

keyPressed = function() {
    var k = key.toString();
    if (shortcuts[k]) {
        TargetShape.setMode(shortcuts[k]);
    }
};
}
