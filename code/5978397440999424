/******************************************************
 *       HOW TO PLAY
 * The game simulates a simple commandline interface.
 * Navigate by typing commands, then pressing enter.
 * The aim is to access the system/security folder
 * 
 * NOTE: This can be considered a beta release.
 * I suspect there are still a number of bugs,
 * and there are couple of aspects that I might
 * tweak, but it should work for the most part.
 * 
 *      TIPS
 * Click and drag the screen to scroll.
 * After logging in:
 *  Type help to get some suggestions.
 *  Type cmd to get a list of possible commands.
 *  Use alt to autocomplete file and folder names.
 *  Use the up and down arrows to browse a user's command history.
 *  Use Ctrl + X to quit programs
 *  Read .exe files to find out what they do.
 *  Clearance is shown as read/write/execute.
 * 
 * This is an update of my Hacker puzzle, of which it
 * is a spin off. It has a lot more functionality and
 * is better coded. More importantly, it has a second,
 * much more tricky level. Maybe I can even add a third
 * level within the next year.
 * 
 * To Do:
 *  Improve Text Editor save y/n
 *  Give exes clearance levels
 *  Allow programs to be run with parameters 
 *  Move input strings to Envs
 *  Connection program
 *  Scroll bar
 *  Secret bonus tasks
 *  Storyline elements
 *
 *  Piping
 *  Improve parsing of > in commands
 *  Alias, sudo, chmod, rm
 *  Allow commands separated by ;
 *  .bashrc
********************************************************/

/*****************************************************
 *  Functions for generating the world
******************************************************/

var randFromArray = function(arr) {
    return arr[floor(random() * arr.length)];
};

var clearanceNames = ['guest', 'user', 'admin', 'trusted', 'secure', 'special', 'secret']; 

/*****************************************************
 *  Keep track of what tasks the users has completed
******************************************************/

var taskManager = function() {
    this.count = 0;
    this.tasks = {};
    this.animation = 0;
    this.animationMax = 40;
};

taskManager.prototype.draw = function() {
    var tx = 8;
    var ty = height - 8;
    var txt = "Progress: ";

    textAlign(LEFT, BASELINE);
    textSize(13);
    fill(0);
    text(txt, tx, ty);
    
    tx += textWidth(txt);
    txt = this.count;
    text(txt, tx, ty);
    tx += textWidth(txt) / 2;
    
    if (this.animation > 0) {
        var d = (this.animationMax - this.animation);
        pushStyle();
        fill(0, 200, 0, 255 * this.animation / this.animationMax);
        textSize(13 + 0.5 * d);
        textAlign(CENTER, BASELINE);
        text("+1", tx, ty - d * 2);
        popStyle();
        this.animation--;
    }
};

taskManager.prototype.add = function(task) {
    if (!this.tasks[task]) {
        this.tasks[task] = true;
        this.count++;
        this.animation = this.animationMax;
    }
};

var tasks = new taskManager();

/*****************************************************
 *  Generic File object
 * Text files have canRead = true
 * Program files have canRun = true
******************************************************/

var File = function(name, clearance, parent, data, task) {
    this.name = name;
    this.clearance = clearance || [0, 0, 0];
    this.parent = parent;
    this.data = data || [];
    this.task = task;
    
    var txt = name.split(".");
    var n = txt.length;

    if (n > 0) {
        if (!txt[0]) {
            this.hidden = true;
            n--;
        }
        if (n > 0) {
            this.ext = txt[n - 1];
        }
    } else {
        this.ext = 'none';
    }

    this.canRead = true;
    
    if (this.ext === 'exe') {
        this.canRun = true;
        this.script = this.data;
        this.script.parent = this.parent;
        this.data = this.script.description;
    }
};

File.prototype.getPath = function() {
    return this.parent.getPath() + "/" + this.name;
};

/*******************************************************
 *  Generic Folder object
 * Contains other files and folders
********************************************************/
var Folder = function(name, clearance, parent) {
    this.name = name;
    this.clearance = clearance;
    this.parent = parent;
    this.folders = {};
    this.files = {};
};

Folder.prototype.getPath = function() {
    if (this.parent) {
        return this.parent.getPath() + "/" + this.name;
    } else {
        return "";
    }
};

Folder.prototype.getFromPath = function(pathElements, clearance) {
    if (clearance !== undefined && this.clearance[0] > clearance) {
        return [false, "PermissionError", this.name + ": you do not have read permission"];
    }
    
    if (pathElements.length === 0) {
        return [true, this];
    }

    var firstElement = pathElements.splice(0, 1)[0];
    
    if (firstElement === '..') {
        if (this.parent) {
            return this.parent.getFromPath(pathElements, clearance);

        } else {
            return [false, 'PathError', "Already at root"];
        }
    }
    
    var folder = this.folders[firstElement];
    if (folder) {
        return folder.getFromPath(pathElements, clearance);
    }
    
    var file = this.files[firstElement];
    var path  = this.getPath() + "/" + firstElement;
    if (file) {
        if (pathElements.length === 0) {
            return [true, file];
        } else {
            return [false, 'PathError', path + ': Not a folder'];
        }
    } else {
        return [false, 'PathError', path + ': Not a file or folder'];
    }
};

/*****************************************************
 *      Environment object
 * Environments are programs that run on the
 * operating system.
 * They parse and respond to inputs,
 * and generate outputs.
 * 
 * Functions that don't start with an underscore
 * can be called via the terminal.
******************************************************/
var Environment = function(os) {
    this.os = os;
    this.helpString = ["Type a command and press enter."];
    this.prompt = "> ";
};

Environment.prototype._drawCursor = function(x, y) {
    // Current input string
    
    var s1, s2;
    if (this.hideInput) {
        s1 = Array(this.os.inputBefore.length + 1).join("*");
        s2 = Array(this.os.inputAfter.length + 1).join("*");
    } else {
        s1 = this.os.inputBefore.join("");
        s2 = this.os.inputAfter.join("");
    }
    
    var str = this.prompt + s1;
    if (focused) {
        if (frameCount % this.os.blink < this.os.blink / 2) {
            noStroke();
            rect(x + textWidth(str), y - textAscent() - 1, 8, textAscent() + 3);   
        }
    }
    text(str + s2, x, y);
};

Environment.prototype._init = function() {
    // Nothing here - overridden by other programs
};

Environment.prototype._enter = function() {
    var str = this.os.getCmdString();

    // Clear this now, so it can be updated in _init functions
    this.os.inputBefore = [];
    this.os.inputAfter = [];
    
    this.os.output(this.prompt + str);
    var parts = str.split(" ");
    this._run(parts[0], parts.splice(1));
};

Environment.prototype._delete = function() {
    if (this.os.inputBefore.length > 0) {
        this.os.inputBefore.splice(this.os.inputBefore.length - 1, 1);
    }
};

Environment.prototype._input = function(value) {
    // To be overridden
};

Environment.prototype._run = function(functionName, parameters) {
    // Strip out underscores, so we can hide object functions
    functionName = functionName.replace('_', '');
    
    // Check whether function exists and if so run with parameters
    var f = this[functionName];
    
    if (f && typeof(f) === 'function') {
        return f.call(this, parameters);
    } else {
        this.os.raiseError("CommandError", functionName + ": command not found");
    }
};

Environment.prototype._quit = function() {
    // As a default, assume that quitting returns to explorer
    // Return to explorer without reinitialising it
    this.os.currentProgram = this.os.programs.explorer;
};

Environment.prototype.help = function() {
    this.os.outputArray(this.helpString);
};

/*****************************************************
 *      Input Environment object
 * This represents a simple program that gets a
 * series of inputs, which it saves in this.data.
 * At the end the _end function is called.
 * A series of prompts should be saved in this.states.
******************************************************/

var InputEnv = function(os) {
    this.os = os;
    this.states = [];
};

InputEnv.prototype = Object.create(Environment.prototype);

InputEnv.prototype._init = function() {
    this.inputs = [];
    this.currentState = 0;
    this._getState();
};

InputEnv.prototype._getState = function() {
    if (this.currentState >= this.states.length) {
        this._end();
        return;
    }
    
    this.state = this.states[this.currentState];
    
    if (!this.state) {
        this.os.raiseError("FatalError", "Input program has no states");
        this.os.run('explorer');
    }
    
    if (this.state.prompt) {
        this.prompt = this.state.prompt + ": ";
    } else {
        this.prompt = "> ";
    }
    
    this.hideInput = this.state.password;
};

InputEnv.prototype._enter = function() {
    var str = this.os.getCmdString();

    // Ensure there is some text to enter
    if (!str.length) { return; }

    // Clear this now, so it can be updated in _init functions
    this.os.inputBefore = [];
    this.os.inputAfter = [];
    
    if (this.hideInput) {
        this.os.output(this.prompt + Array(str.length + 1).join("*"));    
    } else {
        this.os.output(this.prompt + str);
    }
    
    this.inputs.push(str);
    
    if (this.state.func) {
        var func = this[this.state.func];
        if (func) {
            func.call(this);   
        } else {
            this.os.raiseError("ProgramError", "No function " + this.state.func);
        }
    }
    
    if (this.state.validInput && this.state.validInput.indexOf(str) === -1) {
        this.os.output(str + " is not a valid input");
        this.os.output("Enter one of " + this.state.validInput);
        return;
    }
    
    this.currentState++;
    this._getState();
};

InputEnv.prototype._end = function() {
    // Called after all input received.
    // Should be overridden.
    this._quit();
};

/*****************************************************
 *  Functions for build various programs
******************************************************/

// Create a program show starting info and runs the login program
var buildInfoEnv = function(os) {
    var env = new Environment(os);
    
    env.helpString = [
        "Type a command then enter",
        "Commands:",
        "  login:           login into server",
        "  login [name]:    login into server as name"
    ];

    env._init = function() {
        this._run('info');
    };
    
    env._quit = function() {
        // You can't quit this program
    };

    env.info = function() {
        this.os.outputArray([
            " -------------------------------------------- ",
            "            Welcome to InCompiTech          ",
            "        In Computer Technology We Trust     ",
            " ",
            "   Type help for help and login to login  ",
            "   First-time users can login as guest    ",
            " -------------------------------------------- "]);
    };
    
    env.login = function(username) {
        this.os.run('login', username);
    };

    return env;
};

// Create a program that deals with people logging into their accounts
var buildLoginEnv = function(os) {
    var env = new InputEnv(os);
    
    env.states = [
        { prompt: 'username', func: '_checkUsername' },
        { prompt: 'password', password: true },
    ];
    
    env._init = function(username) {
        this.inputs = [];
        if (username && username.length > 0) {
            username = username.join(" ");
            if (username === 'guest') {
                this._loginSucess({ username: 'guest' , clearance: 0 });
            }
            this.inputs.push(username);
            this.currentState = 1;
        } else {
            this.currentState = 0;
        }
        this._getState();
    };
    
    env._end = function() {
        var username = this.inputs[0];
        var person = this.os.users[username];
        
        if (person && this.inputs[1] === person.password) {
            this._loginSucess(person);
        } else {
            this.os.output("Incorrect password");
            this.os.run('info');
        }
    };
    
    env._checkUsername = function() {
        if (this.inputs[0] === 'guest') {
            this._loginSucess({ username: 'guest' , clearance: 0 });
        }
    };
    
    env._loginSucess = function(person) {
        var s = "Logged in as " + person.username;
        if (person.username !== 'guest') {
            s += " (" + clearanceNames[person.clearance] + ")";
        }
        tasks.add('login ' + person.clearance);
        this.os.output(s);
        this.os.run('explorer', person);
    };
    
    env._quit = function() {
        this.os.run('info');
    };
    
    return env;
};

// Program that functions as a file explorer with generic terminal functions
var buildExplorerEnv = function(os) {
    var env = new Environment(os);
    
    env.helpString = [
        " Type a command then enter",
        " Use up and down arrows to browse history",
        " Use alt to complete a file or folder name",
        " ",
        " Key Commands:",
        "  ls             list files and folders",
        "  cd <path>      change to folder <path>",
        "  cd ..          change to parent folder",
        "  read <path>    read file called <path>",
        "  run <path>     run file called <path>",
        "  exit           exit the server",
        "  man <cmd>      show manual for <cmd>",
        "  cmd            list all valid commands",
    ];
    
    env.synonyms = {
        list: 'ls',
        show: 'ls',
        dir: 'ls',
        cat: 'read',
        more: 'read',
        nano: 'edit',
        vi: 'edit',
        vim: 'edit',
        write: 'touch',
        logout: 'exit'
    };
    
    env._init = function(user) {
        this.currentFolder = os.root;

        if (user) {
            this.clearance = user.clearance;
            this.username = user.username;
            this.prompt = user.username + "@ICT > ";
            
            // Set user profile
            if (user.folder) {
                os.root.folders.user = user.folder;
            } else {
                delete os.root.folders.user;
            }
        } else {
            //this.clearance = 0;
        }
        
        // Get or set-up bash history
        this.historyN = -1;
        var folder = this.os.getFolder("user");
        if (!folder[0]) {
            folder = this.os.root;
        } else {
            folder = folder[1];
        }
        
        // TODO: should delete the old guest .bash_history
        
        var dest = this.os.getFolder(".bash_history", folder);
        if (!dest[0]) {
            // Create new history
            this.history = this.os.addFile(".bash_history", [0,2,2], [], folder);
        } else {
            // Get old history
            this.history = dest[1];
        }
        
    };
    
    env._enter = function() {
        var str = this.os.getCmdString();

        // Clear this now, so it can be updated in _init functions
        this.os.inputBefore = [];
        this.os.inputAfter = [];
    
        this.os.output(this.prompt + str);
        this.history.data.unshift(str);
        this.historyN = -1;
        
        // Test whether we are piping output
        // TODO improve how this is done
        var outputTo = false;
        var parts = str.split(/\s*>\s*/);
        
        if (parts.length > 1) {
            outputTo = parts[1];
            str = parts[0];
        }
        
        // Split on whitespace
        var parts = str.split(/\s+/);
        
        // Remove leading space if there is one
        if (!parts[0].length) {
            parts = parts.slice(1);
        }
        
        var func = this.synonyms[parts[0]] || parts[0];
        
        var output = this._run(func, parts.splice(1));
        if (!outputTo) {
            if (output) {
                this.os.outputArray(output);    
            }
        } else {
            // create output to file
            this.os.addFile(outputTo, [0,0,0], output, this.currentFolder); 
        }
    };
    
    env._input = function(value) {
        if (value === 38) {
            env._browseHistory(1);
        } else if (value === 40) {
            env._browseHistory(-1);
        } else if (value === 18) {
            env._autoComplete();
        }
    };
    
    env._browseHistory = function(d) {
        this.historyN = constrain(env.historyN + d, 0, env.history.data.length - 1);
        this.os.setCmdString(this.history.data[this.historyN]);
    };
    
    env._autoComplete = function() {
        // Get final part of the command string
        var currentFolder = this.currentFolder;
        var cmd = this.os.getCmdString().split(" ");
        var last = cmd.splice(-1);
        
        // Join command string back together
        cmd = cmd.join(" ") + (cmd.length > 0 ? " " : "");
        
        // Test whether the last part is a path
        last = last[0].split("/");
        
        if (last.length > 1) {
            // Remove final element in path
            var last2 = last.splice(-1);
            var path = last.join("/");
            var dest = os.getFolder(path, currentFolder, this.clearance, true);
            if (!dest[0]) { return; }
            var currentFolder = dest[1];
            last = last2[0];
            cmd += path + "/";
        } else {
            last = last[0];
        }
        
        var n = last.length;
        if (n < 1) { return; }
        
        // Get an array of potential options
        var options = [];
        for (var folder in currentFolder.folders) {
            if (last === folder.slice(0, n)) {
                options.push(folder);
            }
        }
        
        for (var file in currentFolder.files) {
            if (last === file.slice(0, n)) {
                options.push(file);
            }
        }
        
        if (options.length === 1) {
            this.os.setCmdString(cmd + options[0]);
        } else if (options.length > 1) {
            // Find the longest substring for all options
            for (; n < options[0].length; n++) {
                var s = options[0].slice(0, n + 1);
                var flag = true;
                for (var i = 1; i < options.length; i++) {
                    if (options[i].slice(0, n + 1) !== s) {
                        flag = false;
                        break;
                    }
                }
                if (!flag) { break; }
            }
            this.os.setCmdString(cmd + options[0].slice(0, n));
            this.os.output(options.join(" "));
        }
    };
    
    // Commands used in Explorer below

    env.cd = function(parameters) {
        // Change directory
        var dest = this.os.getFolder(parameters[0], this.currentFolder, this.clearance);
        if (dest[0]) {
            if (dest[1].folders) {
                this.currentFolder = dest[1];
            } else {
                this.os.raiseError("PathError", dest[1].name + ": is not a folder");
            }
        } else {
            this.os.raiseError(dest[1], dest[2]);
        }
    };
    
    env.cmd = function() {
        var commands = [];
        for (var attr in this) {
            if (typeof(this[attr]) === 'function' && attr !== 'constructor' && attr.charAt(0) !== '_') {
                commands.push(attr);
            }
        }
        return [commands.join(", ")];
    };
    
    env.echo = function(str) {
        return [str.join(" ")];
    };
    
    env.edit = function(parameters) {
        if (!parameters.length) {
            os.raiseError("CommandError", "edit: requires a file name");
            return;
        }
        
        var dest = this.os.getFolder(parameters[0], this.currentFolder);
        
        // No file found, so raise error
        if (!dest[0]) { os.raiseError(dest[1], dest[2]); }
        
        var file = dest[1];
        if (file.folders) {
            this.os.raiseError("IOError", file.name + ": is a folder");
        } else if (file.canRead) {
            if (this.clearance >= file.clearance[1]) {
                os.run("edit", file);
            } else {
                this.os.raiseError("PermissionError", file.name + ": you do not have write permission");
            }
        } else {
            this.os.raiseError("IOError", file.name + ": cannot be read");
        }
    };
    
    env.exit = function() {
        // Logout of the server
        this.os.run('info');
    };
    
    env.ls = function(parameters) {
        var options = [];
        var paths = [];
        
        for (var i = 0; i < parameters.length; i++) {
            var p = parameters[i];
            if (p.length > 0 && p.charAt(0) === '-') {
                for (var j = 1; j < p.length; j++) {
                    options.push(p.charAt(j));
                }
            } else {
                paths.push(p);
            }
        }
        
        // Allow ls path to list in path
        // TODO: check path, folder-by-folder to find first not permitted
        var startFolder = this.currentFolder;
        if (paths.length > 0) {
            var dest = os.getFolder(paths[0], this.currentFolder);
            if (dest[0]) {
                startFolder = dest[1];
            } else {
                os.raiseError(dest[1], dest[2]);
                return;
            }
        }
        
        var files = { };
        if (options.indexOf('a') !== -1) {
            files = startFolder.files;
        } else {
            for (var file in startFolder.files) {
                var f = startFolder.files[file];
                if (!f.hidden) {
                    files[file] = f;
                }
            }
        }
        
        var folders = startFolder.folders;
        var output = [];
        
        // List files and folders
        if (options.indexOf('l') !== -1) {
            output.push("  NAME                 TYPE     CLEARANCE");
            for (var folder in folders) {
                var s = " " + folder;
                s += Array(22 - folder.length).join(" ");
                s += "folder      ";
                s += folders[folder].clearance.join("/");
                output.push(s);
            }
            for (var file in files) {
                var s = " " + file;
                s += Array(22 - file.length).join(" ");
                s += files[file].ext === 'exe'? "script      " : "text        ";
                s += files[file].clearance.join("-");
                output.push(s);
            }
        } else {
            for (var folder in folders) {
                output.push(" " + folder);
            }
            for (var file in files) {
                output.push(" " + file);
            }
        }
        
        return output;
    };
    
    env.man = function(parameters) {
        // Would be nice to bind these to the actual functions
        var manual = {
            cd: {
                desc: [
                    'change directory to <path>',
                    '<path> can be absolute (starting with /),',
                    'or relative',
                ],
                arg: 'path',
            },
            cmd: { desc: ['list all valid commands'] },
            echo: {
                desc: ['write arguments to output'],
                arg: '[string]'
            },
            edit: {
                desc: ['open file <name> in text editor'],
                arg: 'name'
            },
            exit: { desc: ['exit the server'] },
            ls: {
                desc: [
                    'list files and folders in current',
                    'folder unless a path is specified'
                ],
                arg: '[-al] [path]',
                options: {
                    '-a': 'include hidden files',
                    '-l': 'show file type and permissions'
                }
            },
            man: {
                desc: ['display manual for the command <name>'],
                arg: 'name'
            },
            mkdir: {
                desc: ['make a directory (folder) called <name>'],
                arg: 'name'
            },
            pwd: { desc: ['show path for current folder'] },
            read: {
                desc: ['show the contents of file <name>'],
                arg: 'name'
            },
            run: {
                desc: ['execute file <name>'],
                arg: 'name'
            },
            touch: {
                desc: ['make a file called <name>'],
                arg: 'name'
            },
            whoami: { desc: ['show current user and clearance'] },
        };
        
        if (parameters.length === 0) {
            return ["What manual page do you want?"];
        }
        
        for (var i = 0; i < parameters.length; i++) {
            var parameter = parameters[i];
            var cmd = manual[parameter];
            if (cmd) {
                var arg = cmd.arg;
                var desc = cmd.desc;
                var opt = cmd.options;
                var output = [
                    "USAGE",
                    "    " + parameter + " " + (arg ? arg : ""),
                    "DESCRIPTION"
                ];
                
                for (var i = 0; i < desc.length; i++) {
                    output.push("    " + desc[i]);
                }
                if (opt) {
                    output.push("OPTIONS");
                    for (var o in opt) {
                        output.push("    " + o + "  " + opt[o]);
                    }    
                }
                return output;
            } else {
                this.os.raiseError("CommandError", parameter + ": manual not found");
            }
        }
    };
    
    env.mkdir = function(parameters) {
        if (parameters.length) {
            var name = parameters[0];
            this.os.addFolder(name, 0, this.currentFolder);    
        } else {
            os.raiseError("CommandError", "mkdir: requires a folder name");
        }
    };
    
    env.pwd = function() {
        return [this.currentFolder.getPath() || "/"];
    };
    
    env.read = function(parameters) {
        var dest = this.os.getFolder(parameters[0], this.currentFolder);
        
        // No file found, so raise error
        if (!dest[0]) {
            os.raiseError(dest[1], dest[2]);
            return;
        }
        
        var file = dest[1];
        if (file.folders) {
            this.os.raiseError("IOError", file.name + ": is a folder");
        } else if (file.canRead) {
            if (this.clearance >= file.clearance[0]) {
                if (file.task) {
                    tasks.add('read ' + file.name);
                }
                return file.data;
            } else {
                this.os.raiseError("PermissionError", file.name + ": you do not have read permission");
            }
        } else {
            this.os.raiseError("IOError", file.name + ": cannot be read");
        }
    };
    
    env.run = function(parameters) {
        var dest = this.os.getFolder(parameters[0], this.currentFolder);
        
        // No file found, so raise error
        if (!dest[0]) {
            os.raiseError(dest[1], dest[2]);
            return;
        }
        
        var file = dest[1];
        
        if (this.clearance < file.clearance[2]) {
            this.os.raiseError("PermissionError", file.name + ": you do not have permission to run.");
        } else if (!file.canRun) {
            this.os.raiseError("RunTimeError", file.name + ": cannot be run");
        } else if (!file.canRun) {
            this.os.raiseError("RunTimeError", file.name + ": no program data found");
        } else {
            this.os.run(file.script);
        }
    };
    
    env.touch = function(parameters) {
        if (parameters.length) {
            var name = parameters[0];
            this.os.addFile(name, [0, 0, 0], [], this.currentFolder);    
        } else {
            os.raiseError("CommandError", "touch: requires a file name");
        }
    };
    
    env.whoami = function() {
        var s = this.username || "root";
        if (this.clearance) {
            s += " (clearance: " + this.clearance + ")";
        }
        return [s];
    };
    
    return env;
};

var buildTextEditor = function(os) {
    var env = new Environment(os);
    
    env._init = function(file) {
        this.row = 0;
        this.prompt = "";
        this.file = file;
        
        if (file.data && file.data.length) {
            this.data = file.data.slice(0);
        } else {
            this.data = [" "];
        }
        
        this._updateLine(0);
    };
    
    env._draw = function(x, y) {
        for (var i = 0; i < this.data.length; i++) {
            var str = this.data[i];
            if (i !== this.row) {
                text(str, x, y, this.os.width, this.os.height);
            } else {
                this._drawCursor(x + 1, y + 9);
            }
            y += 16 * ceil(str ? textWidth(str) / this.os.width : 1);
        }
        text("Press Alt to save and quit.", x, height - 54);
        text("Press Ctrl + Alt to quit without saving.", x, height - 36);
    };
    
    env._input = function(value) {
        if (value === 38) {
            this._updateLine(-1);
        } else if (value === 40) {
            this._updateLine(1);
        } else if (value === 18) {
            this.data[this.row] = this.os.getCmdString();
            if (!this.os.ctrl) {
                this.file.data = this.data;
            }
            
            this.os.inputBefore = [];
            this.os.inputAfter = [];
            
            // Return to explorer without reinitialising it
            this._quit();
        }
    };
    
    env._enter = function() {
        if (this.data.length < 12) {
            this.data.splice(this.row + 1, 0, this.os.inputAfter.join(""));
            this.os.inputAfter = [];
            this._updateLine(1);
        }
    };
    
    env._delete = function() {
        if (this.os.inputBefore.length > 0) {
            this.os.inputBefore.splice(this.os.inputBefore.length - 1, 1);
        } else if (this.row > 0) {
            var pos = this.data[this.row - 1].length;
            this.data[this.row - 1] += this.os.inputAfter.join("");
            this._updateLine(-1, pos);
            var nextRow = this.data.splice(this.row + 1, 1);
        }
    };
    
    env._updateLine = function(d, pos) {
        // Add new line back to file data
        if (d) {
            pos = pos || this.os.inputBefore.length;
            this.data[this.row] = this.os.getCmdString();
        }
        
        // Add the new line in the correct place
        this.row = constrain(this.row + d, 0, this.data.length - 1);
        var lineArray = this.data[this.row].split("");
        this.os.inputAfter = lineArray.splice(pos);
        this.os.inputBefore = lineArray;
    };
    
    return env;
};

// *** Programs found as .exe files ***

var createUserEnv = function(os) {
    var env = new InputEnv(os);
    
    env.description = [
        "Creates a user profile on the computer.",
        "A username is generated from the first two",
        "letters of the first name and the first three",
        "of the second name.",
        "New users have a clearance level of 1."
    ];
    
    env.states = [
        { prompt: 'first name' },
        { prompt: 'last name' },
        { prompt: 'password', password: true },
    ];

    env._end = function() {
        var user = this.os.addUser(this.inputs[0], this.inputs[1], this.inputs[2], 1);
        this.os.outputArray([
            "  New user profile created",
            "    username: " + user.username,
            "    clearance " + user.clearance + " (" + clearanceNames[user.clearance] + ")"
        ]);
        tasks.add('create profile ' + user.clearance);
        this._quit();
    };
    
    return env;
};

var createBiogEnv = function(os) {
    var env = new InputEnv(os);
    
    env.description = [
        "Creates a user biography at /user/documents/biog.txt.",
        "Users are encouraged to create a biography,",
        "especially if they are admins"
    ];
    
    env.states = [
        { prompt: 'extension' },
        { prompt: 'line manager' },
        { prompt: 'other duties' },
    ];

    env._end = function() {
        this.os.addFile("/user/documents/biog.txt", [1, 1, 1], [
            "Extension: " + this.inputs[0],
            "Line manager: " + this.inputs[1],
            "Additional duties: " + this.inputs[2]
        ]);
        
        tasks.add('create biog');
        this._quit();
    };
    
    return env;
};

var addToGroupEnv = function(os) {
    var env = new InputEnv(os);
    
    var groups = ['security', 'procurement', 'investment', 'analysis', 'marketing'];
    
    env.description = [
        "Adds a user to a group",
        "This updates the personnel.txt file for the group",
        "(or makes on if this is the first user).",
        "If the user is an admin and has a biography, it will",
        "copy the details of their biog.txt to the group page.",
    ];
    
    env.states = [
        { prompt: 'first name' },
        { prompt: 'last name', func: '_getUser' }, 
        { prompt: 'group number', validInput: ['1', '2', '3', '4', '5'] }
    ];

    env._init = function() {
        this.inputs = [];
        this.currentState = 0;
        this._getState();
        
        var dest = this.os.getFolder(".addToGroup.config", this.parent);
        
        if (!dest[0]) {
            this.os.raiseError("ProgramError", ".addToGroup.config not found");
            this.os.run("explorer");
        } else {
            this.paths = [];
            var p = 0;
            var f = dest[1];
            
            // Ignore lines that start with #
            // Paths are first two lines
            for (var i = 0; i < f.data.length; i++) {
                if (f.data[i][0] !== '#') {
                    this.paths[p] = f.data[i].replace(/\s+/g, "");
                    p++;
                }
            }
            
            if (p !== 2) {
                this.os.raiseError("ProgramError", "Insufficient data in .addToGroup.config");
                this._quit();
            }
        }
    };

    env._getUser = function() {
        var username = this.os.generateUsername(this.inputs[0], this.inputs[1]);
        this.person = this.os.users[username];
        
        if (!this.person) {
            os.raiseError("ProgramError", "No user found with username " + username);
            this.os.run('explorer');
        } else {
            this.userClearance = clearanceNames[this.person.clearance];
            this.os.output("  Found user: " + username + " (" + this.userClearance + ")");
            
            // Groups are hard-coded
            this.os.output("  User can be added to the following groups");
            for (var i = 0; i < groups.length; i++) {
                this.os.output("    " + (i + 1) + ". " + groups[i]);
            }
        }
    };

    env._end = function() {
        var name1 = this.inputs[0];
        var name2 = this.inputs[1];
        var group = groups[parseInt(this.inputs[2], 10) - 1];
        var groupPath = this.paths[0] + "/" + group;
        
        // Move to this.person's account (must be a way to exploit this)
        var currentUserAccount = os.root.folders.user;
        if (this.person.folder) {
            this.os.root.folders.user = this.person.folder;
        } else {
            delete this.os.root.folders.user;
        }
        
        var dest = this.os.getFolder(groupPath);
        
        if (!dest[0]) {
            // Failed to open path to group
            this.os.raiseError(dest[1], dest[2]);
            this.os.raiseError("ProgramError", "Unable to open " + groupPath);
            this.os.output("Check group exists or update the path in .addToGroup.config");
        } else {
            // Get personnel.txt file
            var dest = this.os.getFolder(groupPath + "/personnel.txt");
            var personnel = dest[1];
            
            if (!dest[0]) {
                this.os.output("personnel.txt not found, creating one...");
                personnel = this.os.addFile(groupPath + "/personnel.txt", 5, []);
            }
            // TODO: Check whether person is already in group?
            personnel.data.push([this.userClearance + " " + name1 + " " + name2]);
            this.os.output(name1 + " " + name2 + " added to group " + group);
            
            // Add biog.txt if found and user if admin
            if (this.person.clearance >= 2) {
                var biogPath = this.paths[1];
                var dest = this.os.getFolder(biogPath);
                if (!dest[0]) {
                    this.os.output("Unable to find " + biogPath);
                    this.os.output("No user biography added");
                } else {
                    // Make new file
                    var filename = groupPath + "/" + name1 + name2 + ".txt";
                    var file = this.os.addFile(filename, [1, 3, 3], dest[1].data, null, true);
                    this.os.output("User biog.txt data added to " + file.getPath());
                }
            }
        }
        
        // Return to original account
        this.os.root.folders.user = currentUserAccount;
        
        this._quit();
    };
    
    return env;
};

var makeAdminEnv = function(os) {
    var env = new InputEnv(os);
    
    env.description = [
        "Give a user admin clearance"
    ];
    
    env.states = [{ prompt: 'username' }];

    env._end = function() {
        var person = this.os.users[this.inputs[0]];
        
        if (!person) {
            this.os.raiseError("ProgramError", "No user found with username " + this.inputs[0]);
        } else {
            person.clearance = max(2, person.clearance);
            // Groups are hard-coded
            this.os.output("  " + this.inputs[0] + " now has admin clearance.");
        }
        
        this._quit();
    };
    
    return env;
};

var sentinelEnv = function(os) {
    var env = new Environment(os);
    var enterEnv = new InputEnv(os);
    
    enterEnv.states = [
        { prompt: '  Sentinel password', password: true },
    ];

    enterEnv._end = function() {
        // Password is never correct
        this.os.output("Incorrect password");
        this._quit();
    };
    
    env._init = function() {
        // Sentinel overrides the normal getFolder function
        // It checks if the folder is on its watchlist
        // And if it is, it is requires a password to continue
        
        var getFolder = os.getFolder;
        var boundGetFolder = getFolder.bind(os);
        var sentinelParent = this.parent;
        
        os.getFolder = function(path, parent, clearance, suppress) {
            var watchlist;
            var dest = getFolder("sentinel.txt", sentinelParent, 3);
            
            if (dest[0]) {
                watchlist = dest[1];
            } else {
                this.raiseError("ProgramError", "sentinel.txt: File not found");
            }
            
            var fullPath = (parent ? parent.getPath() : "") + "/" + path;
            if (watchlist) {
                for (var i = 1; i < watchlist.data.length; i++) {
                    if (watchlist.data[i] === fullPath) {
                        if (!suppress) {
                            os.currentProgram = enterEnv;
                            enterEnv._init();
                            return [false, "PermissionError", "  Folder protected by sentinel"];
                        } else {
                            return [false, ""];
                        }
                    }
                }
            }
            
            return boundGetFolder(path, parent, clearance);
        };
    };
    
    return env;
};

/*******************************************************
 *      Operating System
 * This is the outer wrapper for all the programs.
 * It consists of the terminal input/output control and
 * stores a directory of files and folders as a tree.
********************************************************/

var OperatingSystem = function() {
    // Display variables
    this.background = color(30, 30, 25);
    this.font = createFont("monospace", 13);
    this.textCol = color(245, 245, 240);
    
    // Terminal position and size
    this.x = 16;
    this.y = 16;
    this.promptY = this.y;
    this.width = width - 2 * this.x;
    this.height = height - this.y - 25;
    this.scrollY = 0;
    this.scrolling = false;
    this.blink = 40;
    
    // Map program names to program objects
    this.programs = {};
    this.currentProgram = false;
    
    // The current string to be inputed as two arrays
    // of characters before and after the cursor
    this.inputBefore = [];
    this.inputAfter = [];
    
    // So we can display what has been displayed
    this.outputs = [];
    
    // Tree of files and folders
    this.root = new Folder('~', 0);
    
    // Users: maps username to [password, clearance]
    this.users = { };
};

OperatingSystem.prototype.draw = function() {
    // Background
    background(200, 200, 200);
    fill(this.background);
    rect(5, 5, width - 10, height - 30, 10);
    
    fill(this.textCol);
    textFont(this.font);
    textAlign(LEFT, BASELINE);

    if (this.currentProgram._draw) {
        this.currentProgram._draw(this.x, this.y);
    } else {
        // Previous outputs
        var dy = max(0, this.promptY - this.height) - this.scrollY;
        for (var i = 0; i < this.outputs.length; i++) {
            var ty = this.outputs[i][0] - dy;
            text(this.outputs[i][1], this.x, ty, this.width, this.height);
            if (ty > height - 30) { break; }
        }
        
        if (this.currentProgram) {
            var y = this.promptY + textAscent() - dy;
            this.currentProgram._drawCursor(this.x, y);
        }
    }
    
    // Mask upper and lower edge in case of overlap
    noStroke();
    fill(200);
    rect(0, 0, width, 5);
    rect(0, height - 25, width, 25);
};

OperatingSystem.prototype.keyPressed = function() {
    var inputLength = this.inputBefore.length + this.inputAfter.length;
    
    // Press enter
    if (keyCode === ENTER || keyCode === RETURN) {
        if (this.currentProgram) {
            this.currentProgram._enter();
        }
        return;
    }
    
    // Control / command
    if (keyCode === CONTROL || keyCode === 157) {
        this.ctrl = true;
    }
    
    // Ctrl + X = Force quit
    if (this.ctrl && keyCode === 88) {
        if (this.currentProgram) {
            this.currentProgram._quit();
        }
    }
    
    // Special keys
    if (keyCode === DELETE || keyCode === BACKSPACE) {
        if (this.ctrl) {
            this.inputBefore = [];
            this.inputAfter = [];
        } else if (this.currentProgram) {
            this.currentProgram._delete();
        }
    } else if (keyCode === LEFT) {
        if (this.inputBefore.length > 0) {
            if (this.ctrl) {
                this.inputAfter = this.inputBefore.concat(this.inputAfter);
                this.inputBefore = [];
            } else {
                var letter = this.inputBefore.pop();
                this.inputAfter.unshift(letter);
            }
        }
    } else if (keyCode === RIGHT) {
        if (this.inputAfter.length > 0) {
            if (this.ctrl) {
                this.inputBefore = this.inputBefore.concat(this.inputAfter);
                this.inputAfter = [];
            } else {
                var letter = this.inputAfter.shift();
                this.inputBefore.push(letter);
            }
        }
    } else if ([18, 38, 40].indexOf(keyCode) !== -1) {
        if (this.currentProgram) {
            this.currentProgram._input(keyCode);
        }
    }
    
    // Input too long, so prevent any more characters being added
    if (inputLength > 40) { return; }
    
    if ((keyCode > 47 && keyCode < 91) || (keyCode > 186 && keyCode < 223)) {
        // Add number or lowercase letter
        this.inputBefore.push(key.toString());
    } else if (keyCode === 32) {
        this.inputBefore.push(" ");
    }
    
};

OperatingSystem.prototype.keyReleased = function() {
    // Control / command
    if (keyCode === CONTROL || keyCode === 157) {
        this.ctrl = false;
    }
};

OperatingSystem.prototype.scroll = function() {
    if (this.promptY) {
        var screenExtra = max(0, this.promptY - this.height);
        if (screenExtra === 0) { return; }
        
        var fraction = this.height / this.promptY;
        var barHeight = max(25, height * fraction);
        var scrollSpace = 388 - barHeight;
        
        var d = (pmouseY - mouseY) * screenExtra / scrollSpace;
        this.scrollY = constrain(this.scrollY + d, 0, max(0, this.promptY - this.height));  
    }
};

OperatingSystem.prototype.getCmdString = function() {
    return this.inputBefore.join("") + this.inputAfter.join("");
};

OperatingSystem.prototype.setCmdString = function(str) {
    str = str || "";
    this.inputBefore = str.split('');
    this.inputAfter = [];
};

OperatingSystem.prototype.output = function(str) {
    this.outputs.push([this.promptY, str]);
    this.promptY += 16 * ceil(textWidth(str) / this.width);
};

OperatingSystem.prototype.outputArray = function(arr, start) {
    start = start || "";
    
    if (arr.length) {
        for (var i = 0; i < arr.length; i++) {
            this.output(start + arr[i]);
        }
    } else {
        this.output(start + arr);
    }
};

OperatingSystem.prototype.run = function(program, parameters) {
    if (program._init) {
        // Local program
        this.currentProgram = program;
        this.currentProgram._init(parameters);
    } else if (this.programs[program]) {
        // Program stored in bin
        this.currentProgram = this.programs[program];
        this.currentProgram._init(parameters);
    } else {
        this.raiseError("RunTimeError", program + " could not be found.");
    }
};

OperatingSystem.prototype.getFolder = function(path, parent, clearance) {
    // TODO: change of order of arguments to be consistent with other functions
    path = path || "";
    parent = parent || this.root;
    
    var pathElements = path.split('/');
    if (pathElements[0] === '') {
        pathElements = pathElements.splice(1);
    } else if (pathElements[0] === '~') {
        pathElements = pathElements.splice(1);
        parent = this.root;
    }
    
    return parent.getFromPath(pathElements, clearance);
};

OperatingSystem.prototype.getBaseFolder = function(path, clearance, parent) {
    // Given a path to a new folder or file, return the base folder
    // and file or folder name
    
    var parts = path.split('/');
    var name = parts.splice(-1)[0];
    var basepath = parts.join('/');
    
    var dest = this.getFolder(basepath, parent);
    
    if (dest[0]) {
        var folder = dest[1];
        if (folder.folders) {
            return [folder, name];
        } else {
            this.raiseError('PathError', folder.name + ": Not a folder");
            return false;
        }
    } else {
        this.raiseError(dest[1], dest[2]);
        return false;
    }
};

OperatingSystem.prototype.addFolder = function(path, clearance, parent) {
    var dest = this.getBaseFolder(path, clearance, parent);
    
    if (dest) {
        var folder = dest[0];
        var name = dest[1];
        
        if (clearance <= folder.clearance[1]) {
            this.raiseError('PermissionError', "You do not have write permission");
        } else if (folder.folders[name] || folder.files[name]) {
            this.raiseError('PathError', name + ": Already exists");
        } else {
            var newFolder = new Folder(name, clearance, folder);
            folder.folders[name] = newFolder;
            return newFolder;
        }
    }
};

OperatingSystem.prototype.addFile = function(path, clearance, data, parent, overwrite, task) {
    var dest = this.getBaseFolder(path, clearance, parent);
    if (dest) {
        var folder = dest[0];
        var name = dest[1];
        var exists = folder.files[name] || folder.folders[name];
        
        if (name.indexOf('..') !== -1) {
            this.raiseError('PathError', name + ": Invalid file name");
        } else if (clearance <= folder.clearance[1]) {
            this.raiseError('PermissionError', "You do not have write permission");
        } else if (!overwrite && exists) {
            this.raiseError('PathError', name + ": Already exists");
        } else if (overwrite && exists && clearance <= exists.clearance[1]) {
            this.raiseError('PermissionError', "You do not permission to overwrite: " + name);
        } else {
            var newFile = new File(name, clearance, folder, data, task);
            folder.files[name] = newFile;
            return newFile;
        }
    }
};

OperatingSystem.prototype.removeFile = function(path, clearance, parent) {
    var dest = this.getBaseFolder(path, clearance, parent);
    
    if (dest) {
        var folder = dest[0];
        var name = dest[1];
        if (folder.files[name]) {
            delete folder.files[name];
        } else {
            this.raiseError('PathError', name + ": Does not exist");
        }
    }
};

OperatingSystem.prototype.generateUsername = function(name1, name2) {
    // Generate a username from the first two letters of the first name
    // and the first three of the second name
    var username = name1.slice(0, 2) + name2.slice(0, 3);
    return username.toLowerCase();
};

OperatingSystem.prototype.addUser = function(name1, name2, password, clearance) {
    var username = this.generateUsername(name1, name2);
    var user = this.users[username];
    
    if (user) {
        // Update password
        user.password = password;
    } else {
        // Add new user
        this.users[username] = {
            name1: name1,
            name2: name2,
            username: username,
            password: password,
            clearance: clearance,
            folder: new Folder('user', [1, 1, 1], this.root)
        };
        
        user = this.users[username];
        
        // Add user documents
        this.addFolder("documents", [1, 1, 1], user.folder);
    }
    
    return user;
};

OperatingSystem.prototype.raiseError = function(error, details) {
    this.output('ERROR: ' + error);
    this.output(details);
};

/*****************************************************
 *  Setting up the computer
******************************************************/

// Create the people who use the computer
var setupPeople = function() {
    var firstNames = ["Sophia", "Isabella", "Emma", "Olivia", "Ava", "Emily", "Abigail", "Madison", "Mia", "Chloe", "Elizabeth", "Ella", "Addison", "Natalie", "Lily", "Grace", "Samantha", "Avery", "Sofia", "Aubrey", "Brooklyn", "Lillian", "Victoria", "Evelyn", "Hannah", "Alexis", "Charlotte", "Zoey", "Leah", "Amelia", "Zoe", "Hailey", "Layla", "Gabriella", "Nevaeh", "Kaylee", "Alyssa", "Anna", "Sarah", "Allison", "Savannah", "Ashley", "Audrey", "Taylor", "Brianna", "Aaliyah", "Riley", "Camila", "Khloe", "Claire", "Jacob", "Mason", "William", "Jayden", "Noah", "Michael", "Ethan", "Alexander", "Aiden", "Daniel", "Anthony", "Matthew", "Elijah", "Joshua", "Liam", "Andrew", "James", "David", "Benjamin", "Logan", "Christopher", "Joseph", "Jackson", "Gabriel", "Ryan", "Samuel", "John", "Nathan", "Lucas", "Christian", "Jonathan", "Caleb", "Dylan", "Landon", "Isaac", "Gavin", "Brayden", "Tyler", "Luke", "Evan", "Carter", "Nicholas", "Isaiah", "Owen", "Jack", "Jordan", "Brandon", "Wyatt", "Julian", "Aaron"];

    var surnames = ["Adams", "Allen", "Anderson", "Bailey", "Baker", "Bell", "Bennett", "Brown", "Butler", "Campbell", "Carter", "Chapman", "Clark", "Collins", "Cook", "Cooper", "Cox", "Davies", "Davis", "Edwards", "Ellis", "Evans", "Fox", "Graham", "Gray", "Green", "Griffiths", "Hall", "Harrison", "Hill", "Holmes", "Hughes", "Hunt", "Hunter", "Jackson", "James", "Johnson", "Jones", "Kelly", "Kennedy", "Khan", "King", "Knight", "Lee", "Lewis", "Lloyd", "Marshall", "Martin", "Mason", "Matthews", "Miller", "Mitchell", "Moore", "Morgan", "Morris", "Murphy", "Murray", "Owen", "Palmer", "Parker", "Patel", "Phillips", "Powell", "Price", "Reid", "Reynolds", "Richards", "Richardson", "Roberts", "Robinson", "Rogers", "Rose", "Russell", "Saunders", "Scott", "Shaw", "Simpson", "Smith", "Stevens", "Stewart", "Taylor", "Thomas", "Thomson", "Turner", "Walker", "Walsh", "Ward", "Watson", "White", "Wilkinson", "Williams", "Wilson", "Wood", "Wright", "Young"];
    
    var people = [];
    
    var generatePassword = function(n) {
        var chars = "abcdefghijklmnopqrstuvwxyz0123456789".split("");
        var password = "";
        for (var i = 0; i < n; i++) {
            password += randFromArray(chars);
        }
        return password;
    };
    
    var createRandomPerson = function(clearance) {
        var name1 = randFromArray(firstNames);
        var name2 = randFromArray(surnames);
        
        return {
            name1: name1,
            name2: name2,
            password: generatePassword(floor(random() * 5) + 8),
            clearance: clearance
        };
    };

    people.push(createRandomPerson(2));
    
    for (var i = 0; i < 6; i++) {
        people.push(createRandomPerson(1));
    }
    
    return people;
};
var people = setupPeople();

var setupComputer = function(os, people) {
    // Add programs
    os.programs.info = buildInfoEnv(os);
    os.programs.login = buildLoginEnv(os);
    os.programs.explorer = buildExplorerEnv(os);
    os.programs.edit = buildTextEditor(os);
    
    // Add files and folders
    
    // System folder
    var system = os.addFolder('system', [2, 2, 2]);
    os.addFolder('security', [2, 3, 3], system);
    os.addFile('success.txt', [2, 3, 2], ["Level one complete!"], system, 0, true);
    os.addFile('security/success.txt', [2, 3, 2], ["Level two complete!"], system, 0, true);
    
    os.addFile('system/security/sentinel.txt', [2, 3, 2], [
        "# List of paths to be watched by sentinel.exe",
        "/system/security"
    ]);
    var sentinel = sentinelEnv(os);
    os.addFile('system/security/sentinel.exe', [2, 4, 4], sentinel);

    // Shared folder contains scripts and groups
    var shared = os.addFolder('shared', [0, 0, 0]);
    os.addFile('passwords.txt', [0, 2, 0],
        ["Employees are reminded to change their passwords every eight weeks."],
        shared);

    // Groups
    var groupFolder = os.addFolder('groups', [1, 2, 1], shared);
    var groups = [
        { name: 'special', clearance: [4,4,4] },
        { name: 'security', clearance: [3,3,3] },
        { name: 'procurement', clearance: [3,3,3] },
        { name: 'investment', clearance: [3,3,3] },
        { name: 'analysis', clearance: [3,3,3] },
        { name: 'marketing', clearance: [1,3,3] }
    ];
    
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        os.addFolder(group.name, group.clearance, groupFolder);
    }
    
    // Add people to marketing
    var data = [];
    var admin;
    for (var i = 0; i < people.length - 1; i++) {
        var person = people[i];
        var name1 = person.name1;
        var name2 = person.name2;
        var clearance = person.clearance;
        var user = os.addUser(name1, name2, person.password, clearance);
        data.push([clearanceNames[user.clearance] + " " + name1 + " " + name2]);
        if (clearance === 2) {
            admin = user;
        }
    }
    
    var adminName = (admin.name1 + admin.name2).toLowerCase();
    // Add files to marketing folder
    os.addFile("/marketing/personnel.txt", [1, 3, 3], data, groupFolder, 0, true);
    os.addFile("/marketing/" + adminName + ".txt", [1, 3, 3],
        ["Admin for marketing group",
         "Extension: 05783",
         "Line manager: " + people[5].name1 + " " + people[5].name2,
         "Additional duties: interviewing, doughnut round"],
         groupFolder);
    
    // Add admin's todo list
    os.addFile("documents/todo.txt", [1, 1, 1], [
            "Prepare for Winston's visit",
            "Get hair cut",
            "Buy doughnuts",
            "Update security/sentinel.txt",
            "Find pictures for Operation Jökulhlaup presentation"
        ], admin.folder, 0, true);

    // Scripts
    var scripts = os.addFolder('scripts', [0, 3, 0], shared);
    
    // Add programs
    os.addFile('createUser.exe', [0, 3, 0], createUserEnv(os), scripts);
    os.addFile('createBiog.exe', [0, 3, 1], createBiogEnv(os), scripts);
    os.addFile('makeAdmin.exe', [0, 3, 2], makeAdminEnv(os), scripts);
    os.addFile('addToGroup.exe', [0, 3, 2], addToGroupEnv(os), scripts);
    os.addFile('.addToGroup.config',[2, 2, 2],
        ["#Group Path", "/shared/groups", "#Biog Path", "/user/documents/biog.txt"],
        scripts, 0, true);

    //os.addUser('Peter', 'Collingridge', 'abc', 2);
    //os.addFile('t.txt', [0, 0, 0], ["a b c", "de"]);
    
    os.run(sentinel);
};

var os = new OperatingSystem();
setupComputer(os, people);

// Boot up
os.run('info');
//os.run('explorer', { username: 'pecol', clearance: 2 });

/*****************************************************
 *  Main loop
******************************************************/

draw = function() {
    os.draw();
    tasks.draw();
};

/*****************************************************
 *  Event handling
******************************************************/

keyPressed = function() {
    //println(keyCode);
    os.keyPressed();
};

keyReleased = function() {
    //println(keyCode);
    os.keyReleased();
};

mousePressed = function() {
    os.scrolling = true;
};

mouseOut = function() {
    os.scrolling = false;
};

mouseDragged = function () {
    os.scroll();
};
