// Anti-alias
// Render in 3D

var imageWidth = 400;
var imageHeight = 400;
var imageX = width - imageWidth;

var sansFont = createFont("sans", 15);
var serifFont = createFont("serif", 16);
var showing = {};

var SWATCHSIZE = 128;
var swatch;
var createSwatch = function(n, brightness) {
    loadPixels();
    var px = imageData.data;
    
    var ni = 1 / n;
    var x, y, h, s, r, g, b, i, f, p, q, t;
    var index;
    
    //var s = 0.5;          // Saturation
    var v = brightness;     // Brightness
    
    for (x = 0; x < n; x++) {
        h = ni * x;     // Hue along x-axis
        for (y = 0; y < n; y++) {
            s = ni * y; // Saturation along y-axis
            //v = ni * y; // Brightness along y-axis
            i = floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            index = x + (y * width) << 2;
            px[index++] = r * 0xFF | 0;
            px[index++] = g * 0xFF | 0;
            px[index++] = b * 0xFF | 0;
        }
    }
    updatePixels();
    return get(0, 0, n, n);
};

// GUI
{
/*************************************************
 * Generic GUI component from which other elements
 * inherit
 * The default object is basically a button
**************************************************/
{
var GUI_Component = function(x, y, w, h, name, updateFunction) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.name = name;
    
    if (updateFunction) {
        this.trigger = updateFunction.bind(this);
    }
    
    this.selected = false;
    this.disabled = false;
    this.transition = 0;
};

GUI_Component.prototype.draw = function() {
    var y = this.y + this.h;
    fill(20);
    stroke(20);
    strokeWeight(2);
    if (this.mouseOver()) {
        line(this.x + 8, y, this.x + this.w - 8, y);
    }
    
    textFont(sansFont, 16);
    textAlign(CENTER, BASELINE);
    text(this.name, this.x + this.w / 2, y - 3);
};

GUI_Component.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h);
};

GUI_Component.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
};

GUI_Component.prototype.mouseDragged = function() {};

GUI_Component.prototype.mouseReleased = function() {
    if (this.selected && !this.disabled && this.mouseOver()) {
        this.trigger();
    }
    this.selected = false;
};

GUI_Component.prototype.trigger = function() {
    // To be over-written
};

GUI_Component.prototype.fade = function() {
    if (this.selected || this.mouseOver()) {
        this.transition = min(10, this.transition + 1);
    } else {
        this.transition = max(0, this.transition - 1);
    }
};
}
/*************************************************
 *  GUI Button
**************************************************/
{
var Button = function(x, y, w, h, params) {
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    this.defaultCol = color(235, 235, 235, 240);
    this.highlightCol = params.highlightCol || color(210, 210, 210, 250);
    if (params.filled) {
        this.makeFilled();
    }
};
Button.prototype = Object.create(GUI_Component.prototype);

Button.prototype.draw = function() {
    this.fade();
    
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(200);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 12);
    
    if (this.disabled) {
        fill(120);
    } else {
        fill(20);
    }
    
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2 + 1);
};

Button.prototype.drawFilled = function() {
    this.fade();
    
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(this.highlightCol);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 19);
    
    if (this.disabled) {
        fill(120);
    } else {
        fill(lerpColor(this.highlightCol, color(255, 255, 255), this.transition / 10));
    }
    
    textFont(sansFont, 16);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2);
};

Button.prototype.makeFilled = function() {
    this.draw = this.drawFilled;
    this.defaultCol = color(0, 0, 0, 1);
};

var CheckBox = function(x, y, w, h, name) {
    Button.call(this, x, y, w, h, { name: name });
    this.box = this.h - 6;
    this.bx = this.x + 5;
    this.by = this.y + 3;
};
CheckBox.prototype = Object.create(Button.prototype);

CheckBox.prototype.trigger = function() {
    showing[this.name] = !showing[this.name];  
};

CheckBox.prototype.draw = function() {
    this.fade();
    
    if (this.transition) {
        noStroke();
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        rect(this.x, this.y, this.w, this.h + 1, 4);
    }
    
    fill(20);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    text(this.name, this.x + this.box + 9, this.y + this.h/2 + 1);
    
    noFill();
    stroke(10);
    strokeWeight(1);
    rect(this.bx, this.y + 3, this.box, this.box);

    if (showing[this.name]) {
        line(this.bx + 1, this.by + 1, this.bx + this.box, this.by + this.box);
        line(this.bx + this.box, this.by + 1, this.bx + 1, this.by + this.box);
    }
};
// Button to set a colour
var SwatchButton = function(x, y, w, h, name, colour, updateFunction) {
    Button.call(this, x, y, w, h, {
        name: name,
        trigger: function() {
            this.showSwatch = !this.showSwatch;
        }
    });
    this.color = colour;
    this.hue = hue(this.color) / 255;
    this.sat = saturation(this.color) / 255;
    this.bri = brightness(this.color) / 255;

    this.defaultCol = color(250);
    this.updateFunction = updateFunction;
    
    if (this.updateFunction) { this.updateFunction(); }
    
    this.showSwatch = false;
    this.sx = this.x + this.w + 16;
    this.sy = this.y - 4;
    this.sx2 = this.sx + SWATCHSIZE;
    this.sy2 = this.sy + SWATCHSIZE;
};
SwatchButton.prototype = Object.create(Button.prototype);

SwatchButton.prototype.draw = function() {
    this.fade();
    
    fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
    noStroke();
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 8);
    
    fill(20);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    var txt = this.name + ":";
    text(txt, this.x + 3, this.y + this.h / 2 + 1);
    
    strokeWeight(1);
    stroke(20);
    fill(this.color);
    rect(this.x + textWidth(txt) + 8, this.y + 2, 16, 16);
    
    // TODO: make a swatch object
    if (this.showSwatch) {
        noStroke();
        fill(0,0,0,50);
        rect(this.sx, this.sy, SWATCHSIZE + 4, SWATCHSIZE + 30);
        fill(0);
        rect(this.sx - 2, this.sy - 2, SWATCHSIZE + 4, SWATCHSIZE + 30);
        image(swatch, this.sx, this.sy);
        
        if (this.mouseOverSwatch()) {
            colorMode(HSB);
            var hue = norm(mouseX, this.sx, this.sx2);
            var sat = norm(mouseY, this.sy, this.sy2);
            fill(hue * 255, sat * 255, this.bri * 255);
            rect(this.sx, this.sy2 + 2, SWATCHSIZE, 24);
            colorMode(RGB);
        } else {
            fill(255);
            textAlign(CENTER, CENTER);
            text("Pick a color", this.sx + SWATCHSIZE / 2, this.sy2 + 13);
        }
    }
};

SwatchButton.prototype.setColor = function() {
    colorMode(HSB);
    this.color = color(this.hue * 255, this.sat * 255, this.bri * 255);
    colorMode(RGB);
};

SwatchButton.prototype.findColor = function() {
    this.hue = norm(mouseX, this.sx, this.sx2);
    this.sat = norm(mouseY, this.sy, this.sy2);
};

SwatchButton.prototype.mouseOverSwatch = function() {
    return mouseX >= this.sx && mouseX <= this.sx2 &&
           mouseY >= this.sy && mouseY <= this.sy2;
};

SwatchButton.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
    if (this.showSwatch && !this.mouseOverSwatch()) {
        this.showSwatch = false;
    }
};

SwatchButton.prototype.mouseReleased = function() {
    if (this.selected && this.mouseOver()) {
        this.trigger();
    } else if (this.showSwatch) {
        if (this.mouseOverSwatch()) {
            this.findColor();
            this.setColor();
            if (this.updateFunction) {
                this.updateFunction(this.color);
            }
        } else {
            this.showSwatch = false;
        }
    }
    this.selected = false;
};
}
/*************************************************
 * GUI Slider
**************************************************/
{
var Slider = function(x, y, w, h, params) {
    // Size of ball
    this.ballR = 12;
    this.ballD = this.ballR * 2;
    
    x += this.ballR;
    w -= this.ballR * 2;
    
    var h = this.ballD + (params.name ? 16 : 0);
    y += h - this.ballR;
    
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    
    this.x2 = x + w;
    this.fill = params.fill || color(240);
    this.stroke = params.stroke || color(180);
    
    this.min = params.min || 0;
    this.max = params.max === undefined ? 1 : params.max;
    this.val = params.now === undefined ? this.min : params.now;
    this.decimalPlaces = params.decimalPlaces === undefined ? 0 : params.decimalPlaces;
    this.setValue(this.val);
    this.trigger();
};
Slider.prototype = Object.create(GUI_Component.prototype);

Slider.prototype.draw = function() {
    if (this.name) {
        fill(20);
        textSize(13);
        textAlign(CENTER, BASELINE);
        text(this.name,  this.x + this.w / 2, this.y - 15);
        //text(this.name + ": " + this.val,  this.x + this.w / 2, this.y - 14);
    }
    
    this.fade();
    fill(lerpColor(color(this.fill), color(this.stroke), this.transition / 10));
    stroke(this.stroke);
    strokeWeight(3);
    line(this.x, this.y, this.x2, this.y);
    ellipse(this.bx, this.y, this.ballD, this.ballD);
    
    fill(20);
    textSize(11);
    textAlign(CENTER, CENTER);
    text("" + this.val, this.bx, this.y);
};

Slider.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.bx, this.y) < this.ballR;
};

Slider.prototype.mousePressed = function() {
    if (this.mouseOver()) {
        this.selected = true;
        return true;
    }
};

Slider.prototype.mouseDragged = function() {
    if (this.selected) {
        this.bx = constrain(mouseX, this.x, this.x2);
        var p = pow(10, this.decimalPlaces);
        this.val = round(map(this.bx, this.x, this.x2, this.min, this.max) * p) / p;
        //this.trigger();
    }
};

Slider.prototype.mouseReleased = function() {
    if (this.selected) {
        this.trigger();
    }
    this.selected = false;
};

Slider.prototype.setValue = function(v) {
    this.val = constrain(v, this.min, this.max);
    this.bx = map(this.val, this.min, this.max, this.x, this.x2);
    this.trigger();
};

var ColorSlider = function(x, y, w, h, params) {
    Slider.call(this, x, y, w, h, params);
    //this.max = params.max || 255;
    this.saturation = params.saturation || 150;
    this.brightness = params.brightness || 180;
    this.setColor();
};
ColorSlider.prototype = Object.create(Slider.prototype);

ColorSlider.prototype.setColor = function() {
    colorMode(HSB);
    this.color = color(this.val, this.saturation, this.brightness);
    colorMode(RGB);
    this.R = red(this.color);
    this.G = green(this.color);
    this.B = blue(this.color);
};

ColorSlider.prototype.draw = function() {
    if (this.name) {
        fill(20);
        textSize(13);
        textAlign(CENTER, BASELINE);
        text(this.name,  this.x + this.w / 2, this.y - 15);
    }
    
    this.fade();
    fill(this.color);
    strokeWeight(4);
    stroke(this.stroke);
    line(this.x, this.y, this.x2, this.y);
    stroke(250);
    strokeWeight(1);
    ellipse(this.bx, this.y, this.ballD, this.ballD);
};

ColorSlider.prototype.mouseDragged = function() {
    if (this.selected) {
        this.bx = constrain(mouseX, this.x, this.x2);
        var p = pow(10, this.decimalPlaces);
        this.val = round(map(this.bx, this.x, this.x2, this.min, this.max) * p) / p;
        this.setColor();
    }
};

ColorSlider.prototype.trigger = function() {
    this.setColor();
};
}
/*************************************************
 * GUI Label
**************************************************/
var Label = function(x, y, w, h, name) {
    this.x = x + w / 2;
    this.x1 = x + 8;
    this.x2 = x + w - 8;
    this.y = y + h - 4;
    this.name = name;
};

Label.prototype.draw = function() {
    fill(40);
    textFont(sansFont, 16);
    textAlign(CENTER, BASELINE);
    text(this.name, this.x, this.y - 2);
    
    strokeWeight(1);
    stroke(40);
    line(this.x1, this.y, this.x2, this.y);
};
/*************************************************
 *      Toolbar
 * A container for buttons and sliders.
**************************************************/
{
var Toolbar = function(x, y, w) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = 8;
    this.components = [];
    this.labels = [];
};

Toolbar.prototype.draw = function() {
    fill(250);
    strokeWeight(1);
    stroke(180);
    rect(this.x, this.y, this.w, this.h, 8);
   
    this.components.forEach(function(p) { p.draw(); });
    this.labels.forEach(function(p) { p.draw(); });
};

Toolbar.prototype.add = function(type, params) {
    params = params || {};
    var h = params.h || 20;
    var component = new type(this.x + 5, this.y + this.h, this.w - 10, h, params);
    this.components.push(component);
    this.h += component.h + 8;
};

Toolbar.prototype.addLabel = function(name) {
    var h = 20;
    this.labels.push(new Label(this.x, this.y + this.h, this.w, h, name));
    this.h += h + 8;
};

Toolbar.prototype.addOptions = function(options) {
    var x = this.x + 3;
    var y = this.y + this.h + 2;
    var w = this.w - 6;
    var h = 22;
    
    for (var opt in options) {
        var button = new CheckBox(x, y, w, h, opt);
        this.components.push(button);
        y += h + 5;
        this.h += h + 5;
    }
    
    this.h += 2;
};

Toolbar.prototype.addSwatch = function(name, colour, trigger) {
    var h = 20;
    var button = new SwatchButton(this.x + 5, this.y + this.h, this.w - 10, h, name, colour, trigger);
    this.components.push(button);
    this.h += h + 8;
    return button;
};

Toolbar.prototype.mousePressed = function() {
    this.components.forEach(function(p) { p.mousePressed(); });
};

Toolbar.prototype.mouseReleased = function() {
    this.components.forEach(function(p) { p.mouseReleased(); });
};

Toolbar.prototype.mouseDragged = function() {
    this.components.forEach(function(p) { p.mouseDragged(); });
};
}
/*************************************************
 *      Tabbed Toolbar
 * A container for toolbars
**************************************************/
{
var TabbedToolbar = function(x, y, w) {
    this.x = x;
    this.tx = x;
    this.y = y;
    this.w = 160;
    
    this.toolbars = [];
    this.tabs = [];
    this.currentTab = -1;
    this.components = [];
    this.labels = [];
};

TabbedToolbar.prototype = Object.create(Toolbar.prototype);

TabbedToolbar.prototype.draw = function() {
    // Background
    noStroke();
    fill(200);
    rect(this.x, this.y, this.w, 24);
    
    textFont(sansFont, 16);
    textAlign(LEFT, BASELINE);
    var tx = this.x;
    var ty = this.y + 22;
    
    // Draw tab
    if (this.currentTab !== -1) {
        var tab = this.tabs[this.currentTab];
        fill(250);
        noStroke();
        rect(tab.x + 1, tab.y, tab.w - 2, 26, 3);
    }

    this.components.forEach(function(p) { p.draw(); });
    this.labels.forEach(function(p) { p.draw(); });
};

TabbedToolbar.prototype.changeTab = function(n) {
    this.currentTab = n;
    this.components = this.tabs.concat(this.toolbars[n].components);
    this.labels = this.toolbars[n].labels;
};

TabbedToolbar.prototype.addTab = function(name, toolbar) {
    textFont(sansFont, 16);
    var w = textWidth(name) + 16;
    var index = this.tabs.length;
    var self = this;
    this.tabs.push(
        new GUI_Component(this.tx, this.y + 2, w, 20,
            name, function() {
                self.changeTab(index);
            }
        )
    );
    this.tx += w;
    
    this.toolbars.push(toolbar);
    if (this.currentTab === -1) { this.changeTab(0); }
};
}
}

// Get initial sites using Possion distribution
var possionDiscSampling = function(minDist) {
    // How many points we try before rejecting a point
    var k = 30;
    var maxDist = minDist * 2;
    var minDist2 = minDist * minDist;
    
    var x, y, i, j, p, d;
    // Final array of points that we'll return
    var points = [];
    
    // Points that we use to find neighbours
    var activePoints = [];
    
    // Start at a random point
    x = (0.2 + random() * 0.6) * imageWidth;
    y = (0.2 + random() * 0.6) * imageHeight;
    points.push([x, y]);
    activePoints.push([x, y]);
    
    var activeIndex, currentPoint, pointAdded, angle, collision;
    var d = 100;
    var w = imageWidth + d;
    var h = imageHeight + d;
    
    while (activePoints.length) {
        // Pick a random active point
        activeIndex = floor(random() * activePoints.length);
        currentPoint = activePoints[activeIndex];
        pointAdded = false;
        
        for (i = 0; i < k; i++) {
            angle = random() * 360;
            d = random(minDist, maxDist);
            x = currentPoint[0] + cos(angle) * d;
            y = currentPoint[1] + sin(angle) * d;
            
            if (x < -d || x > w || y < -d || y > h) {
                continue;
            }
            
            // Check distance from each other point is > minDist
            collision = false;
            for (j = points.length; j--;) {
                p = points[j];
                if ((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1]) < minDist2) {
                    collision = true;
                    break;
                }
            }
            
            if (!collision) {
                points.push([x, y]);
                activePoints.push([x, y]);
                pointAdded = true;
                break;
            }
        }
        
        // Failed to add point so remove it from the active list
        if (!pointAdded) {
            activePoints.splice(activeIndex, 1);
        }
    }
    
    return points;
};

/*********************************************************
 *       Site Object
 * Represents an initial point on the diagram.
 * Has methods to draw a parabola using the site
 * as a focus and the sweepline as a directrix.
*********************************************************/
{
var sortVertices = function(a, b) { return a.angle - b.angle; };
    
var Site = function(focus, id) {
    this.x = focus[0];
    this.x2 = this.x * this.x;
    this.y = focus[1];
    this.id = id;
    
    // Array of vertices that define the cell
    this.cell = [];    
};

Site.prototype.getCellProperties = function() {
    var vertices = this.cell;
    var n = vertices.length;
    this.numVertices = n;
    
    var i, vertex, dx, dy;
    var vertex2 = vertices[n - 1];
    
    // Find bounding box
    this.minX = vertex2.x;
    this.maxX = vertex2.x;
    this.minY = vertex2.y;
    this.maxY = vertex2.y;
    
    var x = this.x;
    var y = this.y;
    
    for (i = 0; i < n; i++) {
        vertex = vertices[i];
        dx = vertex.x - x;
        dy = vertex.y - y;

        vertices[i] = {
            angle: atan2(dy, dx),
            x: vertex.x,
            y: vertex.y,
            dx: dx,
            dy: dy
        };
        
        if (vertex.x > this.maxX) { this.maxX = vertex.x; }
        else if (vertex.x < this.minX) { this.minX = vertex.x; }
        if (vertex.y > this.maxY) { this.maxY = vertex.y; }
        else if (vertex.y < this.minY) { this.minY = vertex.y; }
    }
    
    vertices.sort(sortVertices);
    
    var vertex2 = vertices[n - 1];
    this.area = 0;
    for (var i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        this.area += vertex2.x * vertex.y - vertex.x * vertex2.y;
        vertex2 = vertex;
    }
};

Site.prototype.updateSize = function(d) {
    var vertices = this.cell;
    var n = vertices.length;
    var i, p2, p1 = vertices[n - 1];
    
    this.deltas = [];
    for (i = 0; i < n; i++) {
        p2 = vertices[i];
        p2.x1 = this.x + p2.dx * d;
        p2.y1 = this.y + p2.dy * d;
        this.deltas.push([p1.x - p2.x, p1.y - p2.y]);
        
        p1 = p2;
    }
};

Site.prototype.pointInArea = function(px, py) {
    // Bounding box test
    if (px <= this.minX || px >= this.maxX || py <= this.minY) {
        return false;
    }
    
    var i, d, p, cross, sign;
    for (i = this.cell.length; i--; ) {
        p = this.cell[i];
        d = this.deltas[i];
        cross = Math.sign(d[0] * (py - p.y) - d[1] * (px - p.x));
        if (!sign) {
            sign = cross;
        } else if (cross !== sign) {
            return false;
        }
    }

    return true;
};

Site.prototype.pointInArea2 = function(px, py) {
    var i, d, p, cross, sign;
    for (i = this.cell.length; i--; ) {
        p = this.cell[i];
        d = this.deltas[i];
        cross = Math.sign(d[0] * (py - p.y1) - d[1] * (px - p.x1));
        if (!sign) {
            sign = cross;
        } else if (cross !== sign) {
            return false;
        }
    }
    return true;
};

}
/*********************************************************
 *          Node object
 * Represents a node in the binary tree
 * Internal nodes represents breakpoint between
 * two arcs in the beachline (left and right).
 * Leaf nodes point to a parabola site and
 * represent an arc in the beachline.
*********************************************************/
{
var Node = function() {
    if (arguments.length === 1) {
        // Make an arc
        this.site = arguments[0];
    } else {
        // Make a breakpoint with the parameters as children
        this.setChild('left', arguments[0]);
        this.setChild('right', arguments[1]);
    }
};

Node.prototype.setChild = function(dir, child) {
    this[dir] = child;
    child.parent = this;
};

// Find the arc to the left of this breakpoint
Node.prototype.getLeftArc = function() {
    var node = this.left;
    while (!node.site) {
        node = node.right;
    }
    return node;
};

Node.prototype.getRightArc = function() {
    var node = this.right;
    while (!node.site) {
        node = node.left;
    }
    return node;
};

Node.prototype.getParent = function(dir) {
    var parent = this.parent;
    var parentLast = this;
    
    while (parent[dir] === parentLast) { 
        if (!parent.parent) { return; }
        parentLast = parent;
        parent = parent.parent; 
    }
    
    return parent;
};

Node.prototype.getY = function(x, y) {
    var d = this.site.y - y;
    var a = 0.5 / d;
    return a * x * x - 2 * a * this.site.x * x + a * this.site.x2 + y + 0.5 * d;
};

Node.prototype.finishEdge = function() {
    var edge = this.edge;
    if (edge) {
        var x = edge.dx < 0 ?
            max(imageWidth, edge.start.x + 100) :
            min(0, edge.start.x - 100);
        
        var p = { x: x, y: edge.getY(x) };
        edge.end = p;
        
        // Add vertex to cell
        edge.siteLeft.cell.push(p);
        edge.siteRight.cell.push(p);
    }
    
    if (!this.left.site) { this.left.finishEdge(); }
    if (!this.right.site) { this.right.finishEdge(); }
};
}
/*********************************************************
 *          Edge object
 * Represents an edge in Voronoi diagram
 * Edges are created whenever a breakpoint is created
 * They can be ended when a breakpoint is removed.
*********************************************************/
{
var Edge = function(start, siteLeft, siteRight) {
    this.start = start;
    this.siteLeft = siteLeft;
    this.siteRight = siteRight;
    
    // Direction vector
    this.dx = this.siteLeft.y - this.siteRight.y;
    this.dy = this.siteRight.x - this.siteLeft.x;

    // Constant term in line equation
    // y - y1 = (dy / dx)(x - x1) rearranged to
    //  dx(y) = dy(y) - dy(x1) + dx(y1)
    this.c = start.x * this.dy - start.y * this.dx;
    
    // TODO: fix for dy = 0
    this.grad = this.dy / this.dx;
};

Edge.prototype.getY = function(x) {
    return this.start.y + this.grad * (x - this.start.x);
};
}
/*********************************************************
 *          Voronoi object
 * Constructs the cells for a Voronoi diagram.
*********************************************************/
{
var sortSites = function(a, b) { return b[1] - a[1]; };
var sortEvents = function(a, b) { return b.site.y - a.site.y; };

var Voronoi = function(size) {
    this.events = [];
    this.edges = [];
    this.sites = [];
    this.edgeWidth = 0.9;
    
    var sites = possionDiscSampling(size);
    sites.sort(sortSites);
    
    // Add each site to the event queue
    // Add a cell for each site
    var site;
    for (var i = 0, len = sites.length; i < len; i++) {
        // Convert array of coordinates into a site object
        site = new Site(sites[i], i + 1);
        this.sites.push(site);
        
        this.events.push({
            site: site,
            newArc: true
        });
    }

    this.compute();
};

Voronoi.prototype.compute = function() {
    while (this.events.length) {
        var event = this.events.pop();
        this.sweepline = event.site.y;
        
        // Process event
        if (event.newArc) {
            this.insertArc(event.site);
        } else {
            this.removeArc(event);
        }
    }
    
    this.root.finishEdge();
    var i, len;
    for (i = 0, len = this.edges.length; i < len; i++) {
        if (this.edges[i].neighbour) {
            this.edges[i].start = this.edges[i].neighbour.end;
        }
    }
    
    // Sort cell vertices
    var minArea = 400 * 400;
    var maxArea = 0;
    var site;
    
    for (i = this.sites.length; i--;) {
        site = this.sites[i];
        site.getCellProperties();
        site.updateSize(0.9);
        // Only count cells completely on-screen
        if (site.minX > 0 && site.maxX < imageWidth &&
            site.minY > 0 && site.maxY < imageHeight) {
            if (site.area > maxArea) {
                maxArea = site.area;
            } else if (site.area < minArea) {
                minArea = site.area;
            }
        }
    }
    
    // Normalise areas
    //println(minArea + " " + maxArea);
    
    maxArea = min(maxArea, 3 * minArea);
    var areaNorm = 1 / (maxArea - minArea);
    
    for (i = this.sites.length; i--;) {
        this.sites[i].areaFactor = (min(maxArea, this.sites[i].area) - minArea) * areaNorm;
        //println(this.sites[i].areaFactor);
    }
};

// Add a new arc with its focus at the given site
Voronoi.prototype.insertArc = function(site) {
    // Create a new arc based on this site
    var newArc = new Node(site);
    
    // No need to do anything further with the first parabola
    if (!this.root) {
        this.root = newArc;
        return;
    }
    
    // Find leaf representing the arc above the new parabola
    var existingArc = this.getArcAbovePointX(site.x);
    
    // Split existing arc into two pieces
    var arc1 = new Node(existingArc.site);
    var arc2 = new Node(existingArc.site);
    var breakpoint = new Node(newArc, arc2);

    // Convert existing arc node to a breakpoint
    existingArc.setChild('left', arc1);
    existingArc.setChild('right', breakpoint);
    
    this.removeCircleEvent(existingArc);
    
    // Add a new edge
    var p = { x: site.x, y: existingArc.getY(site.x, this.sweepline) };
    var leftEdge = new Edge(p, existingArc.site, site);
    var rightEdge = new Edge(p, site, existingArc.site);
    
    leftEdge.neighbour = rightEdge;
    this.edges.push(leftEdge);
    existingArc.edge = rightEdge;
    breakpoint.edge = leftEdge;
    
    existingArc.site = false;
    
    // Check for new circle events
    this.checkForCircleEvent(arc1);
    this.checkForCircleEvent(arc2);
};

// Search binary tree for parabola covering given x-position
Voronoi.prototype.getArcAbovePointX = function(x) {
    var node = this.root;
    var p1, p2, d1, d2, a1, a2, a, b, c, discriminant, testX, x1, x2;
    
    // While we are not at a leaf in the tree (representing an arc).
    while (!node.site) {
        p1 = node.getLeftArc().site;
        p2 = node.getRightArc().site;
    
        // Coeffiecients for parabola equation in standard form
        d1 = p1.y - this.sweepline;
        d2 = p2.y - this.sweepline;
        
        a1 = 0.5 / d1;
        a2 = 0.5 / d2;
        
        a = a1 - a2;
        b = 2 * (a2 * p2.x - a1 * p1.x);
        c = a1 * p1.x2 - a2 * p2.x2 + 0.5 * (d1 - d2);
    
        discriminant = b * b - 4 * a * c;
        a *= 2;
        x1 = (-b + sqrt(discriminant)) / a;
        x2 = (-b - sqrt(discriminant)) / a;
        testX = p1.y > p2.y ? max(x1, x2) : min(x1, x2);
        node = testX > x ? node.left : node.right;
    }
    
    return node;
};

Voronoi.prototype.removeArc = function(event) {
    var arc = event.arc;
    var leftBreak = arc.getParent('left');
    var rightBreak = arc.getParent('right');
    var leftArc = leftBreak.getLeftArc();
    var rightArc = rightBreak.getRightArc();

    // Get point where the arc disappears
    var x = event.site.x;
    var p = { x: x, y: arc.getY(x, this.sweepline) };
    
    // Add a vertex to each of the cells
    arc.site.cell.push(p);
    leftArc.site.cell.push(p);
    rightArc.site.cell.push(p);
    
    // Add an end point to the two breakpoints that have joined

    leftBreak.edge.end = p;
    rightBreak.edge.end = p;
    
    this.removeCircleEvent(leftArc);
    this.removeCircleEvent(rightArc);
    
    // Find the higher breakpoint
    var higher;
    var parent = arc;
    while (parent !== this.root){
        parent = parent.parent;
        if (parent === leftBreak) { higher = leftBreak; }
        if (parent === rightBreak) { higher = rightBreak; }
    }
    
    higher.edge = new Edge(p, rightArc.site, leftArc.site);
    this.edges.push(higher.edge);

    // Remove leaf from tree and reorder
    var parent = arc.parent;
    var gparent = parent.parent;
    var d1, d2;
    
    if (parent.left === arc) {
        d2 = 'right';
        d1 = gparent.left === parent ? 'left' : 'right';
    } else {
        d2 = 'left';
        d1 = gparent.left === parent ? 'left' : 'right';
    }
    
    // Set new parents
    gparent.setChild(d1, parent[d2]);
    
    this.checkForCircleEvent(leftArc);
    this.checkForCircleEvent(rightArc);
};

Voronoi.prototype.checkForCircleEvent = function(b) {
    var leftBreak = b.getParent('left');
    var rightBreak = b.getParent('right');
    
    if (!leftBreak || !rightBreak) { return; }
    
    var a = leftBreak.getLeftArc();
    var c = rightBreak.getRightArc();
    
    if (!a || !c || a.site === c.site) { return; }
    
    //println(a + " " + b + " " + c);
    
    // Check whether edges of breakpoints intersect
    var e1 = leftBreak.edge;
    var e2 = rightBreak.edge;
    var den = e1.dx * e2.dy - e1.dy * e2.dx;
    
    // Lines are parallel
    if (!den) { return; }
    
    // Center circle at intersection point
    var ix = (e2.c * e1.dx - e1.c * e2.dx) / den;
    var iy = (e2.c * e1.dy - e1.c * e2.dy) / den;
    
    // Test whether edge is in the wrong direction
    if ((ix - e1.start.x) * e1.dx > 0 || (iy - e1.start.y) * e1.dy > 0 ||
        (ix - e2.start.x) * e2.dx > 0 || (iy - e2.start.y) * e2.dy > 0) {
        return;
    }

    var radius = dist(ix, iy, a.site.x, a.site.y);
    
    //println(radius);
    //println(ix + " " + iy);
    
    // Convert center to lower edge
    iy += radius;
    
    // Ignore circle if the sweep line has passed
    if (iy <= this.sweepline) { return; }
    
    // Create new event
    var event = {
        site: { x: ix, y: iy },
        radius: radius,
        arc: b
    };
    
    b.circleEvent = event;
    this.events.push(event);
    this.events.sort(sortEvents);
};

// Remove a circle event associated with the given arc
Voronoi.prototype.removeCircleEvent = function(arc) {
    //println("Remove circle event " + arc);
    if (arc.circleEvent) {
        //println("Removed");
        var index = this.events.indexOf(arc.circleEvent);
        if (index > -1) { this.events.splice(index, 1); }
        arc.circleEvent = null;
    }
};

Voronoi.prototype.getSiteAtPoint = function(x, y) {
    for (var i = this.sites.length; i--;) {
        if (y < this.sites[i].maxY && this.sites[i].pointInArea(x, y)) {
            // This is the site, is it the skin or scale?
            if (this.sites[i].pointInArea2(x, y)) {
                return this.sites[i];
            }
        }
    }
};

Voronoi.prototype.recalculateScaleSize = function() {
    var i, d = this.edgeWidth * 0.01;
    
    for (var i = this.sites.length; i--;) {
        this.sites[i].updateSize(d);
    }
};
}
/*********************************************************
 *      Create object
*********************************************************/

var ms = millis();
var voronoi = new Voronoi(50);
//println(millis() - ms);
noiseDetail(3, 0.6);

var imageOfScales;
var imageXi = 0;
var scaleAmplitudes = [0.5, 0.1, 0.25];
var skinAmplitudes = [0.4, 0.2, 0];
var scaleFrequencies = [1, 2, 4];

var getSkinFunction = function(i) {
    return function() {
        skinAmplitudes[i] = this.val;
        imageOfScales = false;
        imageXi = 0;
    };
};

var getScaleFunction = function(i) {
    return function() {
        scaleAmplitudes[i] = this.val;
        imageOfScales = false;
        imageXi = 0;
    };
};

var skinToolbar = new Toolbar(0, 22, 160);
var scaleToolbar = new Toolbar(0, 22, 160);
var toolbar = new TabbedToolbar(0, 0, 160);
toolbar.addTab('Skin', skinToolbar);
toolbar.addTab('Scale', scaleToolbar);

var skinHue, skinSat, scaleHue, scaleSat, scaleHue2, scaleSat2;

scaleToolbar.add(Slider, {
    name: 'Size',
    min: 50,
    now: 90,
    max: 100,
    trigger: function() {
        if (voronoi.edgeWidth !== this.val) {
            voronoi.edgeWidth = this.val;
            voronoi.recalculateScaleSize();
            imageOfScales = false;
            imageXi = 0;
        }
    }
});
skinToolbar.addSwatch(
    'Color',
    color(150, 120, 60),
    function() {
        skinHue = this.hue;
        skinSat = this.sat;
        imageOfScales = false;
        imageXi = 0;
    });
    
var skinSwatch = skinToolbar.components[0];
skinToolbar.add(Slider, {
    name: 'Brightness',
    now: 80,
    max: 255,
    trigger: function() {
        skinSwatch.bri = this.val / 255;
        skinSwatch.setColor();
        imageOfScales = false;
        imageXi = 0;
    }
});
    
scaleToolbar.addSwatch(
    'Color 1',
    color(80, 120, 140),
    function() {
        scaleHue = this.hue;
        scaleSat = this.sat;
        imageOfScales = false;
        imageXi = 0;
    });
    
var scaleSwatch1 = scaleToolbar.components[1];
scaleToolbar.add(Slider, {
    name: 'Brightness',
    now: 160,
    max: 255,
    trigger: function() {
        scaleSwatch1.bri = this.val / 255;
        scaleSwatch1.setColor();
        imageOfScales = false;
        imageXi = 0;
    }
});

// Add amplitude controls
for (var i = 0; i < 3; i++) {
    skinToolbar.add(Slider, {
        name: 'Resolution ' + (i + 1) + ' amplitude',
        min: 0,
        now: skinAmplitudes[i],
        max: 1,
        decimalPlaces: 2,
        trigger: getSkinFunction(i)
    });
    scaleToolbar.add(Slider, {
        name: 'Resolution ' + (i + 1) + ' amplitude',
        min: 0,
        now: scaleAmplitudes[i],
        max: 1,
        decimalPlaces: 2,
        trigger: getScaleFunction(i)
    });
}

toolbar.changeTab(0);

/*********************************************************
 *      Get image of tiles
**********************************************************/

var subdivideGrid = function(grid) {
    var w = grid.length;
    var h = grid[0].length;
    var splitGrid = [];
    
    // Split grid
    var i, j;
    var row, newRow, p2, p1;
    
    // For each row, add an element between each existing element, which is the mean of its neighbours
    for (i = 0; i < w; i++) {
        newRow = [];
        row = grid[i];
        p1 = row[h - 1];
        
        for (j = 0; j < h; j++) {
            p2 = row[j];
            newRow.push((p1 + p2) / 2, p2);
            p1 = p2;
        }
        splitGrid.push(newRow);
    }
    
    // Add a new row in between each row, which is the average of its neighbours
    var row2, row1 = splitGrid[0];
    h = splitGrid[0].length;
    
    for (i = w; i--;) {
        newRow = [];
        row2 = splitGrid[i];
        for (j = 0; j < h; j++) {
            newRow.push((row1[j] + row2[j]) / 2);
        }
        splitGrid.splice(i + 1, 0, newRow);
        row1 = row2;
    }
    
    // Average grid
    // For each element average it with each of its neighbours
    w = splitGrid.length;
    var d = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    var averageGrid = [];
    var v;
    
    for (i = 0; i < w; i++) {
        newRow = [];
        
        for (j = 0; j < h; j++) {
            v = splitGrid[i][j] +
                splitGrid[i][(j + 1) % h] +
                splitGrid[i][(j + h - 1) % h] +
                splitGrid[(i + 1) % w][j] +
                splitGrid[(i + w - 1) % w][j];
            v *= 0.2;
            newRow.push(v);
        }
        averageGrid.push(newRow);
    }
    
    return averageGrid;
};

var getRandomNumbers = function(n, m) {
    var grid = [];
    
    for (var i = 0; i < n; i++) {
        var row = [];
        for (var j = 0; j < m; j++) {
            row.push(random() - 0.5);
        }
        grid.push(row);
    }
    
    grid = subdivideGrid(grid);
    grid = subdivideGrid(grid);
    grid = subdivideGrid(grid);
    grid = subdivideGrid(grid);
    
    return grid;
};

var noiseGrid = getRandomNumbers(20, 20);

// Calculate noise at pixel
var i400 = 1 / 400;
var getNoise = function(x, y, amplitudes) {
    var gw = noiseGrid.length;
    var gh = noiseGrid[0].length;
    
    // Normalise (x, y) to (400, 400)
    x *= gw * i400;
    y *= gh * i400;
    
    var i, ix, iy, px, py, px1, px2;
    var v1, v2, v = 0;
    
    for (i = 0; i < 3; i++) {
        px = (x * scaleFrequencies[i]) % gw;
        ix = px | 0;
        px1 = noiseGrid[ix];
        px2 = noiseGrid[(ix + 1) % gw];
        ix = px - ix;
        
        py = (y * scaleFrequencies[i]) % gh;
        iy = py | 0;
        py -= iy;
        
        v += amplitudes[i] * (
            (px1[iy] * (1 - ix) + px2[iy] * ix) * (1 - py) + 
            (px1[(iy + 1) % gh] * (1 - ix) + px2[(iy + 1) % gh] * ix) * py);
    }
    
    // Convert v from range (-0.5, 0.5) to (0, 1)
    return v;
};

var setPixelHSB = function(pix, index, h, s, v) {
    var r, g, b;
    var i = floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }
    pix[index++] = r * 0xFF | 0;
    pix[index++] = g * 0xFF | 0;
    pix[index++] = b * 0xFF | 0;
};

var getImageOfScales = function() {
    loadPixels();
    
    var p = imageData.data;
    var y, n, n1, n2, site, i, f;
    var m = millis();
    var MAX_TIME = 120;
    var h, b;

    while (imageXi < imageWidth) {
        for (y = 0; y < imageHeight; y++) {
            i = width * y + imageX + imageXi << 2;
            
            // Get number of scale or false
            site = voronoi.getSiteAtPoint(imageXi, y);
            if (site) {
                f = 1 - site.areaFactor;
                n = getNoise(
                    site.id * 5.3 + imageXi,
                    site.id * 2.7 + y,
                    scaleAmplitudes);
                n1 = getNoise(abs(site.x * 0.1), abs(site.y * 0.1), [1, 0, 0]);
                n2 = getNoise(
                    site.id * 53 + imageXi,
                    site.id * 27 + y,
                    scaleAmplitudes);
                    
                h = (1 + scaleHue + n1 * 0.75 + n * 0.25) % 1;
                b = constrain(scaleSwatch1.bri * (n2 + 1), 0, 1);
                
                setPixelHSB(p, i, h, scaleSat * f, b);
            } else {
                n = getNoise(imageXi, y, skinAmplitudes);
                b = constrain(skinSwatch.bri * (n + 1), 0, 1);
                setPixelHSB(p, i, skinHue, skinSat, b);
            }
        }
        imageXi++;
        if (millis() - m > MAX_TIME) {
            updatePixels();
            return;
        }
    }
    
    imageXi = 0;
    updatePixels();
    
    return get(imageX, 0, imageWidth, imageHeight);
};

/*********************************************************
 *      Main loop
**********************************************************/

draw = function() {
    if (!imageOfScales) {
        imageOfScales = getImageOfScales();
        return;
    }
    
    if (!swatch) {
        swatch = createSwatch(SWATCHSIZE, 0.8);
    }
    
    background(250);
    image(imageOfScales, imageX, 0);
    toolbar.draw();
};

/**************************************
 *  Event handling
***************************************/
{
keyPressed = function() {
    //voronoi.deleteSite();
};
    
mousePressed = function() {
    toolbar.mousePressed();
};

mouseDragged = function() {
    toolbar.mouseDragged();
};

mouseReleased = function() {
    toolbar.mouseReleased();
};

mouseOut = mouseReleased;
}
