/**************************************
 * Build an animation of a ball
 * 
 * - Allow keyframes to be dragged to a new frame.
 * - Option to choose linear or cubic
 * - Save keyframes
**************************************/

var BACKGROUND = color(250, 250, 250);
var BLUE = color(64, 95, 237);
var SKYBLUE = color(230, 240, 255);
var SKYBLUE2 = color(20, 100, 255);
var PINK = color(255, 0, 175);
var PINK_T = color(255, 0, 175, 80);
var GREEN = color(28, 173, 123);
var ORANGE = color(255, 165, 0);
var GREY = color(140, 140, 140);
var GRIDGREY = color(230, 240, 230);
var TEXTCOL = color(20, 20, 20);
var TOOLBAR = color(235, 235, 235, 240);

var RESOLUTION = 20;

var sansFont = createFont("sans", 24);
var serifFont = createFont("serif", 24);

frameRate(24);
var FRAMES = 24;

var removeButton, speedSlider;

// Linear interpolation of the values of an array between two indices
var interpolate = function(arr, index1, index2) {
    var d = index2 - index1;
    var v1 = arr[index1];
    var v2 = arr[index2];
    
    for (var i = 1; i < d; i++) {
        arr[index1 + i] = lerp(v1, v2, i / d);
    }
};

var parabolicSpline = function(p1, p2, p3, t) {
    var rx = lerp(p1.x, p3.x, t);
    var ry = lerp(p1.y, p3.y, t);
    var sx = lerp(p3.x, p2.x, t);
    var sy = lerp(p3.y, p2.y, t);
    return {
        x: lerp(rx, sx, t),
        y: lerp(ry, sy, t),
    };
};

var cubicSpline = function(p1, p2, m1, m2, t) {
    var t2 = t * t;
    var t3 = t * t2;
    
    var a = -1 * t3 + 3 * t2 - 3 * t + 1;
    var b = t3;
    var c =  3 * t3 - 6 * t2 + 3 * t;
    var d = -3 * t3 + 3 * t2;
    
    return {
        x: p1.x * a + p2.x * b + m1.x * c + m2.x * d,
        y: p1.y * a + p2.y * b + m1.y * c + m2.y * d
    };
};

/*********************************************
 *      Creating sprites
**********************************************/
var sprites = [];
var spritesLoaded = 0;
var ballSprite = {
width: 64, height: 64, f: function() {/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ŉŉĿ5ÂÝĊs¾ßĔ_^ÝĔ‐`Óđ—Îéÿ+ĺĳàW!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!€éĘA“âĚe‒çĝ=‘âěÜ”âĜĕ“âĚŅ]áěŉ]âĚŉ]ãĚŉ[áĜŉÕýÚŉĩĥwŉĥĢxŉģĠzŉĢğ)ığĜ@úğĜ/¿ĜĚ>vėĕ=R!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!°æĘV‘äĞÒ”æĠē‘æĠĹ“æĠŉ”æġŉ‘æġŉ”æġŉ”åĠŉ“äĞŉ_ãğŉÈøñŉįĩwŉīħwŉĪĦxŉħĤyŉĥĢyŉģğzŉĠĝzŉĜę%ŉĚĘ&ħĖĔ(øĔē[^!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!♣åĖM”åğò”èĢŉ‘êĤŉ‘êĤŉ‘êĤŉ”êĤŉ‘éģŉ‘èĢŉ”çġŉ”çġŉ”æĠŉ‘æĜŉāĔµŉĮĩwŉĭĨwŉīħxŉĪĦxŉĨĤyŉĥĢzŉĤġzŉġĝzŉĜę#ŉĚĘ$ŉĖĔ$ŉđď@ĵĐĎ^“ĠĞ»2!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!–ãěb’éĢÙ”êģŉ‘ìĥŉ’ìĥŉ‘ìĥŉ‘ëĥŉ‘ëĥŉ”ëĥŉ”ëĤŉ”ëĤŉ‘éģŉ‘çĢŉ”æĠŉ™ìđŉġģ:ŉĮĩwŉĮĩwŉĬĨwŉīħxŉĨĤxŉĨģyŉĤġzŉģĠzŉĠĜ#ŉĜę#ŉĚĖ$ŉėĔ$ŉđĐ%ŉčċ@ėĈĆ<=åôÿ3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!©íĕÀ‘ëĤĲ’ìĦŉ’îĦŉ’îħŉ’íĥŉ’íĥŉ’íĥŉ‘íĦŉ‘ìĥŉ‘ëĥŉ‘ëĤŉ‘êĤŉ‘èĢŉ‘èĢŉ¢ñĆŉĶĮrŉįĪwŉĮĩwŉĭĨwŉĭĨwŉĪĦxŉĨĤyŉħĤyŉĤĠzŉĢğzŉĞězŉěĘ$ŉęĖ$ŉĖē$ŉđď%ŉČĊ"ņĄā@ąöõ½H!!!!!!!!!!!!!!!!!!!!!!!!!!!!ĹĴ©EďĞµÿ¼òĘŉ’îħŉ–îħŉ–îĦŉ–îħŉ–îħŉ–îħŉ–îĦŉ–íĦŉ’ìĦŉ’ìĥŉ‘ìĥŉ‘ëĥŉ”êĤŉ“èĤŉÓÿìŉķįoŉįĪwŉįĪwŉĭĩwŉĭĨwŉīħxŉĩĥxŉħģyŉĤĢzŉģğzŉĠĜzŉĜę#ŉĚė$ŉėĔ$ŉĔĒ%ŉđĎ%ŉċĉ&ŉýý@Ňçä]#!!!!!!!!!!!!!!!!!!!!!!!!!!ĵı*zķĲzĪéČ×ŉ`íĬŉ–ïĨŉ–ïĨŉ–ïħŉ—îĦŉ–îħŉ–îħŉ–îħŉ–îĦŉ–ìĥŉ’íĥŉ’ìĥŉ‘êĤŉ‘êģŉ`çħŉîČÍŉĵĮqŉįīwŉįĪwŉĮĩwŉĭĨwŉĬĨwŉĪĦxŉĨĤyŉĥĢyŉĤĠzŉġĞzŉĝĚ#ŉěĘ$ŉęĖ$ŉĕē%ŉĒĐ%ŉĎČ%ŉĊĈ&ŉüú"ŉää+Ç!!!!!!!!!!!!!!!!!!!!!!!!ĶĲ:zĶıxľľĵoŉ®ðĞŉ–ïĩŉ—îħŉ–ïħŉ–îħŉ–íĦŉ–íĦŉ–íĥŉ–ìĥŉ–íĦŉ–íĥŉ–ìĥŉ’ìĥŉ’ìĥŉ‘ëĤŉ^çĨŉāĕ«ŉĵĮrŉİīwŉįĪwŉĮĩwŉĭĨwŉĭĨwŉĪĦxŉĨĤyŉĦģzŉĤĠzŉĢğzŉĞě#ŉěę#ŉĘĔ#ŉĘĚ$ŉĔĒ%ŉĐč%ŉċĉ&ŉĆĄ&ŉùø"ŉÝÝ+ô!!!!!!!!!!!!!!!!!!!!!!ĵı,#ķıwŉĸĳrŉĪĪ<ŉ;éĲŉ–ïħŉ–îĦŉ–îħŉ–íĦŉ–ìĥŉ–íĥŉ–îĦŉ–íĥŉ–ìĥŉ–íĥŉ–ìĥŉ–ìĥŉ–êĤŉ’êĤŉ^èĪŉČě¼ŉĴĮsŉİĬvŉįīwŉĮĩwŉĮĩwŉĭĨwŉĪħxŉĨĤxŉĦģzŉģĠzŉģĠzŉğě#ŉĜę#ŉĒĄzŉüÀuŉāÙxŉČĀ$ŉčĊ&ŉĉć&ŉĀÿ"ŉóó"ŉæç*ôÏËÖ3!!!!!!!!!!!!!!!!!!!ĶĲ,(ķĲwŀķĲtŉļĴoŉĀĘÂŉ^ìĮŉ–îĦŉ–îĦŉ–îĦŉ–îĦŉ–íĦŉ–íĥŉ–ìĥŉ–íĥŉ–íĦŉ–îĦŉ–îĦŉ–îĦŉ–íĦŉ’ëĥŉ]èĪŉđĞ™ŉĴĮsŉıĬvŉįĪwŉĮĩwŉĭĩwŉĭĨwŉĪħxŉĨĤyŉħģyŉĤġzŉģĠzŉĠĜ#ŉĜę#ŉĚę$ŉĖĒ$ŉýÆuŉæusŉð°wŉüàzŉąĆ"ŉùø"ŉïï"ŉâã,Ý!×Ø;1!!!!!!!!!!!!!!!!Ĺĳ©IĶĲyĳķĲtŉĸĲtŉĿĶmŉåċáŉ“íĬŉ–îĦŉ–îĦŉ–íĦŉ–íĦŉ–îĦŉ–îĦŉ–íĦŉ–íĦŉ–íĦŉ–îĦŉ–îħŉ–îĦŉ–îĦŉ–îĦŉ]êīŉĕĠ°ŉĴįsŉıĬvŉįīwŉĮĪwŉĭĩwŉĬĨwŉīħxŉĨĤxŉħĤzŉĤġzŉģĠzŉğĜ#ŉĜę#ŉěĘ$ŉĘĖ$ŉĕē$ŉĂàwŉäutŉávsŉà+rŉøñ&ŉñò"ŉðï&ŉÖ×<♠!!!!!!!!!!!!!!!!Ĺĸŉ1ĶĲ$ēķĲsŉĸĲtŉĸĳtŉŁķkŉÎāøŉ”íĪŉ–îĦŉ–íĦŉ–îĦŉ–îĦŉ–îĦŉ–îĦŉ–îĦŉ–îĦŉ–îĦŉ–îĦŉ–îħŉ–îħŉ–îħŉ–îħŉ_ìĭŉēğ™ŉĵįsŉıĬvŉįīwŉįĪwŉĮĩwŉĬĨwŉīħxŉĨĤxŉħģzŉĤġzŉģğzŉğĜ#ŉĜę#ŉĚĘ#ŉĘĖ$ŉĖē$ŉĕė&ŉĀÝxŉã#uŉÚlpŉÒksŉÝ£zŉîé&ňíï"ŉÕÓ:"!!!!!!!!!!!!!!!Ķı%áķĲsŉĸĲtŉĸĳtŉĸĳtŉńĸhŉÁûĎŉ‘íĩŉ–îħŉ–îĦŉ–îĦŉ–îħŉ—îħŉ—îĦŉ—îĦŉ—ïħŉ—îĦŉ–îĦŉ–îĦŉ–îĦŉ–îħŉ–îħŉ`íĭŉĎĞ½ŉĵİsŉıĭvŉįīvŉĮĪwŉĮĩwŉĬĨwŉīħxŉĨĤyŉħģyŉĤġzŉģĠzŉğĜ#ŉĜę#ŉěĘ$ŉĘĖ$ŉĖē$ŉĒď%ŉđĒ%ŉĀç#ŉÜqpŉÖrsŉËuwŉÈ/yŉéà$ŉäã(ğ¢;zH!!!!!!!!!!!!!ĶĲ:yķĲwĽĸĲtŉĸĳtŉĸĳtŉĹĳtŉņĹgŉ†õĒŉ’îħŉ–îĦŉ–îĦŉ—îħŉ‐ïħŉ…ïħŉ‐ðħŉ‐ïħŉ…ïħŉ…ïħŉ…ïħŉ–îĦŉ—íĦŉ–îĦŉ–îħŉ“íĭŉĉĜ€ŉĵįrŉıĭvŉıīvŉĮĪwŉĮĩwŉĭĨwŉĪĦxŉĨĤyŉĦĢzŉĤġzŉģĞzŉğĜ#ŉĜę#ŉěĘ$ŉĘĖ$ŉĖĔ$ŉĒĐ%ŉďč%ŉČċ&ŉöÑxŉ×tuŉÎxuŉÂxwŉ¿tyŉÜ¿yŉÃ–@Ê!!!!!!!!!!!!!ĶĲ&ĂķĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳsŉŇĹgŉ†ôĒŉ’íħŉ–îĦŉ…îħŉ‒ðħŉ™ñĨŉ⅔óĩŉµõĪŉ¢öĪŉ†ôĩŉ½òĩŉ°ðħŉ…ïħŉ—îĦŉ—îĦŉ–îĦŉ“íĬŉüėÄŉĶİrŉıĭvŉİĬwŉĮĪwŉĮĩwŉĬĨwŉĪĦxŉĨĤyŉĦģzŉĤġzŉĢğzŉĞě#ŉĜę#ŉĚė$ŉĘĕ$ŉĕē%ŉĒĐ%ŉďč%ŉċĉ&ŉĉČ"ŉê»wŉÌouŉÃxwŉÃxxŉÂyyŉÀzwŉ¾[>d!!!!!!!!!!!ĶĲ“@ķĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳsŉĺĳsŉŇĹgŉ‡ôđŉ’íħŉ…îĦŉ©ñĨŉ‡ôĩŉÁúĬŉËþĭŉÒĂįŉÑĂĮŉËÿĭŉÁúĬŉ‡ôĪŉ©ðħŉ…îĦŉ—îĦŉ—îĦŉ”íīŉîďÖŉĸıqŉĲĭvŉİīwŉĮĩwŉĭĨwŉĭĨwŉĪĦxŉħĤyŉĥĢzŉģĠzŉĢğzŉĞě#ŉěę#ŉęė$ŉėĕ$ŉĕē%ŉĒĐ%ŉĐč%ŉċĉ&ŉćĆ"ŉĀĀ"ŉÜ©xŉÂtwŉÂxwŉÂxwŉÃywŉ£xzė!!!!!!!!!!!ĶĲ&ĩķĲsŉĸĲtŉĸĳtŉĸĳtŉĺĳsŉĺĳsŉņĹgŉ♣÷Đŉ–íħŉ©ðħŉ£öĪŉËĀĮŉàĊıŉðđĴŉöĔĶŉõēĵŉêĎĲŉÚĆİŉÆüĬŉ‡ôĩŉ°ðħŉ…îĦŉ…îĦŉ‘íĩŉÜćëŉĺĲoŉĲĭvŉİīwŉĮĩwŉĭĨwŉĬĨwŉĨĥxŉħģyŉĥĢzŉģĠzŉġĝzŉĝĚ#ŉěĘ#ŉęė$ŉėĕ$ŉĔĒ%ŉĒď%ŉĎČ&ŉċĉ&ŉĆą"ŉĀÿ"ŉóë&ŉÇ*xŉÂxwŉÂxwŉÂxwŉÃyxŃ¾&",!!!!!!!!!ıħ?[ķĲtŉķĲtŉĸĳtŉĹĳtŉĹĳtŉĹĳsŉĺĳsŉŅĹhŉÉýĆŉ—íĨŉµõĩŉÎāįŉéďĴŉĂĜĹŉĒĥļŉĘĪľŉĕħĽŉĉğĺŉóĒĴŉÚąİŉÂúĬŉ½òĨŉ…îĦŉ‐ïħŉ’îħŉÇýÿŉļĳmŉıĭvŉİīwŉĮĪwŉĭĨwŉīħxŉĨĥyŉħģyŉĤġzŉģĠzŉġĝzŉĜę#ŉĚĘ#ŉęĖ$ŉėĕ$ŉĔĒ%ŉĒď%ŉĎČ&ŉċĈ&ŉĆą"ŉÿÿ"ŉøø"ŉÜÀ#ŉÁvwŉÂxwŉÂxwŉÂxwŉ♥#$ë¾’“4!!!!!!!!ħĊwýķĲtŉķĲtŉĸĳtŉĹĳtŉĹĳsŉĺĳsŉĺĳsŉłĸjŉØąõŉ®ðīŉÅüĮŉåČĳŉĆğĺŉĝĭĿŉĬĶŃŉİĹńŉīĶŃŉğĭĿŉĊĠĺŉëĎĳŉÍÿĮŉµõĪŉ‒ðĨŉ‐ïħŉ—ïħŉ€øďŉĸısŉıĭvŉįĪwŉĮĩwŉĭĨwŉīħxŉĨĤyŉĦģyŉĤĠzŉĢğzŉĠĜzŉĜę#ŉĚĘ$ŉĘĖ$ŉĖĔ%ŉēđ%ŉđď%ŉĎČ&ŉĊĈ&ŉĆĄ"ŉÿþ"ŉöô"ŉóõ"ŉÉ,wŉÁwxŉÂxwŉÂxwŉ♦#zķ£$%I!!!!!!!ĎÊ"TıġwĪķĲtŉĸĲtŉĸĳtŉĹĳtŉĺĳsŉĺĳsŉĻĴsŉŁķkŉìĎæŉ⅓óįŉÔĄİŉùėķŉęĪľŉĮĸŃŉĻŁņŉĿńňŉĺŀņŉĭķŃŉėĨĽŉ÷ĕĵŉÕĄİŉ«÷īŉ°ñĨŉ‐ïħŉ…ïħŉ⅓õĔŉĮĬ"ŉıĬwŉįīwŉĮĩwŉĬĨwŉĪĦxŉĨĤyŉĦģyŉģĠzŉĢĞzŉğězŉěĘ#ŉęė$ŉĘĖ$ŉĕĔ%ŉēđ%ŉđĎ%ŉčĊ&ŉĉć&ŉąă"ŉýü"ŉõó"ŉñò"ŉèÞ"ŉÀqvŉÂxwŉÂxwŉÀwvŉ»;:_!!!!!!!Ĥā"(ĳĨtŉķĲtŉĸĲtŉĹĳtŉĹĳtŉĺĳsŉĺĳsŉĻĴsŉŀĶmŉýėÏŉ¢öĲŉàĊĲŉĆĞĹŉĤıŁŉĸĿņŉńŇŉŉňŉŉŉŁŅňŉĲĻńŉěĬĿŉûėķŉ×ąİŉ♠øīŉ°ñĨŉ‐ïħŉ—ïħŉ¼óęŉĞĤ[ŉıĬvŉįĪwŉĮĩwŉīħxŉĩĥxŉħĤyŉĤġzŉģĠzŉġĝzŉĝĚ#ŉĚę$ŉęĖ$ŉėĕ$ŉĕē%ŉĒď%ŉĐč%ŉČĊ&ŉĈć&ŉăĂ"ŉüû"ŉóò"ŉòò"ŉçÛ%ŉÀrwŉÂxwŉÂxwŉÃxwŉ♠$%Ď!!!!!!!Ĩď%ÕķĳtŉĸĲtŉĸĳtŉĹĳtŉĹĳtŉĺĳsŉĺĳsŉĻĴsŉľĵnŉĖĢ♥ŉ¢öĴŉãČĳŉĉĠĺŉħĳŁŉĺŀņŉŅňŉŉňŉŉŉĿńŇŉİĹŃŉęĩľŉõĔĵŉÔăİŉ€÷īŉ‒ðĨŉ‐ïĦŉ–íĦŉ©ðĞŉĎĝ•ŉİīwŉĮĪwŉĭĨwŉīħxŉĩĥxŉĦĢyŉĤġzŉģğzŉğĜ#ŉĜę#ŉĚė$ŉęĖ$ŉĖĔ$ŉĔĒ%ŉĒď%ŉďČ%ŉċĉ&ŉćĆ&ŉĂā"ŉûú"ŉñð"ŉóö(ŉÇ*xŉÂwxŉÂxwŉÂxwŉÂxwŉ♥vvŉıŉŉ3!!!!!!ĲĦ%ĝķĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳsŉĺĳsŉĺĳsŉĻĴsŉļĵpŉįĮ‘ŉ⅔õĵŉáċĲŉĄĞĹŉġįŀŉĴĻŅŉĽłŇŉĽŃŇŉķļŅŉĦĲŁŉČĢĻŉëĎĳŉËþĮŉ⅔óĩŉ‐îĦŉ…íĦŉ—íĥŉ–ìĤŉĀĖ♣ŉįĪwŉĮĩwŉĭĨxŉĪĦxŉĨĤxŉĥĢzŉĤĠzŉġĞzŉĞě#ŉěę#ŉĚė$ŉĘĖ$ŉĖĔ$ŉēĐ%ŉđď%ŉčċ%ŉĊĈ&ŉĆĄ"ŉĀÿ"ŉù÷"ŉññ"ŉÛÀ$ŉÂvwŉÂxwŉÂxwŉÂxwŉÂxwŉÃzxŉ¾)@=!!!!!!ĴĮvŉĸĲtŉĸĲtŉĸĳtŉĹĳtŉĹĳsŉĺĳsŉĻĴsŉĻĴsŉĻĴsŉĿĵvŉ†ôĶŉ×ĆıŉøĖĶŉĔħĽŉĥıŁŉĭķŃŉĭķŃŉĤıŀŉĔĦļŉùĖĶŉÙąİŉ¿ùīŉ™ðĨŉ…îĦŉ—íĦŉ–ìĥŉ”êĦŉìČÒŉįĪwŉĮĩwŉĬĨxŉĩĥxŉħĤyŉĥġzŉģğzŉĠĝzŉĜę#ŉěĘ#ŉęĖ$ŉėĕ$ŉĕē%ŉĒĐ%ŉĐč%ŉČĊ&ŉĊć&ŉąă"ŉþü"ŉöô"ŉëä&ŉÄ)yŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂyxŉ«%%Û!!!!!ĳĩ•mĶĲtŉĸĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳtŉĺĳsŉĺĳsŉĻĴsŉĻĴsŉĿĶoŉÁûģŉÈþįŉãċĲŉüĘķŉĎģĻŉĕĨĽŉĔĦļŉċĠĺŉùĖķŉßĈıŉÇüĬŉ†òĨŉ‐íĦŉ…íĦŉ—ëĤŉ’ëĤŉ‘êĥŉÓĀíŉĭĩyŉĮĩwŉīħxŉĩĥxŉĦģyŉĤĠzŉĢğzŉĞě#ŉĜę#ŉěĘ$ŉęĖ$ŉĖĔ$ŉēđ%ŉđď%ŉďč%ŉċĉ&ŉĉą&ŉĂā"ŉûú"ŉóô"ŉÍ“yŉÁvwŉÂxwŉÃxwŉÂxwŉÂxwŉÂxwŉÂxwŉ♣##č!!!!!Ĵį@®ķĲtŉķĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳtŉĺĳsŉĺĳsŉĻĴsŉĻĴsŉļĵqŉÓĄĂŉ£÷ĭŉÌĀĮŉàĉıŉïďĳŉõēĵŉôĒĴŉêčĳŉÙąįŉÇüīŉ¢óĨŉ°íĦŉ…ìĥŉ…ìĤŉ–êģŉ–ëĤŉ’êĥŉ€óĊŉĬĩzŉĭĩwŉīħxŉĨĤxŉĦģyŉĤĠzŉĢĞzŉĞě#ŉěę#ŉĚė$ŉĘĕ$ŉĕē$ŉĒĐ%ŉđĎ%ŉčĊ&ŉĊĈ&ŉĆĄ&ŉĀĀ"ŉúú"ŉÕ⅓yŉÀrwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉ♣wwĥŉŉŉ2!!!!Ķı,ÒķĲtŉķĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳtŉĺĳsŉĺĳsŉĺĳsŉĻĴsŉļĴrŉìďåŉ°ðĬŉ€öĩŉÅûĬŉÏÿĭŉÒāĮŉÑĀĮŉÉýĬŉ¿øĪŉ⅔òħŉ©íĥŉ…ìĥŉ…ìĤŉ–êģŉ–êģŉ’êģŉ’êģŉ[äĦŉīĨ"ŉĭĨwŉīħxŉĨĤyŉĥĢyŉģĠzŉġĞzŉĞĚ#ŉĚĘ#ŉĚė$ŉĘĕ$ŉĔĒ%ŉĒď%ŉďč%ŉČĉ&ŉĉĆ&ŉąă"ŉþý"ŉâÁ#ŉÂxyŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÁxxī=`‘I!!!!ĵİ,ôĶıtŉķĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳtŉĹĳsŉĺĳsŉĺĳsŉĺĳsŉĻĴsŉćěÃŉ”íīŉ®ðĨŉ¾òĨŉµôĩŉ«öĪŉ¢õĩŉ⅔òĨŉ™ïĦŉ‐ìĥŉ…ìĤŉ…ìĤŉ—ëĤŉ–êĤŉ’êģŉ’êĤŉ‘éģŉ<âĩŉČę½ŉĮĩuŉĪĦxŉĨĤxŉĤġzŉģĠzŉġĝzŉĜę#ŉěĘ$ŉęĖ$ŉėĔ$ŉĔĒ%ŉđď%ŉĎČ&ŉċĉ&ŉćą&ŉăĂ"ŉî×$ŉÅuxŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÂxwŉÃzyĲ«°–X!!!!ķĲ>ĊĶısŉķĲtŉĸĲtŉĸĳtŉĸĳtŉĸĳtŉĹĳsŉĹĳsŉĺĳsŉĺĳsŉĺĳsŉęĤ°ŉ‐ïĦŉ…îĦŉ‐îĦŉ‒ïĦŉ°ïħŉ‒ïħŉ‐îĥŉ…ìĥŉ—ëĤŉ…ëĤŉ—ëĤŉ–ëĤŉ’êĤŉ–êĤŉ’éĢŉ‘èĢŉ^åĦŉÙāáŉĲĪqŉĩĥxŉħģyŉĤġzŉģğzŉĠĜzŉĜę#ŉĚĘ$ŉęĖ$ŉĖĔ%ŉēĐ%ŉĒď%ŉčċ&ŉĊĈ&ŉĈĉ"ŉîÌyŉÏwuŉÃwxŉÁxwŉÁuxŉÁuwŉÁtwŉÁtwŉÁswŉÁrwŉÂwwŉÂxwŉÃ#yĶ†=“i!!!!ĶĲ?ĉĶıtŉķĲtŉķĲtŉĸĲtŉĸĳtŉĸĳtŉĹĳsŉĹĳtŉĹĳsŉĺĳsŉĺĳsŉĥĩ[ŉ⅔ôęŉ–îħŉ—îĦŉ…îĦŉ…íĦŉ—íĥŉ–ìĥŉ–ëĤŉ—ëĤŉ’êģŉ–êģŉ–ëĤŉ–ëĤŉ’êģŉ‘éĢŉ‘çĢŉ“æĢŉ…çđŉĸĮmŉĨĤxŉĦģyŉĤġzŉĢğzŉğĜ#ŉěę#ŉĚĘ$ŉęĖ$ŉĖĔ%ŉēĐ%ŉĐĎ%ŉčċ&ŉĊć&ŉñÆxŉÓotŉËtvŉÇ(vŉÊ<wŉÏ‘zŉÑ™#ŉØ£$ŉÛÂ$ŉÞÇ&ŉÞÉ%ŉÅ(wŉÂxwŉÃ##ĶÂ†`i!!!!Ķı:øĶıtŉķĲtŉĸĲtŉķĲtŉĸĳtŉĸĲtŉĸĳtŉĹĳsŉĹĳsŉĹĳsŉĹĳsŉĲį%ŉ♦úĉŉ–îĦŉ–íĦŉ–íĥŉ–ìĥŉ–ëĤŉ–ëĤŉ–ëĤŉ–êģŉ–êĤŉ’êģŉ–êĤŉ–êĤŉ‘éĢŉ‘çĢŉ”æġŉ“äĝŉ<ÞĞŉĝĠ<ŉĩĥwŉĥĢzŉĤĠzŉĢĞzŉĞě#ŉěĘ#ŉĚė$ŉėĖ$ŉĕē%ŉĒď%ŉĐč%ŉČĊ&ŉĈĆ&ŉýï&ŉýû%ŉúý(ŉøû(ŉõù(ŉóö"ŉòô"ŉòô"ŉòó"ŉòô"ŉïî"ŉÉ:yŉÂxwŉÆ(zĳûą‡b!!!!Ĵı/ÒĶıtŉķĲtŉķĲtŉĸĲtŉĸĲtŉĸĲtŉĸĳtŉĹĳtŉĸĳtŉĹĳtŉĹĳsŉľĵpŉÏā÷ŉ–íĦŉ–íĥŉ–ìĥŉ–ìĥŉ–ëĤŉ–êĤŉ–êĤŉ’êģŉ–êģŉ’êģŉ’éĢŉ‘éĢŉ‘èĢŉ”çġŉ“åğŉ`ãĚŉ^àęŉíĈÃŉīĦuŉĤġzŉĤĠzŉġĝzŉĝĚ#ŉěę$ŉęĖ$ŉėĕ$ŉĕĒ%ŉĒĐ%ŉďČ%ŉċĉ&ŉĈĆ&ŉăĂ"ŉûû"ŉ÷õ"ŉ÷õ"ŉöô"ŉóò"ŉòð"ŉñð"ŉññ"ŉññ"ŉïí"ŉÌ]yŉÂwwŉÈ,xĬçĔ‘J!!!!Ĵİ,™ĵıuŉķĲuŉķĲtŉķĲtŉĸĲtŉĸĲtŉĸĲtŉĸĲtŉĸĳtŉĸĳtŉĸĳtŉļĵpŉóđÐŉ’ëĦŉ–ìĥŉ–ëĤŉ–ëĤŉ–ëĤŉ–êĤŉ–ëĤŉ’êģŉ–êģŉ’éģŉ’éģŉ‘èĢŉ‘èĢŉ”åĠŉ`ãĜŉ_áęŉ^ßĕŉÂñîŉīĥuŉĤġzŉģğzŉĠĜ#ŉĜę#ŉĚė$ŉęĖ$ŉėĔ$ŉĔĒ%ŉđď%ŉĎČ%ŉċĉ&ŉćą"ŉāĀ"ŉûù"ŉùø"ŉùö"ŉ÷ö"ŉ÷ö"ŉõó"ŉóñ&ŉòñ"ŉññ"ŉïì"ŉÎ_yŉÁvwŉÉ_zĥĂŉŉ2!!!!ĳĭ‐pĵĲuŉĶıuŉķĲtŉķĲtŉķĲtŉĸĲtŉĸĲtŉĸĲtŉĸĲtŉĸĳtŉĸĳtŉĺĴrŉĝĥ’ŉ`éħŉ–ëĤŉ–ëĤŉ–ëĤŉ–ëĤŉ–êģŉ–êģŉ’éģŉ’éģŉ’éĢŉ‘èĢŉ‘çġŉ”æĠŉ`ãĜŉ`áęŉ^ßėŉ]Þĕŉ¼çÿŉęĝ/ŉĤĠzŉĢğzŉĞě#ŉĜę#ŉĚė$ŉĘĖ$ŉĖē$ŉēđ%ŉĐĎ%ŉčċ&ŉĊĈ&ŉąă"ŉÿÿ"ŉüú"ŉûù"ŉúù"ŉù÷"ŉøö"ŉøö"ŉõô"ŉóò&ŉòð"ŉïí"ŉÎ_yŉÀuyŉÔ»"Đ!!!!!!ĬęvŉĶĲuŉķĲuŉķĲtŉķĲtŉķĲuŉĸĲtŉĸĲtŉĸĲtŉĸĲtŉĸĲtŉĸĲtŉŁĶmŉ’êģŉ–ëĤŉ–ëĤŉ–ëĤŉ–êĤŉ’êģŉ–êģŉ’éĢŉ’éĢŉ‘èĢŉ‘çġŉ”æĠŉ“äĞŉ_âĚŉ_àėŉ]ßĕŉ]ÜĒŉ^ÝďŉĈē—ŉģĠzŉġĝzŉĝĚ#ŉěę#ŉĚė$ŉėĔ$ŉĕē%ŉēĐ%ŉĐč%ŉČĊ&ŉĈĆ"ŉĄĂ"ŉþþ"ŉýý"ŉýü"ŉüû"ŉûú"ŉù÷"ŉù÷"ŉùö"ŉöõ"ŉõó"ŉñí&ŉÍ[zŉ¿pyŉáÞ.Ü!!!!!!ĖÝxěķĳuŉĶıuŉĶıuŉķĲtŉķĲtŉķĲuŉĸĲtŉĸĲtŉķĲtŉķĲtŉĸĲtŉŀĶlŉÔĂðŉ“éĨŉ’êĤŉ–êģŉ’êģŉ’êģŉ’éģŉ’éĢŉ‘èĢŉ‘æġŉ”åĠŉ“äĝŉ`âĚŉ_àėŉ^ßĖŉ]Ýēŉ[ÜĒŉ:ØĔŉäĀÈŉģğyŉĠĜzŉĜę#ŉěĘ$ŉęĖ$ŉėĔ$ŉĔđ%ŉĒď%ŉďč%ŉċĈ&ŉĈĆ"ŉăĂ"ŉĀÿ"ŉþþ"ŉþý"ŉýü"ŉýû"ŉüú"ŉûù"ŉù÷"ŉù÷"ŉ÷õ"ŉóî"ŉÎ.wŉË=xŉÚç]?!!!!!!Ā,yÓĦăsŉĶĳuŉĶıuŉĶıuŉĶıuŉĶıuŉķĲuŉķĲuŉķĲuŉķĲuŉķĲtŉĺĳqŉĐĞ⅓ŉ=åĭŉ–êĤŉ–êģŉ’éģŉ’êģŉ‘èĢŉ‘èĢŉ‘çġŉ”åĠŉ“äĞŉ`âĚŉ_àĘŉ^ßĖŉ]ÞĔŉ]Üēŉ[Üđŉ>ÚĒŉ¼æùŉħġvŉĞě#ŉĜę#ŉĚė$ŉĘĕ$ŉĖĔ$ŉēđ%ŉđď%ŉĎċ%ŉĊĈ&ŉąĄ"ŉĂā"ŉĂā"ŉāĀ"ŉÿÿ"ŉþþ"ŉüý"ŉýü"ŉýû"ŉúù"ŉúø"ŉù÷"ŉöò&ŉÌywŉÙ♦$ŉØčĝ6!!!!!!ûpz%ýsrŉİģtŉĶĴuŉĶıuŉĶıuŉķĲuŉĶıuŉĶıuŉĶıuŉĶıuŉĶıuŉĶıuŉĴİyŉ–êġŉ’êĤŉ’êģŉ’èĢŉ‘èĢŉ‘èĢŉ‘çġŉ”æĠŉ“äğŉ`âĜŉ_áęŉ_àėŉ]Þĕŉ]Üēŉ]Ûđŉ?Ûđŉ?ÚĐŉ@Ôėŉēė=ŉğězŉěĘ$ŉĚė$ŉėĕ$ŉĔĒ%ŉēĐ%ŉĐč%ŉČĉ&ŉĉĆ&ŉąă"ŉĄă"ŉăĂ"ŉăĂ"ŉĂā"ŉāĀ"ŉÿþ"ŉþþ"ŉýü"ŉýü"ŉüû"ŉúø"ŉõð&ŉÌtuŉãÛ,ď!!!!!!!ø$yTúdoĩûfpŉĥþsŉĵĮuŉĶıuŉĶıuŉĶıuŉĶıuŉĶıuŉĶıuŉķĲuŉĵıuŉĳİxŉÎÿõŉ”èĥŉ’éĢŉ‘èĢŉ‘èĢŉ‘çġŉ”æġŉ”åĠŉ“ãĝŉ`áĚŉ_àĘŉ^ÞĖŉ]ÝĔŉ]ÜĒŉ?Ûđŉ?ÚĐŉ?Úďŉ<×ĒŉÍôØŉĤĞuŉĚĘ$ŉęĖ$ŉĖĔ%ŉēđ%ŉđĎ%ŉĎČ&ŉċĉ&ŉćĆ&ŉąĄ"ŉąă"ŉąă"ŉĄĂ"ŉăĂ"ŉĂā"ŉĂā"ŉĀÿ"ŉÿþ"ŉýü"ŉýü"ŉüü"ŉï×$ŉÙ”wŉàØ<—!!!!!!!!÷jsöúZoŉùXpŉĝåtŉĶĳuŉĵıuŉĵıuŉĵıuŉĶıuŉĵıuŉĵıuŉĵıuŉĶıuŉ÷ĒÉŉ”èĤŉ‘èĢŉ‘çġŉ‘çġŉ”åĠŉ“åĠŉ“ãĝŉ`âĚŉ_àĘŉ^ßĖŉ]ÝĔŉ[Üēŉ[Ûđŉ?ÚĐŉ?Úďŉ?Ùďŉ?ÙĎŉ[ÙĈŉĜĚ&ŉěė#ŉĘĖ$ŉĕē%ŉēĐ%ŉĐĎ%ŉčĊ&ŉĉć&ŉĈĆ&ŉĆĄ"ŉĆĄ&ŉąĄ"ŉąĄ"ŉąă"ŉăĂ"ŉăĂ"ŉăĂ"ŉāĀ"ŉĀÿ"ŉþý"ŉþā"ŉã⅓yŉäÁ$ĸøĀ”L!!!!!!!!ø%#/øbpŉĘÚrŉĳĮuŉĵıuŉĵıuŉĴıuŉĵıuŉĵıuŉĵıuŉĵıuŉĵıuŉĴıuŉĖġ—ŉ©ëĘŉ‘çġŉ‘æġŉ“åğŉ“åğŉ“ãĝŉ`âĚŉ_àĘŉ^ÞĖŉ]ÝĔŉ]Ýēŉ[Ûđŉ?ÚĐŉ?Ùďŉ?Ùďŉ?ÙĎŉ>Øčŉ>×ċŉéĀ€ŉěĘzŉĘĕ$ŉĔĒ%ŉĒď%ŉďČ%ŉċĉ&ŉĉć&ŉĉĆ&ŉĉą&ŉĆą"ŉĆĄ"ŉąĄ"ŉąĄ"ŉąă"ŉĄĂ"ŉăĂ"ŉĂā"ŉāĀ"ŉĀÿ"ŉāć(ŉ×$uŉ÷÷+îïï♥4!!!!!!!!!ĕâyĦĵĸvŉĳĮvŉĳįuŉĴİuŉĴİuŉĴİuŉĵıuŉĴıuŉĴİuŉĵıuŉĵıuŉĴİxŉµðĉŉ”æġŉ“åğŉ“äĞŉ“ãĜŉ_áĚŉ_àĘŉ^ßĖŉ]Þĕŉ]Üēŉ[Ûđŉ[ÚĐŉ?Ùďŉ?Ùďŉ?ÙĎŉ?ØĎŉ>Øčŉ=×Čŉ♥èäŉėĕ&ŉĖĔ$ŉĔđ%ŉđĎ%ŉčċ&ŉċĈ&ŉĊć&ŉĉć&ŉĉć&ŉĈĆ&ŉĉĆ&ŉĆą"ŉąĄ"ŉąĄ"ŉąă"ŉĄă"ŉăĂ"ŉĂā"ŉĂă"ŉôÜ$ŉíÎzŅúă_/!!!!!!!!!!ĵĺ‘zįĪxŉıĬvŉĲĭvŉĲĮvŉĲĮvŉĳįvŉĳįvŉĳĮvŉĲįvŉĳİvŉĳİvŉĺĳoŉçĈÖŉ^ãĠŉ“ãĝŉ`âěŉ_áęŉ_àĘŉ^ÞĖŉ]ÝĔŉ]Üēŉ[Ûđŉ[ÛĐŉ?Ùďŉ?Ùďŉ?Ùďŉ?ÙĎŉ?Øčŉ>×Čŉ=ÖĊŉ?ÖĄŉćč?ŉĕē$ŉĒĐ$ŉďč%ŉČĊ&ŉċĉ&ŉċĈ&ŉċć&ŉĊć&ŉĊć&ŉĉć&ŉĉĆ&ŉćĆ&ŉĆĄ&ŉąĄ"ŉąĄ"ŉąă"ŉĄĂ"ŉăĄ"ŉðÎxŉüþ.Ę!!!!!!!!!!!!Įĩ(ĀİīwŉıĬvŉĲĬvŉĲĭvŉĲĭvŉĲĮvŉĲĮvŉĲĮvŉĲĮvŉĲĮvŉĴİuŉĭī+ŉ;ÞĢŉ`áĚŉ_áęŉ_àėŉ^Þĕŉ]Ýēŉ]Üēŉ[ÛĒŉ[ÛĐŉ?ÚĐŉ?Ùďŉ?ÙĎŉ[ÙĎŉ?ÙĎŉ>Øčŉ>×ċŉ=Õĉŉ.ÒČŉÒòÌŉĖēzŉđď%ŉĎċ%ŉČĉ&ŉČĊ&ŉċĈ&ŉċĈ&ŉĊć&ŉĊć&ŉĊć&ŉĉć&ŉĉĆ&ŉĈĆ&ŉĆĄ&ŉąĄ"ŉąă"ŉĄă"ŉÿ÷%ŉþú&ŉýý‡e!!!!!!!!!!!!ĭĩ=uĮĩxŀįĪwŉİīvŉıīvŉıĬvŉĲĬvŉĲĭvŉĲĭvŉĲĭvŉĲĭvŉĲĮvŉĽĵmŉÈöñŉ[Þěŉ_ßĖŉ^Ýĕŉ]Üēŉ]ÛĒŉ[Ûđŉ[ÛĐŉ[Ûđŉ?Ùďŉ?ÙĎŉ?ØĎŉ?ØĎŉ?Øčŉ>×Čŉ?ÖĊŉ=Õĉŉ<ÓĈŉ/ÑĈŉďĎ)ŉĐĎ$ŉďČ%ŉČĊ&ŉČĊ&ŉċĊ&ŉČĉ&ŉċĉ&ŉĊĈ&ŉĊĈ&ŉĉĈ&ŉĊć&ŉĉć&ŉĉĆ&ŉćą&ŉĆĄ"ŉąă"ŉĄĂ"ŉāĀ=Ø!!!!!!!!!!!!!!īħ*ÜĮĩvŉĮĪwŉįĪwŉįĪwŉİīwŉİĬvŉİĬwŉıĭvŉıĬvŉĲĭvŉĳĮuŉęĠ’ŉ/Úĝŉ]ÝĔŉ]Üēŉ]Üēŉ[ÛĐŉ?ÚĐŉ[Úďŉ[Úďŉ[ÚĎŉ?Ùčŉ?Øčŉ>×čŉ>ÖČŉ=Öċŉ?Õĉŉ>ÕĈŉ;Óćŉ/ÑĉŉÀæÙŉĘđvŉďČ%ŉĎČ%ŉčċ&ŉČĊ&ŉČĊ&ŉČĊ&ŉČĉ&ŉċĈ&ŉĊĈ&ŉĊć&ŉĉć&ŉĉć&ŉĉĆ&ŉćą&ŉąĄ"ŉĄă@ģĂĂ—N!!!!!!!!!!!!!!!ĩĦ&ĠĭĨwŉĮĩwŉĮĪwŉįĪwŉįīwŉįĪwŉİĬwŉİīwŉıĬvŉĲĭvŉīĪ%ŉ»íøŉ]Üēŉ]ÛĒŉ[Ûđŉ[ÛĐŉ[Úďŉ?ÚĎŉ[ÚĎŉ?Ùčŉ?Ùčŉ?ØČŉ>ÖČŉ=ÖČŉ=Öċŉ>Õĉŉ>Õĉŉ<ÔĈŉ<ÒĆŉ?ÔĀŉÿĄ[ŉĐč%ŉďč%ŉčČ&ŉČĊ&ŉČĊ&ŉČĊ&ŉČĊ&ŉČĊ&ŉċĉ&ŉċĈ&ŉĊć&ŉĊć&ŉĉć&ŉĉĆ&ŉĆĄ(ŅāĀ^[!!!!!!!!!!!!!!!!ĩħ’QĩĦ#ĪĬĨwŉĭĩwŉĭĨwŉĮĩwŉįĪwŉĮĪwŉĮĩwŉįĪwŉİīwŉĲĭvŉéąËŉ^Üđŉ[ÚĐŉ[ÚĐŉ[Úďŉ[Úďŉ?ÚĎŉ?Účŉ?ØČŉ?ØĊŉ>×ċŉ>×Čŉ=Öċŉ=ÕĊŉ=Õĉŉ>ÕĈŉ;Óćŉ<ÒĆŉ<ÑąŉÉëÐŉĐč&ŉĐč%ŉďč%ŉĎČ%ŉčċ&ŉČĊ&ŉČĊ&ŉČĊ&ŉČĉ&ŉċĉ&ŉċĈ&ŉĊć&ŉĊć&ŉĈĆ"ŉĄĄ<♥!!!!!!!!!!!!!!!!!!ĦĤ_%ĨĤzŃĪħxŉĬĨxŉĬĨwŉĭĨwŉĭĨwŉĮĩwŉĮĩwŉĮĩwŉİīwŉĢĤ/ŉ_Ýčŉ[ÚĐŉ?ÚĐŉ[Ùďŉ?Ùčŉ?ÙČŉ?ØČŉ?Øċŉ?×Ċŉ?×Ċŉ=×ċŉ=ÕĊŉ=Õĉŉ=Õĉŉ=ÔĈŉ<Óćŉ<ÒĆŉ<Òąŉ/ÐĄŉąĉ;ŉđĎ%ŉĐč%ŉďČ%ŉďČ%ŉĎċ%ŉčċ&ŉČĊ&ŉČĉ&ŉČĊ&ŉċĉ&ŉĊć&ŉĊć&ŉĈć;ÕċČÊ1!!!!!!!!!!!!!!!!!!!ģĠ?^ĥĢzŀĨĤxŉĩĥxŉīĦxŉīħxŉīĨxŉīħwŉĬĨwŉĮĩwŉķįoŉ×úÛŉ;Øĕŉ?ÚĐŉ[Ùďŉ?ÙĎŉ?ØČŉ?Øċŉ?×Ċŉ>×Ċŉ>×Ċŉ=Öċŉ=ÕĊŉ=Õĉŉ<ÔĈŉ<Óćŉ<Óćŉ<ÒĆŉ;ÒĆŉ/Ðćŉ®Ýìŉēď$ŉĐč%ŉĐč%ŉďč%ŉĎČ%ŉčċ&ŉčċ&ŉČĊ&ŉČĊ&ŉČĊ&ŉċĉ&ŉĈĆ*ôČĔá4!!!!!!!!!!!!!!!!!!!!!Ģğ:)ģĠ%ĻĦĢyŉĦģyŉĨĤyŉĨĤyŉĩĥyŉĩĥyŉĩĥyŉīĦwŉĪħ$ŉ^ÛČŉ?ÙĐŉ?ÙĎŉ?ØĎŉ>×čŉ>×Čŉ>Öċŉ=Öċŉ=Öċŉ=ÕĊŉ=ÕĊŉ=Õĉŉ<Óćŉ<Óćŉ<Óćŉ;ÒĆŉ<ÒĆŉ;ÒĄŉ,ÏĈŉÈëÏŉĕĐyŉĐč%ŉĐč%ŉĐč%ŉĎČ%ŉĎċ%ŉČĊ&ŉČĊ&ŉċĉ&ŉĊĉ;ÛđĒÈ5!!!!!!!!!!!!!!!!!!!!!!!Ġğ”mğĜ&ľģğzŉģĠzŉĥġzŉĥĢyŉĦĢyŉĦģyŉĦģyŉĨĤxŉñć♦ŉ/Öēŉ?Øčŉ>×čŉ>×Čŉ=ÖČŉ=Öċŉ=ÕĊŉ=ÕĊŉ=ÕĊŉ=Õĉŉ<ÔĈŉ<Óćŉ;Óćŉ;Óćŉ;ÒĆŉ;Òąŉ;Òąŉ;ÑĄŉ=Òāŉìý½ŉĐĎ%ŉĐč%ŉĐč%ŉďč%ŉďČ%ŉĎČ%ŉČĊ"ŇČĊ;ÊĔē⅓2!!!!!!!!!!!!!!!!!!!!!!!!!ĢĞ€KĜĚ)ăĞě#ŉĠĝzŉġĝzŉĢĞzŉģğzŉĢğzŉģğyŉěě*ŉ¾äøŉ>×Čŉ=Öċŉ=Öċŉ=ÕĊŉ=Õĉŉ=Õĉŉ=Õĉŉ=Õĉŉ<Ôĉŉ<ÔĈŉ;Óćŉ<Óćŉ<ÒĆŉ;Òąŉ;Òąŉ;ÑĄŉ;ÑĄŉ/ÐĄŉ=Ñþŉïþ©ŉĖđxŉđč$ŉĐč%ŉĎČ%ŉčċ)ĭċċ=™!!!!!!!!!!!!!!!!!!!!!!!!!!!!ĠĜ—5Ěė>©ĘĖ"ŉěĘ#ŉĜę$ŉĜę$ŉĝĚ#ŉĝĚ#ŉğěyŉòĄ†ŉ/ÔĎŉ=ÕĊŉ<Õĉŉ<Ôĉŉ<ÔĈŉ=ÔĈŉ<ÔĈŉ<ÔĈŉ<Óćŉ<Óćŉ;ÓĆŉ;ÒĆŉ<Òąŉ;Òąŉ:ÑĄŉ:Ðăŉ:Ðăŉ:Ðăŉ:Ïăŉ>ÏüŉÈéËŉďĎ"ŉĒď#ŉčČ,õčč^W!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ĬĨÚ9ĖĔ*ÿėĔ%łĘĖ$ŉĘĖ$ŉęĖ$ŉęĖ$ŉĢětŉÁëÜŉ:ÓČŉ<Óćŉ<ÔĈŉ<ÔĈŉ<Óćŉ<Óćŉ<Óćŉ<Óćŉ<Óćŉ<ÒĆŉ<Òąŉ<Òąŉ;ÐĄŉ:Ðăŉ;Ñăŉ:Ðăŉ:Ðăŉ:Ðăŉ:ÍĀŉ.ÌĂŇ(Æÿį?Áï/!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ėĖ]#ėĕ)éĖĔ"ĻĖĔ$ŉėĔ$ŉėĔ$ŉęĕ#ŉ‡ãèŉ/Òĉŉ<ÒĆŉ;Óćŉ<Óćŉ<ÔĈŉ<ÓĆŉ;ÓĆŉ;ÒĆŉ;Òąŉ;Ñąŉ:Ðăŉ:Ðăŉ:Ðăŉ:Ðăŉ:Ðăŉ:Ðăŉ/ÍĀŉ;Èûĉ;Æ÷⅓Õ¢Ü4!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ģġ€3ĜĚ;MĘĖ:µėĕ*ĦĖĔ$ŉėĔ#ŉčĐ.ŉ…Ûôŉ;Òćŉ<ÒĆŉ;ÒĆŉ<Òąŉ;Ñąŉ;ÑĄŉ;ÑĄŉ:Ðăŉ:Ðăŉ:ÏĂŉ:ÏĂŉ:ÐĄŉ/Ïăŉ;ËþŇ;Çúß]Ëúg=♥íA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ğĞ‒Zėĕ>ÂĘĖ"ċĖĔ&ħ•ÝìĲ;ÑąĹ<ÑĄŁ<ÑĄŇ;ÑĄŉ;ÑĄŉ;ÏĂń;ÏĂļ:ÐĂĵ/ËþĬ/Êüě=ÇùÝ“Ãó(!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ĺĭ¢AĻĩwY…Öñq[Èû+^ÐĂ“<Ðă–>Ðă’`Íý=[Êúw=Áóf™♠éI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/}};

var createSprite = function(data, n) {
    var graphics = createGraphics(data.width, data.height, JAVA2D);
    var s = data.f.toString();
    var imgData = s.substring(15, s.length - 4);
    
    if (graphics) {
        graphics.background(0, 0, 0, 0);
        var img = graphics.get();
        var cxt = img.sourceImg.getContext("2d");
        var pixels = cxt.getImageData(0, 0, graphics.width, graphics.height);
        
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz#$%&"()@*+,./:;<=>?[]^_`“”‘’–—…‐‒°©®™•½¼¾⅓⅔†‡µ¢£€«»♠♣♥♦¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋŌō';
        var l = imgData.length;
        var x = 0;
        var i = 0;
        var char;
        
        for (i = 0; i < l;) {
            char = imgData.charAt(i++);
            if (char === '!') {
                // Transparent, so skip
                x += 4;
            } else {
                pixels.data[x++] = chars.indexOf(char);
            }
        }
        
        cxt.putImageData(pixels, 0, 0);
        graphics.image(img, 0, 0);
        sprites[n] = graphics;
        spritesLoaded++;
    }
};

/*********************************************
 *      Slider object
**********************************************/

var Slider = function(x, y, length, orientation, minValue, maxValue, nowValue, name, updateF) {
    this.x = x;
    this.y = y;
    this.length = length;
    this.orientation = orientation;
    
    if (this.orientation === 'vertical') {
        this.start = y;
        this.end = y + this.length;
        this.v1 = this.end;
        this.v2 = this.start;
    } else {
        this.start = x;
        this.end = x + this.length;
        this.v1 = this.start;
        this.v2 = this.end;
    }
    
    this.name = name;
    this.updateFunction = updateF;
    
    this.ballR = 8;
    this.ballD = this.ballR * 2;
    
    this.min = minValue;
    this.max = maxValue;
    this.value = nowValue || minValue;
    this.setValue(this.value);

    this.held = false;
};

Slider.prototype.draw = function() {
    strokeWeight(3);
    stroke(GREY);
    if (this.orientation === 'vertical') {
        line(this.x, this.y, this.x, this.end);
    } else {
        line(this.x, this.y, this.end, this.y);
    }
    
    strokeWeight(1);
    stroke(BACKGROUND);
    fill(ORANGE);
    if (this.orientation === 'vertical') {
        ellipse(this.x, this.ball, this.ballD, this.ballD);
    } else {
        ellipse(this.ball, this.y, this.ballD, this.ballD);
    }
    
};

Slider.prototype.mouseOver = function() {
    if (mouseX >= this.x - this.ballR &&
        mouseY >= this.y - this.ballR) {
        if (this.orientation === 'vertical') {
            return mouseX <= this.x + this.ballR &&
                   mouseY <= this.end + this.ballR;
        } else {
            return mouseX <= this.end + this.ballR &&
                   mouseY <= this.y + this.ballR;
        }   
    }
};
    
Slider.prototype.selected = function() {
    if (this.orientation === 'vertical') {
        this.held = dist(mouseX, mouseY, this.x, this.ball) <= this.ballR;
    } else {
        this.held = dist(mouseX, mouseY, this.ball, this.y) <= this.ballR;
    }
    if (!this.held && this.mouseOver()) {
        this.setBallPosition();
    }
};
    
Slider.prototype.mouseDragged = function() {
    if (this.held) {
        this.setBallPosition();
        return true;
    }
};

Slider.prototype.setBallPosition = function() {
    var value = this.orientation === 'vertical' ? mouseY : mouseX;
    this.ball = constrain(value, this.start, this.end);
    this.setValue();
};

Slider.prototype.setValue = function(d) {
    if (d !== undefined) {
        this.value = constrain(d, this.min, this.max);
    } else {
        
        this.value = round(map(this.ball, this.v1, this.v2, this.min, this.max));
        this.update();
    }
    this.ball = map(this.value, this.min, this.max, this.v1,  this.v2);
};

Slider.prototype.update = function() {
    if (this.updateFunction) {
        this.updateFunction(this.value);
    }
};

/*************************************************
 *  GUI Button
**************************************************/

var Button = function(x, y, w, h, name, clickFunction) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.name = name;
    this.defaultColor = color(140, 140, 140);
    this.highlightColor = color(40, 40, 40);
    this.showing = true;
    this.box = this.h - 6;
    this.clickFunction = clickFunction;
};

Button.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h);
};

Button.prototype.click = function() {
    if (this.clickFunction) {
        this.clickFunction();
    }
};

Button.prototype.mouseReleased = function() {
    if (this.mouseOver()) {
        this.click();
    }
};

Button.prototype.draw = function() {
    if (!this.showing) { return; }
    
    noFill();
    strokeWeight(1);
    stroke(this.defaultColor);
    if (!this.deactivated && (this.mouseOver() || this.selected)) {
        fill(TOOLBAR);
        stroke(this.highlightColor);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 8);
    
    if (this.deactivated) {
        fill(120);
    } else {
        fill(TEXTCOL);
    }
    
    textFont(sansFont, 13);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2);
};

// Circular button
var CircleButton = function(x, y, w, h, clickFunction, drawFunction) {
    Button.call(this, x, y, w, h, "", clickFunction);
    this.drawIcon = drawFunction;
};
CircleButton.prototype = Object.create(Button.prototype);

CircleButton.prototype.draw = function() {
    var c;
    if (this.mouseOver()) {
        c = color(40, 40, 40);
        fill(TOOLBAR);
    } else {
        c = color(140, 140, 140);
        noFill();
    }
    
    var x = this.x + this.w / 2;
    var y = this.y + this.w / 2;
    stroke(c);
    strokeWeight(2);
    ellipse(x, y, this.w, this.w);
    
    if (this.drawIcon) {
        fill(c);
        this.drawIcon(x, y, this.w / 2);   
    }
};

/*************************************************
 *      Draggable point
**************************************************/

var DraggablePoint = function(x, y, color) {
    this.x = x;
    this.y = y;
    this.r = 14;
    this.color = color || ORANGE;
    this.animation = 0;
    this.selected = false;
};

DraggablePoint.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.x, this.y) <= this.r / 2 + 1;
};

DraggablePoint.prototype.move = function() {
    this.x += mouseX - pmouseX;
    this.y += mouseY - pmouseY;
    this.onMove();
};

DraggablePoint.prototype.onMove = function() {
    // To be overwritten
};

DraggablePoint.prototype.draw = function() {
    if (this.selected || (!this.selected && this.mouseOver())) {
        if (this.animation < 5) {
            this.animation++;
        }
    } else {
        this.animation = 0;
    }

    stroke(BACKGROUND);
    strokeWeight(1);
    fill(this.color);
    
    var r = this.r + this.animation;
    ellipse(this.x, this.y, r, r);
    
    if (this.selected) {
        noFill();
        stroke(BACKGROUND);
        ellipse(this.x, this.y, r - 4, r - 4);
    }
};

var ConstrainedPoint = function(x, y, rangeX, rangeY, color) {
    DraggablePoint.call(this, x, y, color);
    this.minX = rangeX[0];
    this.maxX = rangeX[1];
    this.minY = rangeY[0];
    this.maxY = rangeY[1];
};
ConstrainedPoint.prototype = Object.create(DraggablePoint.prototype);

ConstrainedPoint.prototype.move = function() {
    this.x = constrain(this.x + mouseX - pmouseX, this.minX, this.maxX);
    this.y = constrain(this.y + mouseY - pmouseY, this.minY, this.maxY);
    this.onMove();
};

ConstrainedPoint.prototype.moveBy = function(dx, dy) {
    this.x = constrain(this.x + dx, this.minX, this.maxX);
    this.y = constrain(this.y + dy, this.minY, this.maxY);
};
/***********************************************
 *      KeyFrame
 * A point representing the value of an avar
 * at a given keyframe.
 * It can be moved vertically to change the value.
************************************************/

var KeyFrame = function(frame, value, avar, fixed) {
    this.frame = frame;
    this.value = value;
    this.avar = avar;
    this.fixed = fixed;
    this.color = ORANGE;
    this.animation = 0;
    this.r = 14;
    this.frameSelector = this.avar.timeline.frameSelector;
    
    this.handles = [];
    this.setPosition();
};

KeyFrame.prototype = Object.create(DraggablePoint.prototype);

KeyFrame.prototype.setPosition = function() {
    var oldX = this.x;
    var oldY = this.y;
    this.x = this.avar.frameToXPosition(this.frame);
    this.y = this.avar.valueToYPosition(this.value);
    var dx = this.x - oldX;
    var dy = this.y - oldY;
    
    // Update handle positions
    for (var i = 0; i < this.handles.length; i++) {
        this.handles[i].moveBy(dx, dy);
    }
};

KeyFrame.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.x, this.y) <= this.r + 1;
};

KeyFrame.prototype.move = function() {
    this.y = constrain(this.y + mouseY - pmouseY, this.avar.y2, this.avar.y1);
    this.value = this.avar.yPositionToValue(this.y);
    
    // Drag keyframe to next frame
    // Overwrite any existing keyframe there
    var mouseFrame = this.frameSelector.mapMouseToFrame();
    if (!this.fixed && this.frame !== mouseFrame) {
        var existing = this.avar.isKeyFrame(mouseFrame);
        if (existing) {
            if (existing.fixed) {
                this.fixed = true;
            }
            var index = this.avar.keyFrames.indexOf(existing);
            this.avar.keyFrames.splice(index, 1);
        }
        this.frame = mouseFrame;
        this.setPosition();
        this.avar.updateValues();
    }
};

KeyFrame.prototype.drawWithHandles = function() {
    for (var i = 0; i < this.handles.length; i++) {
        var handle = this.handles[i];
        
        strokeWeight(2);
        stroke(handle.color + (100 << 24));
        line(handle.x, handle.y, this.x, this.y);
        handle.draw();
    }
    this.draw();
};

KeyFrame.prototype.addHandle = function(kf2) {
    var dx = this.x - kf2.x;
    var d = abs(dx) * 0.2;
    var angle = atan2(this.y - kf2.y, dx);
    var avar = this.avar;
    
    this.handles.push(new ConstrainedPoint(
        this.x - d * cos(angle),
        this.y - d * sin(angle),
        [avar.x + 10, avar.x + avar.w + 10],
        [avar.y2, avar.y1],
        PINK)
    );
};

/*************************************************
 *      Frame selector
 * A slider allowing the user to select a frame
**************************************************/

var FrameSelector = function(timeline, x, y, dx, maxFrames) {
    this.timeline = timeline;
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.w = (maxFrames + 1) * this.dx;
    
    this.r = 9;
    this.by = this.y - this.r;
    this.maxFrames = maxFrames;
    this.held = false;
    
    this.setBallPosition();
    this.mouseOverFrame = -1;
};

FrameSelector.prototype.draw = function() {
    this.setBallPosition();
    
    this.mouseOverFrame = this.mapMouseToFrame();
    if (this.mouseOver() &&
        this.mouseOverFrame !== this.timeline.currentFrame) {
            strokeWeight(2);
            stroke(ORANGE);
            noFill();
            var x = this.x + (this.mouseOverFrame + 0.5) * this.dx;
            ellipse(x, this.by, this.r * 2, this.r * 2);
    }
    
    // Frame counter
    strokeWeight(1);
    stroke(GREY);
    fill(TEXTCOL);
    textSize(11);
    textAlign(CENTER, BASELINE);
    for (var i = 0; i <= this.maxFrames; i++) {
        var x = this.x + (i + 0.5) * this.dx;
        line(x, this.y, x, this.y - 3);
        text(i + 1, x, this.y - 5);
    }
    
    // Line over the avar boxes
    strokeWeight(1);
    stroke(200);
    line(this.bx, this.y, this.bx, this.y + this.timeline.h);
    
    // Selector ball
    fill(ORANGE);
    stroke(BACKGROUND);
    ellipse(this.bx, this.by, this.r * 2 + 1, this.r * 2 + 1);
    
    fill(TEXTCOL);
    textSize(11);
    textAlign(CENTER, CENTER);
    text(this.timeline.currentFrame + 1, this.bx, this.by);
    
    strokeWeight(1);
    stroke(GREY);
    line(this.x - 36, this.y, this.x + this.w, this.y);
};

FrameSelector.prototype.setBallPosition = function() {
    this.bx = this.x + (this.timeline.currentFrame + 0.5) * this.dx;
};

FrameSelector.prototype.selected = function() {
    this.held = dist(mouseX, mouseY, this.bx, this.by) <= this.r;
};

FrameSelector.prototype.mouseDragged = function() {
    if (this.held) {
        this.updateFrame();
        return true;
    }
};

FrameSelector.prototype.mouseOver = function() {
    return mouseX > this.x && mouseX < this.x + this.w &&
           mouseY < this.y && mouseY > this.y - 2 * this.r;
};

FrameSelector.prototype.mouseReleased = function() {
    // Clicking on frame moves to that frame
    if (this.mouseOver()) {
        this.updateFrame();
    }
    this.held = false;
};

FrameSelector.prototype.mapMouseToFrame = function() {
    var f = map(mouseX + 2, this.x, this.x + this.w, 0, this.maxFrames + 1);
    return constrain(floor(f), 0, this.maxFrames);
};

FrameSelector.prototype.updateFrame = function() {
    // Move to a new frame based on the mouse position
    this.timeline.currentFrame = this.mapMouseToFrame();
    this.setBallPosition();
};

/*************************************
 *      Avar
 * An animation variable.
 * Each variable has a value for each frame.
 * Values are determined by keyframes and
 * interpolation between these frames.
**************************************/

var Avar = function(timeline, name, y, value, vmin, vmax) {
    this.timeline = timeline;
    this.name = name;
    this.min = vmin;
    this.max = vmax;
    
    this.frameCount = timeline.frameCount;
    this.x = timeline.x;
    this.y = y;
    this.w = timeline.w;
    this.h = timeline.dy;
    
    this.dx = this.w / this.frameCount;
    var padding = 10;
    this.y1 = this.y + this.h - padding;
    this.y2 = this.y + padding;
    
    this.selected = -1;
    this.dragging = false;
    
    this.keyFrames = [];
    this.addKeyFrame(0, value, true);
    this.addKeyFrame(this.frameCount - 1, value, true);
    this.updateValues();
};

Avar.prototype.draw = function(f) {
    // Lower border line
    strokeWeight(1);
    stroke(GREY);
    noFill();
    line(this.x - 36, this.y + this.h, this.x + this.w, this.y + this.h);
    
    // Label
    noStroke();
    fill(224);
    rect(this.x - 36, this.y + 1, 35, this.h - 1);
    
    textAlign(CENTER, BASELINE);
    textFont(serifFont, 22);
    fill(TEXTCOL);
    text(this.name, this.x - 18, this.y + this.h / 2 - 4);
    
    textAlign(CENTER, TOP);
    textFont(sansFont, 12);
    text(round(this.values[f]), this.x - 18, this.y + this.h / 2 + 1);
    
    // Interpolated line
    strokeWeight(2);
    stroke(BLUE);
    noFill();
    beginShape();
    for (var i = 0; i < this.lines.length; i++) {
        vertex(this.lines[i][0], this.lines[i][1]);
    }
    endShape();
    
    for (var i = 0; i < this.keyFrames.length; i++) {
        this.keyFrames[i].drawWithHandles();
    }

    // Mouse over keyframe
    var frame = this.mouseOverAvars();
    
    // TODO: also not mouseover control point
    if (frame !== undefined && !this.dragging) {
        // Indicate possible keyFrame
        if (!this.isKeyFrame(frame[0])) {
            strokeWeight(2);
            stroke(ORANGE);
            fill(BACKGROUND);
            ellipse(frame[1], frame[2], 13, 13);   
        }
        
        // Indicate this frame
        var fs = this.timeline.frameSelector;
        noFill();
        ellipse(frame[1], fs.by, fs.r * 2 + 1, fs.r * 2 + 1);
    }
    
};

Avar.prototype.addKeyFrame = function(frame, value, fixed) {
        var kf = new KeyFrame(frame, value, this, fixed);
    this.keyFrames.push(kf);
    
    this.keyFrames.sort(function(a, b) {
        return a.frame - b.frame;
    });
    
    // Find index after sorting
    var index = this.keyFrames.indexOf(kf);
    
    if (index === 0) {
        // First point, so we need to add a fake second point
        kf.addHandle({ x: this.x + this.w, y: kf.y });
    } else {
        kf.addHandle(this.keyFrames[index - 1]);
    }
    if (index < this.keyFrames.length - 1) {
        kf.addHandle(this.keyFrames[index + 1]);
    }
};

Avar.prototype.addControlPoints = function(index) {
    // No need to add for very first keyframe
    // before other points added.
    if (index === 0) { return; }
    
    // Add control points before and after index
    var p1 = this.keyFrames[index - 1];
    var p2 = this.keyFrames[index];
    var p3 = this.keyFrames[index + 1];
    
    var xRange = [this.x, this.x  + this.w];
    var yRange = [this.y2, this.y1];
    
    var getPoint = function(p1, p2, p3) {
        p3 = p3 || p2;
        var d = dist(p1.x, p1.y, p3.x, p3.y);
        var dx = (p3.x - p1.x) / d;
        var dy = (p3.y - p1.y) / d;
        var d2 = min(d, 0.2 * dist(p1.x, p1.y, p2.x, p2.y));
        
        return new ConstrainedPoint(
            p1.x + dx * d2,
            p1.y + dy * d2,
            xRange, yRange, PINK);
    };
    
    // Convert index of keyframe to
    // index of control point
    index = index * 2 - 1;
    
    if (!p3) {
        // Final keyframe
        var cp1 = getPoint(p1, p2);
        var cp2 = getPoint(p2, p1);
        this.controlPoints.splice(index, 0, cp1, cp2);
    } else {
        var cp1 = getPoint(p2, p1);
        var cp2 = getPoint(p2, p3);
        this.controlPoints.splice(index, 0, cp1, cp2);
        // Shrink arm of existing control point
        var cp1a = getPoint(p1, p2, this.controlPoints[index - 1]);
        this.controlPoints.splice(index - 1, 1, cp1a);
    }
};

Avar.prototype.removeSelectedKeyFrame = function() {
    // Check it's not the first or last frame
    if (this.selected > 0 && this.selected < this.keyFrames.length - 1) {
        this.keyFrames.splice(this.selected, 1);
        this.updateValues();
    }
};

Avar.prototype.updateValues = function() {
    this.lines = [];
    this.values = [];
    
    for (var i = 0; i < this.keyFrames.length - 1; i++) {
        var p1 = this.keyFrames[i];
        var p2 = this.keyFrames[i + 1];
        var m1 = p1.handles[p1.handles.length - 1];
        var m2 = p2.handles[0];
        var df = p2.frame - p1.frame;
        var r = df * RESOLUTION;

        for (var j = 0; j <= r; j++) {
            var p = cubicSpline(p1, p2, m1, m2, j / r);
            this.lines.push([p.x, p.y]);
        }
        
        for (var j = p1.frame; j < p2.frame; j++) {
            var t = (j - p1.frame) / df;
            var p = cubicSpline(p1, p2, m1, m2, t);
            this.values.push(this.yPositionToValue(p.y));
        }

    }
    this.values.push(this.yPositionToValue(this.keyFrames[this.keyFrames.length - 1].y));
};

Avar.prototype.setKeyFrame = function(frameNum, value) {
    // TODO: check keyFrame is valid
    var keyFrame;
    
    for (var i = 0; i < this.keyFrames.length; i++) {
        if (this.keyFrames[i].frame === frameNum) {
            keyFrame = this.keyFrames[i];
        }
    }
    
    if (!keyFrame) {
        this.addKeyFrame(frameNum, value);
    } else {
        keyFrame.y = this.valueToYPosition(value);
    }
    
    this.updateValues();
};

Avar.prototype.valueToYPosition = function(v) {
    return map(v, this.min, this.max, this.y1, this.y2);
};

Avar.prototype.yPositionToValue = function(y) {
    return map(y, this.y1, this.y2, this.min, this.max);
};

Avar.prototype.xPositionToFrame = function(x) {
    var fs = this.timeline.frameSelector;
    return map(x, fs.x, fs.x + fs.w, 1, fs.maxFrames + 1);
};

Avar.prototype.frameToXPosition = function(f) {
    var fs = this.timeline.frameSelector;
    return fs.x + (f + 0.5) * fs.dx;
};

Avar.prototype.mouseOver = function() {
    return mouseY >= this.y && mouseY <= this.y + this.h && 
           mouseX >= this.x && mouseX <= this.x + this.w;
};

Avar.prototype.isKeyFrame = function(frame) {
    for (var i = 0; i < this.keyFrames.length; i++) {
        if (this.keyFrames[i].frame === frame) {
            return this.keyFrames[i];
        }
    }
};

Avar.prototype.selectedNotEndFrame = function() {
    var s = this.selected;
    if (s > 0 && s < this.keyFrames.length) {
        return this.keyFrames[s].frame < this.frameCount - 1;
    }
};

Avar.prototype.mouseOverAvars = function() {
    if (this.mouseOver()) {
        var fs = this.timeline.frameSelector;
        var frame = fs.mouseOverFrame;
        
        if (frame > -1) {
            var vx = this.x + (frame + 0.5) * this.dx;
            var vy = this.valueToYPosition(this.values[frame]);
            
            if (dist(mouseX, mouseY, vx, vy) <= 10) {
                return [frame, vx, vy];
            }
        }
    }
};

Avar.prototype.mousePressed = function() {
    // Deselect the selected frame firsr
    if (this.selected > -1) {
        this.keyFrames[this.selected].selected = false;
        this.selected = -1;
    }
    
    // Select key frame node
    if (this.mouseOver()) {
        for (var i = 0; i < this.keyFrames.length; i++) {
            var kf = this.keyFrames[i];
            if (kf.mouseOver()) {
                this.selected = i;
                this.dragging = this.keyFrames[i];
                this.keyFrames[i].selected = true;
                this.timeline.currentFrame = this.keyFrames[i].frame;
                
                // Show remove button a non-end frame is selected
                if (this.selectedNotEndFrame()) {
                    removeButton.showing = true;
                }
                return;
            }
            
            // Select a keyframe handle
            for (var j = 0; j < kf.handles.length; j++) {
                if (kf.handles[j].mouseOver()) {
                    this.dragging = kf.handles[j];
                    return;
                }
            }
        }
    }
};

Avar.prototype.mouseDragged = function() {
    if (this.dragging) {
        this.dragging.move();
        this.updateValues();
    }
};

Avar.prototype.mouseReleased = function() {
    var frame = this.mouseOverAvars();
    if (frame !== undefined && !this.isKeyFrame(frame[0]) && !this.dragging) {
        this.addKeyFrame(frame[0], this.values[frame[0]]);
        this.timeline.currentFrame = frame[0];
    }
    this.dragging = false;
};

/*************************************************
 *      Timeline
 * A object that contains an array for each avar
**************************************************/
{
var Timeline = function(x, y, w, dy, frames, scene) {
    this.x = x + 36;
    this.y = y;
    this.w = w - 36;
    this.h = 0;
    this.dx = this.w / frames;
    this.dy = dy;
    this.scene = scene;
    this.state = 'paused';
    
    this.padding = 8;
    
    this.frameCount = frames;
    this.currentFrame = 0;
    this.frameSelector = new FrameSelector(
        this, this.x, this.y, this.dx, this.frameCount -1
    );
    
    this.avars = {};
    this.avars = {};
    
    this.keyFrames = [0, this.frameCount - 1];
};

Timeline.prototype.addAvar = function(name, value, vmin, vmax) {
    // Add an animation variable
    // It's value will be set to the given value for all frames
    // A slider to control it is also added
    
    this.avars[name] = new Avar(this, name, this.y + this.h,
                                 value, vmin, vmax);
    this.h += this.dy;
};

Timeline.prototype.draw = function() {
    // Move to next frame if running
    
    var mod = 1 << (6 - speedSlider.value);
    
    if (this.state === 'running' && frameCount % mod === 0) {
        this.currentFrame++;
        this.currentFrame %= this.frameCount;
    }
    
    // Frame Selector
    this.frameSelector.draw();

    // Draw avars
    for (var a in this.avars) {
        this.avars[a].draw(this.currentFrame);
    }
};

Timeline.prototype.removeSelectedKeyFrame = function() {
    for (var a in this.avars) {
        if (this.avars[a].selected > -1) {
            this.avars[a].removeSelectedKeyFrame();
            removeButton.showing = false;
        }
    }
};

Timeline.prototype.mouseOver = function() {
    return mouseX >= this.x && mouseX <= this.x + this.w &&
           mouseY >= this.y && mouseY <= this.y + this.h;
};

Timeline.prototype.mouseDragged = function() {
    // Drag sliders and update values
    if (this.state === 'paused') {
        this.frameSelector.mouseDragged();
        
        for (var a in this.avars) {
            this.avars[a].mouseDragged();
        }
    }
};

Timeline.prototype.mousePressed = function() {
    if (this.state === 'paused') {
        this.frameSelector.selected();
        
        // Check whether any non-end keyframes are selected
        if (this.mouseOver()) {
            var anySelected = false;
            for (var a in this.avars) {
                this.avars[a].mousePressed();
                if (this.avars[a].selectedNotEndFrame()) {
                    anySelected = true;
                }
            }
            
            // If mouse pressed outside of avar, hide removeButton
            if (!anySelected) {
                removeButton.showing = false;
            }   
        }
    }
};

Timeline.prototype.mouseReleased = function() {
    if (this.state === 'paused') {
        this.frameSelector.mouseReleased();
        
        for (var a in this.avars) {
            this.avars[a].mouseReleased();
        }
    }
};
}
/*************************************
 *      Actor
 * An actor is an object in a scene to be animated.
**************************************/
{
var Actor = function(timeline) {
    this.timeline = timeline;
    this.avars = timeline.avars;
};

Actor.prototype.draw = function(dx, dy) {
    var f = this.timeline.currentFrame;
    var x = dx + this.avars.x.values[f];
    var y = dy - this.avars.y.values[f];
    var sx = max(0, this.avars.sx.values[f]);
    var sy = max(0, this.avars.sy.values[f]);
    var a = this.avars.a.values[f];
    
    // Shadow
    pushMatrix();
        translate(x + 1, y - sy / 2 + 1);
        rotate(a);
        scale(sx / 64, sy / 64);
        noStroke();
        fill(0, 0, 0, 60);
        ellipse(0, 0, 60, 60);
    popMatrix();
    
    // Ball
    pushMatrix();
    translate(x, y - sy / 2);
    rotate(a);
    scale(sx / 64, sy / 64);
    image(sprites[0], -32, -32, 64, 64);
    popMatrix();
};
}
/*************************************
 *      Scene
 * A scene is box in which the actor exists
**************************************/
{
var Scene = function(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.actors = [];
};

Scene.prototype.draw = function() {
    fill(SKYBLUE);
    rect(this.x, this.y, this.w, this.h + 20);
    
    /*
    strokeWeight(1);
    for (var y = 0; y < this.h + 20; y++) {
        stroke(lerpColor(SKYBLUE2, SKYBLUE, y / (this.h + 20)));
        line(this.x, this.y + y, this.x + this.w, this.y + y);
    }
    */
    
    noStroke();
    fill(120, 200, 160);
    rect(this.x + 1, this.y + this.h, this.w - 1, 20);
    
    strokeWeight(2);
    stroke(GREEN);
    line(this.x + 1, this.y + this.h + 1, this.x + this.w - 1, this.y + this.h + 1);
    
    for (var i = 0; i < this.actors.length; i++) {
        this.actors[i].draw(this.x, this.y + this.h);
    }
    
    // Border
    strokeWeight(1);
    stroke(GREY);
    noFill();
    rect(this.x, this.y, this.w, this.h + 20);
    
    // Clip scene
    noStroke();
    fill(BACKGROUND);
    rect(0, 0, width, this.y);
    rect(0, 0, this.x, this.y + this.h + 60);
    rect(this.x + this.w + 1, 0, this.x, this.y + this.h + 60);
    rect(0, this.y + this.h + 21, width, 40);
};

Scene.prototype.addActor = function(actor) {
    this.actors.push(actor);
};
}
/*************************************
 *      Setup
**************************************/

// TODO: bind avars to actor somehow
var scene = new Scene(20, 10, width - 40, 200);

// Create 24 frames of animation
var timeline = new Timeline(20, scene.y + scene.h + 48, width - 40, 60, FRAMES, scene);
timeline.addAvar('x', 200, 0, scene.w);
timeline.addAvar('y', 50, 0, scene.h);
timeline.addAvar('sx', 32, 1, 64);
timeline.addAvar('sy', 32, 1, 64);
timeline.addAvar('a', 0, -90, 90);
scene.addActor(new Actor(timeline));

// Setup parameters
timeline.avars.x.setKeyFrame(0, 0);
timeline.avars.x.setKeyFrame(23, 600);

/*************************************
 *  Save functions
**************************************/

var saveAnimation = function() {
    var s = "";
    
    // TODO: use interpolation to find values between frames
    
    for (var a in timeline.avars) {
        s += "var " + a + "s=[";
        var t = timeline.avars[a].values;
        for (var i = 0; i < t.length; i++) {
            s += (i ? "," : "");
            if (a === 'y') {
                s += 380 - round(t[i]);
            } else {
                s += round(t[i]);
            }
        }
        s += "];\n";
    }
    
    s += "\nvar drawBall = function(x, y, a, r, s) {\n";
    s += "\tnoStroke();\n";
    s += "\tpushMatrix();\n";
    s += "\ttranslate(x, y);\n";
    s += "\trotate(a);\n";
    s += "\tfill(0, 0, 0, 60);\n";
    s += "\tellipse(1, 1, r, s)\n;";
    s += "\tfill(255, 60, 60);\n";
    s += "\tellipse(0, 0, r, s);\n";
    s += "\tpopMatrix();\n";
    s += "};\n";
    
    s += "draw = function() {\n";
    s += "\tbackground(230, 240, 255);\n";
    s += "\tstrokeWeight(2);\n";
    s += "\tstroke(28, 173, 123);\n";
    s += "\tfill(120, 200, 160);\n";
    s += "\trect(-2, 380, 404, 44);\n";
    
    s += "\n\tvar t = frameCount % " + FRAMES + ";\n";
    s += "\n\tvar x = xs[t];\n";
    s += "\tvar y = ys[t];\n";
    s += "\tvar a = as[t];\n";
    s += "\tvar r = sxs[t];\n";
    s += "\tvar s = sys[t];\n"; 
    s += "\tdrawBall(x, y, a, r, s);\n";
    s += "};\n";
    
    println(s);
};

var saveKeyFrames = function() {
    var s = "";
    for (var a in timeline.avars) {
        var avar = timeline.avars[a];
        
        for (var i = 0; i < avar.keyFrames.length; i++) {
            var kf = avar.keyFrames[i];
            var x = round(avar.xPositionToFrame(kf.x));
            var y = round(100 * avar.yPositionToValue(kf.y)) / 100;
            
            s += "timeline.avars." + a + ".setKeyFrame(" + x + ", " + y + ")\n";
        }
    }
    println(s);
};

/*************************************
 *  Set up other GUI elements
**************************************/

var playPause = function() {
    if (timeline.state === 'running') {
        timeline.state = 'paused';
    } else if (timeline.state === 'paused') {
        timeline.state = 'running';
    }
};

var playIcon = function(x, y, r) {
    noStroke();
    if (timeline.state === 'running') {
        rect(x - 4, y - 5, 3, 10, 5);
        rect(x + 1, y - 5, 3, 10, 5);
    } else {
        triangle(x - r * 0.4, y - r * 0.5, x - r * 0.4, y + r * 0.5, x + r * 0.65, y);
    }
};

var removeKeyFrame = function() {
    timeline.removeSelectedKeyFrame();
};

var buttonY = timeline.y + timeline.h + 10;
var playButton = new CircleButton(26, buttonY, 24, 24, playPause, playIcon);

removeButton = new Button(200, buttonY + 1, 125, 20, "Remove keyframe", removeKeyFrame);
removeButton.showing = false;

speedSlider = new Slider(80, buttonY + 20, 60, 'horizontal', 1, 6, 3);

/*************************************
 *  Main loop
**************************************/

draw = function() {
    background(BACKGROUND);
    
    if (!spritesLoaded) {
        createSprite(ballSprite, 0);
        return;
    }
    
    scene.draw();
    timeline.draw();
    
    playButton.draw();
    
    if (timeline.state === 'paused') {
        removeButton.draw();    
    }
    
    // Extra GUI elements
    fill(TEXTCOL);
    textAlign(CENTER, BASELINE);
    textSize(13);
    text("Speed: " + speedSlider.value, speedSlider.x + speedSlider.length / 2, speedSlider.y - 10);
    speedSlider.draw();
};

/*************************************
 *      Event handling
**************************************/

mousePressed = function() {
    timeline.mousePressed();
    speedSlider.selected();
};

mouseDragged = function() {
    timeline.mouseDragged();
    speedSlider.mouseDragged();
};

mouseReleased = function() {
    timeline.mouseReleased();
    playButton.mouseReleased();
    removeButton.mouseReleased();
    speedSlider.held = false;
};

mouseOut = function() {
    mouseReleased();
};

keyPressed = function() {
    if (key.toString() === "s") {
        saveAnimation();
    } else if (key.toString() === "k") {
        saveKeyFrames();
    }
};
