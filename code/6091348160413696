/****************************************************
 * Character creator v0.9
 * 
 * This is a tool for creating images from polygons.
 * Polygons can be curved using subdivision. See the
 * Pixar Character Modeling tutorial for more information.
 * 
 * Click and drag shapes around. Use the toolbar to edit
 * the style of the shape or add more shapes.
 * 
 * 
 *          -- Getting started --
 * 
 * Edit > New shape
 *  Add a new shape (a triangle) to the canvas.
 * 
 * Points > Edit points
 *  Select the control points of shapes to moves around.
 * Move the mouse over a edge to get a pink circle
 * which indicates a new point can be added.
 * 
 * File > Save canvas
 *  Get shape data that can be pasted into the shape
 * variable at the top of this program to save your
 * progress.
 * 
 * File > Export as PJS
 *  Get the PJS code for the shapes you have created
 * so you can use your shapes in other programs.
 * 
 *
 * NOTE: If you want to edit this program you may find
 * it easier to first comment out all the code in the 
 * createSwatch function to reduce lagging.
 * 
 * TODO:
 *  Functions
 *      Add tooltips to tooltip bar
 *      Tutorial
 *      Change cursors
 *      Keyboard shortcuts
 *      Box cursors to show we can scale/rotate
 *      Controls for opacity
 *      Confirm delete shape
 *      Undo/Redo
 *      Control to change background
 *      Select side number and length for new shapes
 *      Snap and align
 *      Multi-select shapes
 *      Pan and zoom canvas
 * 
 * Fixes
 *      Clicking off swatch should not close toolbar
 * 
 * Improvements
 *      Move brightness control onto swatch
 *      Only test for dragging in the draw loop
 *      Allow dragging on menu bar
 *      Convert all coordinates to objects (?)
 *      Separate out mouseover and mouse events
 * 
*****************************************************/



// Add saved canvas data here
var shapes = [
	{p:[[208,58],[433,54],[460,232],[377.2,273.1],[316,357.5],[263,268],[192,224]],r:5,f:-10499940,s:-12950490,sw:4,name:'face'},
	{p:[[252,124],[225,150],[315,150]],f:-3664381,s:-16777216,name:'eye1'},
	{p:[[400,122],[328,149],[423,149]],f:-3666427,s:-16777216,name:'eye2'}
];





// Standard colours and variables
var BACKGROUND = color(250, 250, 250);
var WARN_COLOR = color(200, 0, 0);
var CONTROL_ARMS = color(10, 10, 10, 120);
var MENU_COLOR = color(235, 230, 225);

var WHITE = color(255, 255, 255);
var BLUE = color(64, 95, 237);
var PINK = color(255, 0, 175);
var GREEN = color(28, 173, 123);
var ORANGE = color(255, 165, 0);
var TEXTCOL = color(20, 20, 20);
var TOOLBAR = color(230, 230, 230, 200);

var sansFont = createFont("sans", 14);
var serifFont = createFont("serif", 16);

strokeJoin(ROUND);
var POINT_SIZE = 12;
var POINT_SIZE2 = POINT_SIZE * POINT_SIZE;

var toolbars, tooltip;
var showing = {};

var shortcuts = {
    '1': 'Scale',
    '2': 'Rotate',
    '3': 'Points',
    '4': 'Color',
};

/*****************************************************
 *  General functions
******************************************************/

var forEach = function(arr, func) {
    for (var i = 0, len = arr.length; i < len; i++) {
        arr[i][func]();
    }
};

var removeFromArray = function(arr, element) {
    var index = arr.indexOf(element);
    if (index > -1) {
        arr.splice(index, 1);
    }
};

var swatch;
var createSwatch = function(n, brightness) {
    loadPixels();
    var px = imageData.data;
    
    var ni = 1 / n;
    var x, y, h, s, r, g, b, i, f, p, q, t;
    var index;
    
    //var s = 0.5;          // Saturation
    var v = brightness;     // Brightness
    
    for (x = 0; x < n; x++) {
        h = ni * x;     // Hue along x-axis
        for (y = 0; y < n; y++) {
            s = ni * y; // Saturation along y-axis
            //v = ni * y; // Brightness along y-axis
            i = floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            index = x + (y * width) << 2;
            px[index++] = r * 0xFF | 0;
            px[index++] = g * 0xFF | 0;
            px[index++] = b * 0xFF | 0;
        }
    }
    updatePixels();
    return get(0, 0, n, n);
};

/*****************************************************
 *      GUI
******************************************************/
{

// Functions for composing
var mouseOverRect = function() {
    return mouseX > this.x && mouseX < this.x + this.w &&
           mouseY > this.y && mouseY < this.y + this.h;
};    

/*******************************************************
 * Button is the default GUI element. Other elements
 * inhert from it.
********************************************************/
{
var Button = function(x, y, w, h, params) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    
    this.mx = this.x + this.w * 0.5;
    this.my = this.y + this.h * 0.5;
    
    this.selected = false;
    this.disabled = false;
    this.transition = 0;
    
    // Default properties
    this.fill = color(230, 230, 230, 200);
    this.textFill = color(55, 50, 45);
    this.highlightFill = color(210, 210, 210, 250);
    this.stroke = color(200);
    this.activeCursor = HAND;
    
    // Copy parameters
    for (var property in params) {
        if (params.hasOwnProperty(property)) {
            this[property] = params[property];
        }
    }
};

Button.prototype.draw = function() {
    this.disabled = this.disabledFunc && this.disabledFunc();
    this.mouseIsOver = this.mouseOver();
    
    if (this.mouseIsOver){
        cursor(this.disabled ? 'not-allowed' : this.activeCursor);
    }
    this.fade();
    
    this.drawElement();
};

Button.prototype.drawElement = function() {
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultFill, this.highlightFill, this.transition * 0.1));
        strokeWeight(1);
        stroke(this.stroke);
    }
    rect(this.x, this.y - 1, this.w, this.h + 3, 19);
    
    fill(this.disabled ? 120 : this.textFill);
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.mx, this.my + 2);
};

Button.prototype.mousePressed = function() {
    this.selected = this.mouseIsOver;
    return this.selected;
};

Button.prototype.mouseOver = function() {
    return mouseX > this.x && mouseX < this.x + this.w &&
           mouseY > this.y && mouseY < this.y + this.h;
};

Button.prototype.mouseDragged = function() {};

Button.prototype.mouseReleased = function() {
    if (this.selected && !this.disabled && this.mouseIsOver) {
        this.trigger();
    }
    this.selected = false;
};

Button.prototype.trigger = function() {
    // To be over-written
};

Button.prototype.fade = function() {
    if (this.selected || this.mouseIsOver) {
        this.transition = min(10, this.transition + 1);
    } else {
        this.transition = max(0, this.transition - 1);
    }
};
}
/****************************************************
 *  GUI Button
*****************************************************/
{
var CheckBox = function(x, y, w, h, name) {
    Button.call(this, x, y, w, h, { name: name });
    this.box = this.h - 6;
    this.bx = this.x + 5;
    this.by = this.y + 3;
};
CheckBox.prototype = Object.create(Button.prototype);

CheckBox.prototype.trigger = function() {
    showing[this.name] = !showing[this.name];  
};

CheckBox.prototype.draw = function() {
    this.fade();
    
    if (this.transition) {
        noStroke();
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        rect(this.x, this.y, this.w, this.h + 1, 4);
    }
    
    fill(20);
    textFont(sansFont, 13);
    textAlign(LEFT, CENTER);
    text(this.name, this.x + this.box + 9, this.y + this.h/2 + 1);
    
    noFill();
    stroke(10);
    strokeWeight(1);
    rect(this.bx, this.y + 3, this.box, this.box);

    if (showing[this.name]) {
        line(this.bx + 1, this.by + 1, this.bx + this.box, this.by + this.box);
        line(this.bx + this.box, this.by + 1, this.bx + 1, this.by + this.box);
    }
};
}   // Checkbox
{
var RadioButton = function(x, y, w, h, name, trigger) {
    Button.call(this, x, y, w, h, {name: name, trigger: trigger});
    this.r = this.h - 6;
    this.cx = this.x + this.r / 2 + 5;
    this.cy = this.y + this.h / 2;
    this.marked = false;
};
RadioButton.prototype = Object.create(Button.prototype);

RadioButton.prototype.draw = function() {
    this.fade();
    
    if (this.transition) {
        noStroke();
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        rect(this.x, this.y, this.w, this.h + 1, 4);
    }
    
    fill(10);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    text(this.name, this.cx + this.r /2 + 4, this.cy + 1);
    
    noFill();
    stroke(10);
    strokeWeight(1);
    ellipse(this.cx, this.cy, this.r, this.r);
    
    if (this.marked) {
        fill(10);
        ellipse(this.cx, this.cy, this.r / 2, this.r / 2);
    }
};
}   // Radio button
{
var Swatch = function(x, y, w, h, params) {
    params.trigger = function() {
        this.showSwatch = !this.showSwatch;
    };
    
    Button.call(this, x, y, w, h, params);
    
    this.setValue(params.color || color(255, 0, 0));

    this.defaultFill = color(250);
    this.updateFunction = params.update;
    
    if (this.updateFunction) { this.updateFunction(); }
    
    this.size = 128;
    this.showSwatch = false;
    this.sx = this.x + this.w + 10;
    this.sy = min(this.y - 4, height - this.size - 48);
    this.sx2 = this.sx + this.size;
    this.sy2 = this.sy + this.size;
};
Swatch.prototype = Object.create(Button.prototype);

Swatch.prototype.draw = function() {
    this.fade();
    
    noStroke();
    fill(lerpColor(this.defaultFill, this.highlightFill, this.transition / 10));
    
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 8);
    
    var my = this.y + this.h / 2;
    
    fill(20);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    var txt = this.name + ":";
    text(txt, this.x + 5, my + 1);
    
    strokeWeight(1);
    stroke(20);
    fill(this.value);
    rect(this.x + textWidth(txt) + 10, my - 8, 16, 16);
    
    // TODO: make a swatch object
    if (this.showSwatch) {
        // Shadow
        noStroke();
        fill(0, 0, 0, 50);
        rect(this.sx + 2, this.sy + 1, this.size + 2, this.size + 27);
        fill(0);
        //rect(this.sx, this.sy, SWATCHSIZE, SWATCHSIZE + 30);
        image(swatch, this.sx, this.sy);
        
        // Overlay with shade for brightness
        fill(0, 0, 0, 255 - this.bri * 255);
        rect(this.sx, this.sy, this.size, this.size);

        noFill();
        strokeWeight(1);
        stroke(255);
        ellipse(this.sx + this.hue * this.size, this.sy + this.sat * this.size, 5, 5);
        
        strokeWeight(2);
        stroke(0);
        rect(this.sx - 1, this.sy - 1, this.size + 2, this.size + 2);
        
        if (this.mouseOverSwatch()) {
            colorMode(HSB);
            var hue = norm(mouseX, this.sx, this.sx2);
            var sat = norm(mouseY, this.sy, this.sy2);
            fill(hue * 255, sat * 255, this.bri * 255);
            rect(this.sx - 1, this.sy2 + 1, this.size + 2, 24);
            colorMode(RGB);
        } else {
            textAlign(CENTER, CENTER);
            fill(0);
            rect(this.sx - 1, this.sy2 + 1, this.size + 2, 24);
            fill(255);
            text("Pick a color", this.sx + this.size / 2, this.sy2 + 12);
        }
    }
};

// Set colour based on current HSB
Swatch.prototype.updateColor = function() {
    colorMode(HSB);
    this.value = color(this.hue * 255, this.sat * 255, this.bri * 255);
    colorMode(RGB);
    return this.value;
};

// Set colour using passed int value
Swatch.prototype.setValue = function(color) {
    this.value = color;
    this.hue = hue(this.value) / 255;
    this.sat = saturation(this.value) / 255;
    this.bri = brightness(this.value) / 255;
};

Swatch.prototype.findColor = function() {
    this.hue = norm(mouseX, this.sx, this.sx2);
    this.sat = norm(mouseY, this.sy, this.sy2);
};

Swatch.prototype.mouseOverSwatch = function() {
    return mouseX >= this.sx && mouseX <= this.sx2 &&
           mouseY >= this.sy && mouseY <= this.sy2;
};

Swatch.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h) ||
            (this.showSwatch && this.mouseOverSwatch());
};

Swatch.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
    
    if (!this.selected && this.showSwatch) {
        this.showSwatch = false;
    }

    return this.selected;
};

Swatch.prototype.mouseReleased = function() {
    if (this.showSwatch && this.mouseOverSwatch()) {
        this.findColor();
        this.updateColor();
        if (this.updateFunction) {
            this.updateFunction(this.value);
        }
    } else if (this.selected && this.mouseOver()) {
        this.trigger();
    } else {
        this.showSwatch = false;
    }
};
}   // Swatch
/****************************************************
 * GUI Slider
*****************************************************/
{
var Slider = function(x, y, w, h, params) {
    // Size of ball
    this.ballR = 12;
    this.ballD = this.ballR * 2;
    
    x += this.ballR;
    w -= this.ballR * 2;
    
    var h = this.ballD + (params.name ? 16 : 0);
    y += h - this.ballR;
    this.x2 = x + w;
    
    // Default values
    this.min = 0;
    this.max = 1;
    this.decimalPlaces = 0;
    
    Button.call(this, x, y, w, h, params);

    this.fill = color(240);
    this.stroke = color(180);

    this.value = params.now === undefined ? this.min : params.now;
    this.setValue(this.value);
    this.trigger();
};
Slider.prototype = Object.create(Button.prototype);

Slider.prototype.draw = function() {
    if (this.name) {
        fill(20);
        textSize(13);
        textAlign(CENTER, BASELINE);
        text(this.name,  this.x + this.w / 2, this.y - 15);
        //text(this.name + ": " + this.value,  this.x + this.w / 2, this.y - 14);
    }
    
    this.fade();
    fill(lerpColor(color(this.fill), color(this.stroke), this.transition / 10));
    stroke(this.stroke);
    strokeWeight(3);
    line(this.x, this.y, this.x2, this.y);
    ellipse(this.bx, this.y, this.ballD, this.ballD);
    
    fill(20);
    textSize(12);
    textAlign(CENTER, CENTER);
    text("" + this.value, this.bx, this.y);
};

Slider.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.bx, this.y) < this.ballR;
};

Slider.prototype.mousePressed = function() {
    if (this.mouseOver()) {
        this.selected = true;
        return true;
    }
};

Slider.prototype.mouseDragged = function() {
    if (this.selected) {
        this.bx = constrain(mouseX, this.x, this.x2);
        var p = pow(10, this.decimalPlaces);
        this.value = round(map(this.bx, this.x, this.x2, this.min, this.max) * p) / p;
        this.trigger();
        return true;
    }
};

Slider.prototype.mouseReleased = function() {
    this.selected = false;
};

Slider.prototype.setValue = function(v) {
    this.value = constrain(v, this.min, this.max);
    this.bx = map(this.value, this.min, this.max, this.x, this.x2);
};
}
/*********************************************
 * GUI Label
**********************************************/
{
var Label = function(x, y, w, h, name, params) {
    this.x1 = x + 8;
    this.x2 = x + w - 8;
    this.y = y + h - 2;
    this.y2 = y + h / 2;
    this.name = name;
    
    this.fontSize = params.fontSize || 16;
    this.underline = !params.noUnderline;
    this.alignH = params.alignH || CENTER;
    this.alignV = params.alignV || CENTER;
    
    this.x = this.alignH === CENTER ? x + w / 2: this.x1;
};

Label.prototype.draw = function() {
    fill(20);
    textFont(sansFont, this.fontSize);
    textAlign(this.alignH, this.alignV);
    text(this.name, this.x, this.y2);
    
    if (this.underline) {
        strokeWeight(1);
        stroke(20);
        line(this.x1, this.y, this.x2, this.y);
    }
};
}
/*****************************************************
 *      Toolbar
 *  Like GUI but is displayed and has methods for adding
 * components like buttons and sliders.
******************************************************/
{
var Toolbar = function(x, y, w) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = 8;
    this.components = [];
    this.labels = [];
    this.mouseOver = mouseOverRect;
};

Toolbar.prototype.draw = function() {
    this.disabled = this.disabledFunc && this.disabledFunc();
    
    strokeWeight(1);
    stroke(180);
    
    if (this.disabled) {
        fill(200);
        rect(this.x, this.y, this.w, this.h, 8);
        
        fill(TEXTCOL);
        textAlign(CENTER, BASELINE);
        textFont(sansFont);
        text("Select a shape to show the style toolbar", this.x + 5, this.y + this.h * 0.25, this.w - 10, 60);
        
    } else {
        fill(250);
        rect(this.x, this.y, this.w, this.h, 8);
       
        forEach(this.labels, 'draw');
        forEach(this.components, 'draw');
    }
};

Toolbar.prototype.add = function(type, params) {
    params = params || {};
    var h = params.h || 20;
    var component = new type(this.x + 5, this.y + this.h, this.w - 10, h, params);
    this.components.push(component);
    this.h += component.h + 8;
    return component;
};

Toolbar.prototype.addLabel = function(name, params) {
    params = params || {};
    var h = params.h || 20;
    this.labels.push(new Label(this.x, this.y + this.h, this.w, h, name, params));
    this.h += h + 8;
};

Toolbar.prototype.addOptions = function(options) {
    var x = this.x + 3;
    var y = this.y + this.h + 2;
    var w = this.w - 6;
    var h = 22;
    
    for (var opt in options) {
        var button = new CheckBox(x, y, w, h, opt);
        this.components.push(button);
        y += h + 5;
        this.h += h + 5;
    }
    
    this.h += 2;
};

Toolbar.prototype.addRadioButtons = function(options, trigger, defaultOption) {
    var x = this.x + 3;
    var y = this.y + this.h + 2;
    var w = this.w - 6;
    var radioButtons = [];
    
    var triggerFunction = function() {
        if (!this.marked) {
            this.marked = true;
            
            // Deselected other buttons
            for (var i = 0; i < radioButtons.length; i++) {
                if (radioButtons[i] !== this) {
                    radioButtons[i].marked = false;
                }
            }
        }
        if (trigger) { trigger(this.name); }
    };
    
    for (var i = 0; i < options.length; i++) {
        var button = new RadioButton(x, y, w, 22, options[i], triggerFunction);
        radioButtons.push(button);
        y += 27;
        this.h += 27;
    }
    
    radioButtons[defaultOption || 0].trigger();
    
    this.components = this.components.concat(radioButtons);
    this.h += 2;
};

Toolbar.prototype.mousePressed = function() {
    // Check mouse is over a component
    for (var i = this.components.length; i--;) {
        if (this.components[i].mousePressed()) {
            this.active = this.components[i];
            return this.active;
        }
    }
    
    // Otherwise capture mouse if it's over the toolbar
    return this.mouseOver();
};

Toolbar.prototype.mouseReleased = function() {
    forEach(this.components, 'mouseReleased');
    this.active = false;
};

Toolbar.prototype.mouseDragged = function() {
    if (this.active) {
        this.active.mouseDragged();
    }
};
}
/*******************************************************
 *      Menu
 * A minimal toolbar that is reveal when a menu is
 * opened. It triggers buttons when mouse is released
 * over an option. The mouse doesn't have to be pressed
 * on the button initially.
********************************************************/
{
var Menu = function(x, y, w) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = 3;
    
    this.components = [];
    this.mouseOver = mouseOverRect;
};

Menu.prototype.draw = function() {
    fill(250);
    strokeWeight(1);
    stroke(180);
    rect(this.x, this.y, this.w, this.h);
    forEach(this.components, 'draw');
};

Menu.prototype.addItem = function(params) {
    params.drawElement = this.drawItem;
    
    var h = 20;
    var component = new Button(this.x, this.y + this.h, this.w, h, params);
    
    this.components.push(component);
    this.h += h;
    
    textFont(sansFont, 15);
    this.setWidth(textWidth(params.name || "") + 10);
};

Menu.prototype.setWidth = function(w) {
    if (w > this.w) {
        this.w = w;
        for (var i = this.components.length; i--;) {
            this.components[i].w = w;
        }
    }
};

Menu.prototype.drawItem = function() {
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    
    if (this.transition && !this.disabled) {
        noStroke();
        var t = this.transition * 0.1;
        fill(lerpColor(this.defaultFill, BLUE, t));
        rect(this.x, this.y, this.w, this.h);
        fill(lerpColor(this.textFill, WHITE, t));
    } else {
        fill(this.disabled ? 180 : this.textFill);
    }
    
    text(this.name, this.x + 5, this.my);
};

Menu.prototype.mouseReleased = function() {
    for (var i = this.components.length; i--;) {
        var component = this.components[i];
        if (!component.disabled && component.mouseIsOver) {
            component.trigger();
            component.transition = 0;
            return true;
        }
    }
};
}
/*******************************************************
 *      MenuButton
 * A button that reveals a dropdown containing more buttons
********************************************************/
{
var MenuButton = function(x, y, w, h, params) {
    Button.call(this, x, y, w, h, params);
    
    this.toolbar = new Menu(x, y + h, w - 1);
    this.toolbar.gap = 1;
};
MenuButton.prototype = Object.create(Button.prototype);

MenuButton.prototype.drawElement = function() {
    if (this.open) {
        noStroke();
        fill(BLUE);
        rect(this.x, this.y, this.w, this.h);
    } else if (this.mouseIsOver) {
        stroke(lerpColor(this.defaultFill, this.textFill, this.transition * 0.1));
        strokeWeight(1);
        var y = this.y + this.h - 2;
        line(this.x, y, this.x + this.w, y);
    }
    
    fill(this.open ? WHITE : this.textFill);
    textFont(sansFont, 14);
    textAlign(CENTER, CENTER);
    text(this.name, this.mx, this.my);
    
    if (this.open) {
        this.toolbar.draw();
    }
};

MenuButton.prototype.mousePressed = function() {
    if (this.open) {
        if (this.toolbar.mouseOver()) {
            // If toolbar is clicked on, do nothing, but capture click
            return true;
        } else {
            // Otherwise close menu
            this.open = false;
            return false;
        }
    } else {
        // If menu not open then open it if mouseover button
        this.open = this.mouseIsOver;
        return this.open;
    }
};

MenuButton.prototype.mouseReleased = function() {
    if (this.open && this.toolbar.mouseOver()) {
        // Trigger toolbar
        if (this.toolbar.mouseReleased()) {
            // Close toolbar if button pressed 
            this.open = false;
        }
        return;
    }
    
    // Toogle menu if mouse over button
    this.open = this.mouseIsOver;
};
}
/*******************************************************
 *      Menubar
 * A horizontal toolbar that only contains dropdown menus
********************************************************/
{
var MenuBar = function(h) {
    this.x = -1;
    this.y = -1;
    this.w = width + 2;
    this.h = h;
    
    this.mx = 5;
    this.fill = color(235, 230, 225);
    
    this.components = [];
    this.menus = {};
    
    this.mouseOver = mouseOverRect;
};

MenuBar.prototype.draw = function() {
    fill(this.fill);
    strokeWeight(1);
    stroke(180);
    rect(this.x, this.y, this.w, this.h);

    forEach(this.components, 'draw');
};

MenuBar.prototype.addMenu = function(name) {
    textFont(sansFont, 14);
    var w = textWidth(name) + 4;
    var menuButton = new MenuButton(this.mx, this.y + 1, w, this.h - 1, {
        name: name,
        defaultFill: this.fill,
    });
    
    this.components.push(menuButton);
    this.menus[name] = menuButton;
    
    this.mx += w + 5;
};

MenuBar.prototype.addMenuItem = function(menuName, item) {
    var menu = this.menus[menuName];
    
    if (menu) {
        menu.toolbar.addItem(item);
    } else {
        println("ERROR: no menu with name " + menuName);
    }
};

MenuBar.prototype.mousePressed = function() {
    // Select a button if one is pressed
    this.active = false;
    
    for (var i = this.components.length; i--;) {
        if (this.components[i].mousePressed()) {
            this.active = this.components[i];
        }
    }

    return this.active || this.mouseOver();
};

MenuBar.prototype.mouseDragged = function() {};

MenuBar.prototype.mouseReleased = function() {
    if (this.active) {
        this.active.mouseReleased();
        if (!this.active.mouseIsOver) {
            this.active = false;
        }
    }
    return this.active;
};
}
}
/*****************************************************
 * DraggablePoint
 * A freely draggable point associated with another 
 * point, whose value it is controlled by
******************************************************/
{
var DraggablePoint = function(p1, p2) {
    
    Object.defineProperty(this, 'x', {
        get: function() { return p1[0]; },
        set: function(x) { p1[0] = x; }
    });
    
    Object.defineProperty(this, 'y', {
        get: function() { return p2[1]; },
        set: function(y) { p2[1] = y; }
    });
    
    this.color = ORANGE;
    this.animation = 0;
};

DraggablePoint.prototype.draw = function() {
    if (this.dragging || this.mouseOver()) {
        if (this.animation < 5) {
            this.animation++;
        }
    } else {
        this.animation = 0;
    }

    strokeWeight(1);
    stroke(BACKGROUND);
    if (this.selected) {
        fill(PINK);
    } else {
        fill(this.color);
    }
    
    var r = POINT_SIZE + this.animation;
    ellipse(this.x, this.y, r, r);
};

DraggablePoint.prototype.mouseOver = function() {
    return (mouseX - this.x) * (mouseX - this.x) + (mouseY - this.y) * (mouseY - this.y) <= POINT_SIZE2;
};
}
/*****************************************************
 *      Polygon
 * A collection of points, joined by control arms
 * A curve is drawn between the points using subdivsion.
******************************************************/
{
var Polygon = function(params) {
    // Add control points
    this.controlPoints = params.p;
    
    this.selectedPoint = false;
    this.addPointCoord = false;
    
    this.name = params.name;
    this.resolution = params.r || 0;
    this.fill = params.f || GREEN;
    this.fillBrightness = brightness(this.fill);
    this.stroke = params.s || color(0);
    this.strokeBrightness = brightness(this.stroke);
    this.strokeWeight = params.sw || 0;
    
    this.min = [];
    this.max = [];
    
    Object.defineProperty(this, 'center', {
        get: function() {
            return [
                (this.min[0] + this.max[0]) * 0.5,
                (this.min[1] + this.max[1]) * 0.5
            ];
        }
    });
    
    this.updateShape();
};

Polygon.prototype.updateShape = function() {
    this.updateCurvePoints();
    this.findBoundingBox();
};

// Calculate the points for the subdivided curve
Polygon.prototype.updateCurvePoints = function() {
    this.curvePoints = [];
    var q = pow(2, this.resolution);
    var q2 = q * q;
    var n = this.controlPoints.length;
    var p1 = this.controlPoints[n - 2];
    var p2 = this.controlPoints[n - 1];
    var p3, a, b, c, s, t, x, y, i;
    
    for (i = 0; i < n; i++) {
        p3 = this.controlPoints[i];
        
        for (t = 0; t < q; t++) {
            s = q - t - 1;
            a = (s * s + s) * 0.5;
            c = (t * t + t) * 0.5;
            b = q2 - a - c;
            
            x = (p1[0] * a + p2[0] * b + p3[0] * c) / q2;
            y = (p1[1] * a + p2[1] * b + p3[1] * c) / q2;
            this.curvePoints.push([x, y]);
        }
        
        p1 = p2;
        p2 = p3;
    }
};

Polygon.prototype.findBoundingBox = function() {
    var points = this.curvePoints;
    var minX = points[0][0];
    var minY = points[0][1];
    var maxX = minX;
    var maxY = minY;
    
    var p;
    for (var i = 1; i < points.length; i++) {
        p = points[i];
        
        if      (p[0] < minX) { minX = p[0]; }
        else if (p[0] > maxX) { maxX = p[0]; }
        if      (p[1] < minY) { minY = p[1]; }
        else if (p[1] > maxY) { maxY = p[1]; }
    }
    
    this.min[0] = minX;
    this.min[1] = minY;
    this.max[0] = maxX;
    this.max[1] = maxY;
};

Polygon.prototype.draw = function() {
    if (this.strokeWeight) {
        stroke(this.stroke);
        strokeWeight(this.strokeWeight);
    } else {
        noStroke();
    }

    fill(this.fill);
    beginShape();
    for (var i = this.curvePoints.length; i--;) {
        var p = this.curvePoints[i];
        vertex(p[0], p[1]);
    }
    endShape(CLOSE);

    this.addPointCoord = false;
};

Polygon.prototype.pointInside = function(x, y) {
    // Bounding box test
    if (x < this.minX || x > this.maxX ||
        y < this.minY || y > this.maxY) {
            return false;
    }
    
    var inside = false;
    var n = this.curvePoints.length;
    var p1, p2 = this.curvePoints[n - 1];
    for (var i = 0; i < n; i++) {
        p1 = this.curvePoints[i];
        
        if (((p1[1] > y) !== (p2[1] > y)) &&
             (x < (p2[0] - p1[0]) * (y - p1[1]) / (p2[1] - p1[1]) + p1[0])) {
           inside = !inside;
        }
        p2 = p1;
    }
    return inside;
};

Polygon.prototype.mouseOver = function() {
    return this.pointInside(mouseX, mouseY);
};

Polygon.prototype.getShapeAsString = function() {
    var s = "\t{p:[";
    
    for (var i = 0; i < this.controlPoints.length; i++) {
        var p = this.controlPoints[i];
        s += (i ? "," : "") + "[" + round(p[0] * 10) / 10 + "," + (p[1] * 10) / 10 + "]";
    }
    
    s += "]";
    
    if (this.resolution) {
        s += ",r:" + this.resolution;
    }
    
    s += ",f:" + this.fill;
    s += ",s:" + this.stroke;
    
    if (this.strokeWeight) {
        s += ",sw:" + this.strokeWeight;
    }
    
    s += "}";
    
    return s;
};

Polygon.prototype.exportShapeAsPJS = function() {
    var s = "";
    
    if (this.strokeWeight) {
        s += "strokeWeight(" + this.strokeWeight + ");\n";
        s += "stroke(" + red(this.stroke) + ", " + green(this.stroke) + ", " + blue(this.stroke) + ");\n";
    } else {
        s += "noStroke();\n";
    }
    
    s += "fill(" + red(this.fill) + ", " + green(this.fill) + ", " + blue(this.fill) + ");\n";
    s += "beginShape();\n";
    
    var oldX, oldY;
    for (var i = 0; i < this.curvePoints.length; i++) {
        var p = this.curvePoints[i];
        var x = round(p[0] * 10) / 10;
        var y = round(p[1] * 10) / 10;
        
        if (oldX !== x || oldY !== y) {
            s += "vertex(" + x + ","  + y + ");\n";
        }
        
        oldX = x;
        oldY = y;
    }
    s += "endShape(CLOSE);";
    return s;
};

Polygon.prototype.exportToSVG = function() {
    var s = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + width + ' ' + height + '">\n';

    var r = red(this.color);
    var g = green(this.color);
    var b = blue(this.color);
    var c = "rgb(" + r + ", " + g + ", " + b + ");";
    
    s += '\t<path style="stroke:' + c + 'stroke-width:3px;fill:' + c + ';fill-opacity:0.5" d="M';
    for (var i = 0; i < this.curvePoints.length; i++) {
        var p = this.curvePoints[i];
        var x = round(100 * p[0]) / 100;
        var y = round(100 * p[1]) / 100;
        s += x  + ","  + y + " ";
        if (!i) { s += "L"; }
    }
    s += 'z"/>\n</svg>';
    println(s);
};
}
/*****************************************************
 *      TargetShape
 * Wrapper for the shape currently selected. Allows
 * the toolbars to target the correct shape easily.
 * Deals with all the functions that edit the shape.
******************************************************/

var TargetShape = {
    shape: null,
    index: null,
    
    // Null transforms
    translateX: 0,
    translateY: 0,
    scaleX: 1,
    scaleY: 1,
    rotateAngle: 0,
    
    // Record start of transformation
    startX: 0,
    startY: 0,
    startAngle: 0,
    
    toolbars: {},
    handles: [],
    
    draggingPoint: null,
    selectedPoint: null,
    addPointCoord: null,
    dragUpdate: null,
    clickUpdate: null,
    
    // Pick what shape is selected
    set: function(shape, index) {
        this.shape = shape;
        this.index = index;
        
        // Set values of toolbars to target shape's values
        for (var t in this.toolbars) {
            this.toolbars[t].setValue(shape[t]);
        }
        
        // Set the mode to update selection boxes
        this.setMode(this.mode);
    },
    
    // Set the property of the target shape equal to the toolbar value
    updateProperty: function(property) {
        var toolbar = this.toolbars[property];
        if (this.shape && toolbar) {
            this.shape[property] = toolbar.value;
        }
    },
    
    // Set edit mode (from a toolbar)
    setMode: function(mode) {
        this.mode = mode;
        
        var shape = this.shape;
        if (!shape) { return; }
        
        if (mode === 'Scale') {
            this.outline = this.drawBoundingBox;
            this.setBoundingBoxHandles(shape);
            this.clickUpdate = this.initialiseScaling;
            this.dragUpdate = this.updateScale;
        } else if (mode === 'Rotate') {
            this.outline = this.drawBoundingBox;
            this.setBoundingBoxHandles(shape);
            this.clickUpdate = this.initialiseRotation;
            this.dragUpdate = this.updateRotation;
        } else if (mode === 'Points') {
            this.outline = this.drawControlArms;
            this.setControlPointHandles(shape);
            this.dragUpdate = this.updateEditPoint;
        }
    },
    
    setBoundingBoxHandles: function(shape) {
        this.handles = [
            new DraggablePoint(shape.min, shape.min),
            new DraggablePoint(shape.max, shape.min),
            new DraggablePoint(shape.max, shape.max),
            new DraggablePoint(shape.min, shape.max)
        ];
    },
    
    setControlPointHandles: function(shape) {
        // Handles to map to control points and update them
        this.handles = shape.controlPoints.map(
            function(p) {
                return new DraggablePoint(p, p);
            }
        );
    },
    
    setOrigin: function(x, y) {
        this.translateX = x;
        this.translateY = y;
        this.translate(-x, -y);
    },
    
    // Called when scaling handle selected
    initialiseScaling: function(i) {
        // Scale using the opposite point as the origin
        var origin = this.handles[(i + 2) % 4];
        this.setOrigin(origin.x, origin.y);
        this.startX = this.draggingPoint.x;
        this.startY = this.draggingPoint.y;
    },
    
    initialiseRotation: function(i) {
        // Scale using the opposite point as the origin
        this.setOrigin(this.shape.center[0], this.shape.center[1]);
        this.startAngle = atan2(this.draggingPoint.y, this.draggingPoint.x);
    },
    
    updateScale: function(dx, dy) {
        this.draggingPoint.x += dx;
        this.draggingPoint.y += dy;
        this.scaleX = this.draggingPoint.x / this.startX;
        this.scaleY = this.draggingPoint.y / this.startY;
    },
    
    updateRotation: function(dx, dy) {
        this.rotateAngle = atan2(mouseY - this.translateY, mouseX - this.translateX) - this.startAngle;
    },
    
    updateEditPoint: function(dx, dy) {
        this.draggingPoint.x += dx;
        this.draggingPoint.y += dy;
        this.shape.updateShape();
    },
    
    draw: function() {
        pushMatrix();
        translate(this.translateX, this.translateY);
        rotate(this.rotateAngle);
        scale(this.scaleX, this.scaleY);
        
        this.shape.draw();
        
        popMatrix();
        this.addPointCoord = false;
    },
    
    drawOutline: function() {
        if (!this.outline) {
            // For the first case
            this.outline = this.drawBoundingBox;
        }
        
        var shape = this.shape;
        if (!shape) { return; }
        pushMatrix();
        translate(this.translateX, this.translateY);
        rotate(this.rotateAngle);
        
        this.outline(shape);
        this.drawHandles();
        
        popMatrix();
    },
    
    drawBoundingBox: function(shape) {
        var x = shape.min[0];
        var y = shape.min[1];

        noFill();
        strokeWeight(1);
        stroke(CONTROL_ARMS);
        rect(x, y, shape.max[0] - x, shape.max[1] - y);
        
        // Center point
        var r = 10;
        var r2 = 0.5 * r + 3;
        var r3 = r2 + 6;
        var cx = shape.center[0];
        var cy = shape.center[1];
        ellipse(cx + 0.5, cy + 0.5, r, r);
        line(cx, cy - r2, cx, cy - r3);
        line(cx, cy + r2, cx, cy + r3);
        line(cx - r2, cy, cx - r3, cy);
        line(cx + r2, cy, cx + r3, cy);
    },
    
    drawControlArms: function(shape) {
        stroke(CONTROL_ARMS);
        strokeWeight(1);
        var i, n = this.handles.length;
        var p1, p2 = this.handles[n - 1];
        
        for (i = 0; i < n; i++) {
            p1 = this.handles[i];
            line(p1.x, p1.y, p2.x, p2.y);
            p2 = p1;
        }
        
        if (!this.draggingPoint) {
            this.drawControlPointAddition();
        }
    },
    
    drawHandles: function() {
        for (var i = this.handles.length; i--;) {
            this.handles[i].draw();
        }
    },
    
    drawControlPointAddition: function() {
        // Show point where a control point could be added
        
        var x = mouseX;
        var y = mouseY;
        var i, n = this.handles.length;
        
        // Check whether mouse isn't too close to a control point
        for (i = n; i--;) {
            if (this.handles[i].mouseOver()) {
                return;
            }
        }
        
        // Test whether mouse is within a certain distance from a control arm
        
        var p1, p2 = this.handles[n - 1];
        var lx, ly, mx, my, w, px, py;
        
        for (i = 0; i < n; i++) {
            p1 = this.handles[i];
            
            // Project (x, y) onto line p1 - p2
            lx = p1.x - p2.x;
            ly = p1.y - p2.y;
            mx = x - p2.x;
            my = y - p2.y;
            w = (mx * lx + my * ly ) / (lx * lx + ly * ly);
            
            if (w > 0 && w < 1) {
                px = p1.x * w + p2.x * (1 - w);
                py = p1.y * w + p2.y * (1 - w);
                
                // Check mouse is within 8 units of the line
                if ((px - x) * (px - x) + (py - y) * (py - y) <= 64) {
                    this.addPointCoord = {
                        x: px, y: py, index: i
                    };
                    
                    stroke(PINK);
                    strokeWeight(2);
                    fill(PINK + (180 << 24));
                    ellipse(px, py, 16, 16);
                    break;
                }
            }
            
            p2 = p1;
        }
    },
    
    transform: function(transformation) {
        this.shape.curvePoints.forEach(transformation);
        this.shape.controlPoints.forEach(transformation);
    },

    translate: function(dx, dy) {
        var _translate = function(p) {
            p[0] += dx;
            p[1] += dy;
        };
        
        this.transform(_translate);
        
        // Move this to transform function ?
        _translate(this.shape.min);
        _translate(this.shape.max);
    },
    
    scale: function(sx, sy) {
        var _scale = function(p) {
            p[0] *= sx;
            p[1] *= sy;
        };
        
        this.transform(_scale);
    },
    
    rotate: function(angle) {
        var cAngle = cos(angle);
        var sAngle = sin(angle);
        
        var _rotate = function(p) {
            var x = p[0];
            var y = p[1];
            p[0] = cAngle * x - sAngle * y;
            p[1] = sAngle * x + cAngle * y;
        };
        
        this.transform(_rotate);
        this.shape.findBoundingBox();
    },
    
    deletePoint: function() {
        if (this.selectedPoint !== null &&
            this.shape.controlPoints.length > 3) {
                this.shape.controlPoints.splice(this.selectedPoint, 1);
                this.shape.updateShape();
                this.setControlPointHandles(this.shape);
                this.selectedPoint = false;
        }
    },
    
    addPointAt: function(p) {
        var shape = this.shape;
        
        if (shape) {
            shape.controlPoints.splice(p.index, 0, [p.x, p.y]);
            shape.updateShape();
            this.setControlPointHandles(shape);
        }
        
    },
    
    pointInside: function(x, y) {
        return this.shape.pointInside(x, y);
    },
    
    exportShapeAsPJS: function() {
        if (this.shape) {
            return this.shape.exportShapeAsPJS();
        }
    },
    
    getShapeAsString: function() {
        if (this.shape) {
            return this.shape.getShapeAsString();
        }
    },
    
    mousePressed: function() {
        // If the mouse is over a point where it
        // can add a point, then take note
        this.canAddPoint = this.addPointCoord;
        
        for (var i = this.handles.length; i--;) {
            if (this.handles[i].mouseOver()) {
                this.draggingPoint = this.handles[i];
                this.draggingPoint.dragging = true;
                if (this.clickUpdate) {
                    this.clickUpdate(i);
                }
                return true;
            }
        }
        
        return this.canAddPoint;
    },
    
    mouseDragged: function() {
        // Don't drag shape if we're going to add a point
        if (this.canAddPoint) { return; }
        
        var dx = mouseX - pmouseX;
        var dy = mouseY - pmouseY;

        if (this.draggingPoint) {
            if (this.dragUpdate) {
                this.dragUpdate(dx, dy);
            } else {
                this.draggingPoint.x += dx;
                this.draggingPoint.y += dy;
            }
        } else {
            this.translateX += dx;
            this.translateY += dy;
        }
    },
    
    mouseReleased: function() {
        // Permenantly rotate shape
        if (this.rotateAngle) {
            this.rotate(this.rotateAngle);
            this.rotateAngle = 0;
        }
        
        // Permenantly scale shape
        if (this.scaleX || this.scaleY) {
            this.scale(this.scaleX, this.scaleY);
            this.scaleX = 1;
            this.scaleY = 1;
        }
        
        // Permenantly translate shape
        if (this.translateX || this.translateY) {
            this.translate(this.translateX, this.translateY);
            this.translateX = 0;
            this.translateY = 0;
        }
        
        // Deselect dragged a point
        if (this.draggingPoint) {
            this.draggingPoint.dragging = false;
            this.draggingPoint = false;
        }
        
        // Test whether we have selected a control point
        this.selectedPoint = null;
        if (this.mode === 'Points') {
            for (var i = this.handles.length; i--;) {
                if (this.handles[i].mouseOver()) {
                    this.selectedPoint = i;
                    this.handles[i].selected = true;
                } else {
                    this.handles[i].selected = false;
                }
            }
        }
        
        if (this.addPointCoord && this.canAddPoint) {
            this.addPointAt(this.addPointCoord);
        }
    }
};

/*****************************************************
 *      Canvas
 * Contains all the shapes and functions for dealing
 * with them
******************************************************/

var canvas = {
    shapes: [],
    selected: null,
    
    init: function(shapes) {
        for (var i = 0, n = shapes.length; i < n; i++) {
            this.addShape(shapes[i], true);
        }
    },
    
    draw: function() {
        // Draw shapes
        for (var i = 0; i < this.shapes.length; i++) {
            this.shapes[i].draw();
        }
        
        // Highlight selected shape
        TargetShape.drawOutline();
    },
    
    addShape: function(shapeData, initialShapes) {
        if (!shapeData) {
            shapeData = {
                p: [[360,150],[260,300],[460,300]]
            };
        }
        
        if (shapeData.p && shapeData.p.length > 2) {
            var polygon = new Polygon(shapeData);
            this.shapes.push(polygon);
            if (!initialShapes) {
                this.selectShape(polygon);
                return polygon;
            }
        }
    },
    
    copyShape: function() {
        if (!TargetShape.shape) { return; }
        
        this.clipboard = {
            r: TargetShape.shape.resolution,
            f: TargetShape.shape.fill,
            s: TargetShape.shape.stroke,
            sw: TargetShape.shape.strokeWeight,
        };
        
        this.clipboard.p = TargetShape.shape.controlPoints.slice(0);
    },
    
    pasteShape: function() {
        if (this.clipboard) {
            this.addShape(this.clipboard);
            TargetShape.translate(10, 10);
        }
    },
    
    moveShapeZ: function(dir) {
        if (TargetShape.shape) {
            var index = TargetShape.index + dir;
            if (index > -1 && index < this.shapes.length) {
                // Swap layers
                this.shapes[index - dir] = this.shapes[index];
                this.shapes[index] = TargetShape;
                TargetShape.index = index;
            }
        }
    },
    
    deleteShape: function() {
        if (TargetShape.shape) {
            removeFromArray(this.shapes, TargetShape.shape);
            this.deselectShape();
        }
    },
    
    getShapeAtPoint: function(x, y) {
        // Go in reverse order to select top shape first
        for (var i = this.shapes.length; i--;) {
            if (this.shapes[i].canAddPoint ||
                this.shapes[i].pointInside(x, y)) {
                return this.shapes[i];
            }
        }
    },
    
    selectShape: function(shape) {
        // Check we're selected a new shape
        if (TargetShape !== shape) {
            
            // Deselect existing shape
            this.deselectShape();
            
            // Check shape is in shapes array
            // I can't imagine why it wouldn't be
            var index = this.shapes.indexOf(shape);
            
            if (index > -1) {
                // Create wrapper around shape
                TargetShape.set(shape, index);
                
                // Replace shape with wrapped shape
                this.shapes[index] = TargetShape;
            }
        }
    },
    
    deselectShape: function() {
        if (TargetShape.shape) {
            // Replace wrapped shape with original shape
            this.shapes[TargetShape.index] = TargetShape.shape;
            TargetShape.shape = null;
            //toolbars.hideToolbar('shape');
        }
    },
    
    saveShapeCode: function() {
        // Save shapes in a form that can be pasted at the top of this curve
        
        var s = "var shapes = [\n";
        var n = this.shapes.length;
        
        for (var i = 0; i < n; i++) {
            s += this.shapes[i].getShapeAsString();
            s += (i < n - 1) ? ",\n" : "\n";
        }
        
        s += "];";
        
        println(s);
    },
    
    exportShapesAsPJS: function() {
        // Save shapes in a form that can be pasted at the top of this curve
        
        var s = "";
        var n = this.shapes.length;
        
        for (var i = 0; i < n; i++) {
            s += this.shapes[i].exportShapeAsPJS();
            s += (i < n - 1) ? "\n" : "";
        }
        
        println(s);
    },
    
    mousePressed: function() {
        // If a shape is already selected, and we select
        // one of its control points, quit now.
        if (this.selected && TargetShape.mousePressed()) {
            return;
        }
        
        // Otherwise test for hitting a new shape
        this.selected = this.getShapeAtPoint(mouseX, mouseY);
        if (this.selected) {
            this.selectShape(this.selected);
            TargetShape.mousePressed();
        } else {
            this.deselectShape();
        }
    },
    
    mouseDragged: function() {
        if (this.selected) {
            TargetShape.mouseDragged();
        }
    },
    
    mouseReleased: function() {
        if (this.selected) {
            TargetShape.mouseReleased();
        }
    }
};

/**************************************
 * Object to handle multiple toolbars
***************************************/

toolbars = {
    units: [],
    
    init: function() {
        // Check whether a shape is selected
        // Use to disable GUI elements
        var checkForShape = function() {
            return !TargetShape.shape;
        };
        
        // Create toolbars
        var mainToolbar = new MenuBar(20);
        var shapeToolbar = new Toolbar(5, height - 280, 120);
        
        shapeToolbar.disabledFunc = checkForShape;
        
        // Attach toolbars
        this.units = [mainToolbar, shapeToolbar];
        
        // Add menus
        mainToolbar.addMenu('File');
        mainToolbar.addMenu('Edit');
        mainToolbar.addMenu('Transform');
        mainToolbar.addMenu('Layers');
        mainToolbar.addMenu('Points');
        
        // File menu has svaing and clearing of the whole canvas
        mainToolbar.addMenuItem('File', {
            name: 'New canvas',
            trigger: function() {
                canvas.shapes = [];
                canvas.selected = false;
            }
        });
        mainToolbar.addMenuItem('File', {
            name: 'Save canvas',
            trigger: canvas.saveShapeCode.bind(canvas)
        });
        mainToolbar.addMenuItem('File', {
            name: 'Export as PJS',
            trigger: canvas.exportShapesAsPJS.bind(canvas)
        });
        
        // Edit menu allows copy, pasting, adding and deleting shapes
        mainToolbar.addMenuItem('Edit', {
            name: 'New shape',
            trigger: canvas.addShape.bind(canvas),
        });
        mainToolbar.addMenuItem('Edit', {
            name: 'Delete shape',
            trigger: (canvas.deleteShape).bind(canvas),
            disabledFunc: checkForShape
        });
        mainToolbar.addMenuItem('Edit', {
            name: 'Copy shape',
            trigger: (canvas.copyShape).bind(canvas),
            disabledFunc: checkForShape
        });
        mainToolbar.addMenuItem('Edit', {
            name: 'Paste shape',
            trigger: function() {
                canvas.pasteShape(TargetShape.shape);
            },
            disabledFunc: function() {
                return !canvas.clipboard;
            }
        });
        
        // Transform menu applies transforms to selected shape
        mainToolbar.addMenuItem('Transform', {
            name: 'Scale',
            trigger: function() {
                TargetShape.setMode('Scale');
            },
            disabledFunc: checkForShape
        });
        mainToolbar.addMenuItem('Transform', {
            name: 'Rotate',
            trigger: function() {
                TargetShape.setMode('Rotate');
            },
            disabledFunc: checkForShape
        });
        mainToolbar.addMenuItem('Transform', {
            name: 'Flip horizontal',
            trigger: function() {
                if (TargetShape.shape) {
                    var cx = TargetShape.shape.center[0];
                    TargetShape.transform(function(p) {
                        p[0] = cx * 2 - p[0];
                    });
                }
            },
            disabledFunc: checkForShape
        });
        mainToolbar.addMenuItem('Transform', {
            name: 'Flip vertical',
            trigger: function() {
                if (TargetShape.shape) {
                    var cy = TargetShape.shape.center[1];
                    TargetShape.transform(function(p) {
                        p[1] = cy * 2 - p[1];
                    });
                }
            },
            disabledFunc: checkForShape
        });
        
        // Layers menu controls where shape is in z-axis
        mainToolbar.addMenuItem('Layers', {
            name: 'Move up',
            trigger: function() {
                canvas.moveShapeZ(1);
            },
            disabledFunc: function() {
                return !TargetShape.shape || TargetShape.index === canvas.shapes.length - 1;
            }
        });
        mainToolbar.addMenuItem('Layers', {
            name: 'Move down',
            trigger: function() {
                canvas.moveShapeZ(-1);
            },
            disabledFunc: function() {
                return !TargetShape.shape || TargetShape.index === 0;
            }
        });
        mainToolbar.addMenuItem('Layers', {
            name: 'Move to top',
            trigger: function() {
                if (TargetShape.shape) {
                    removeFromArray(canvas.shapes, TargetShape);
                    canvas.shapes.push(TargetShape);
                    TargetShape.index = canvas.shapes.length - 1;
                }
                
            },
            disabledFunc: function() {
                return !TargetShape.shape || TargetShape.index === canvas.shapes.length - 1;
            }
        });
        mainToolbar.addMenuItem('Layers', {
            name: 'Move to bottom',
            trigger: function() {
                if (TargetShape.shape) {
                    removeFromArray(canvas.shapes, TargetShape);
                    canvas.shapes.unshift(TargetShape);
                    TargetShape.index = 0;
                }
                
            },
            disabledFunc: function() {
                return !TargetShape.shape || TargetShape.index === 0;
            }
        });
        
        // Points menu edits the control points
        mainToolbar.addMenuItem('Points', {
            name: 'Edit points',
            trigger: function() {
                TargetShape.setMode('Points');
            },
            disabledFunc: checkForShape
        });
        mainToolbar.addMenuItem('Points', {
            name: 'Delete point',
            trigger: TargetShape.deletePoint.bind(TargetShape),
            disabledFunc: function() {
                return !TargetShape.shape ||
                        TargetShape.selectedPoint === null ||
                        TargetShape.handles.length < 4;
            }
        });
        
        // Allow toolbars to be updated when a new shape is selected
        var toolbars = TargetShape.toolbars;
        
        toolbars.resolution = shapeToolbar.add(Slider, {
            max: 5,
            name: "Subdivisions",
            trigger: function() {
                var target = TargetShape.shape;
                if (target && target.resolution !== this.value) {
                    target.resolution = this.value;
                    target.updateShape();
                }
            }
        });
        toolbars.strokeWeight = shapeToolbar.add(Slider, {
            max: 20,
            name: "Stroke weight",
            trigger: function() {
                TargetShape.updateProperty('strokeWeight');
            }
        });
        toolbars.stroke = shapeToolbar.add(Swatch, {
            name: "Stroke",
            update: function() {
                TargetShape.updateProperty('stroke');
            }
        });
        toolbars.strokeBrightness = shapeToolbar.add(Slider, {
            name: "Stroke brightness",
            max: 255,
            trigger: function() {
                toolbars.stroke.bri = this.value / 255;
                toolbars.stroke.updateColor();
                TargetShape.updateProperty('stroke');
            }
        });
        toolbars.fill = shapeToolbar.add(Swatch, {
            name: "Fill",
            update: function() {
                TargetShape.updateProperty('fill');
            }
        });
        toolbars.fillBrightness = shapeToolbar.add(Slider, {
            name: "Fill brightness",
            max: 255,
            trigger: function() {
                toolbars.fill.bri = this.value / 255;
                toolbars.fill.updateColor();
                TargetShape.updateProperty('fill');
            }
        });
    },
    
    draw: function() {
        for (var i = this.units.length; i--;) {
            this.units[i].draw();
        }
    },
    
    // Return true if toolbar element clicked on and 
    // sets active element if one activated
    mousePressed: function() {
        if (this.active) {
            this.active.mousePressed();
            if (!this.active.active) {
                this.active = false;
            }
            return true;
        } else {
            for (var i = this.units.length; i--;) {
                if (this.units[i].disable) { continue; }
                
                var hit = this.units[i].mousePressed();

                if (hit) {
                    // If hit is true, then mouseevent
                    // captured but nothing active
                    if (hit !== true) {
                        this.active = this.units[i];
                    }
                    return true;
                }
            }
        }
    },
    
    mouseDragged: function() {
        if (this.active) {
            this.active.mouseDragged();
        }
    },
    
    mouseReleased: function() {
        if (this.active) {
            if (!this.active.mouseReleased()) {
                this.active = false;
            }
        }
    }
};

/*******************************************************
 * Tooltip bar along the bottom of the screen gives
 * information about what the buttons do
********************************************************/

tooltip = {
    h: 18,
    y: height - 18,
    
    txt: "",
    
    draw: function() {
        fill(MENU_COLOR);
        strokeWeight(1);
        stroke(180);
        rect(-1, this.y, width + 1, this.h);
        
        fill(TEXTCOL);
        textAlign(LEFT, CENTER);
        textFont(sansFont, 13);
        text(this.txt, 5, this.y + this.h * 0.5);
    }
};

/*******************************************************
 *      Initialisation
********************************************************/

toolbars.init();
canvas.init(shapes);

/*******************************************************
 *      Main loop
********************************************************/

draw = function() {
    if (!swatch) { swatch = createSwatch(128, 1); }
    background(BACKGROUND);
    cursor('default');
    
    canvas.draw();
    toolbars.draw();
    tooltip.draw();
};

/*******************************************************
 *      Event handling
********************************************************/
{
mousePressed = function() {
    // We don't want to deselect on the canvas if a
    // toolbar element is active
    if (!toolbars.mousePressed()) {
        canvas.mousePressed();
    }
};

mouseDragged = function() {
    if (toolbars.active) {
        toolbars.mouseDragged();
    } else {
        canvas.mouseDragged();
    }
};

mouseReleased = function() {
    if (toolbars.active) {
        toolbars.mouseReleased();
    } else {
        canvas.mouseReleased();
    }
};

keyPressed = function() {
    var k = key.toString();
    if (shortcuts[k]) {
        //TargetShape.setMode(shortcuts[k]);
    }
};
}
