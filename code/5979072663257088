/********************************************************
 *  Defining RGB with R = z, G = y, B = x
 * 
 * TODO:
 *  Find a more efficient way to calculate positions
*********************************************************/

var BACKGROUND = color(250, 250, 250);
var TEXTCOL = color(20, 20, 20);
var TOOLBAR = color(230, 230, 230, 200);

var sansFont = createFont("sans", 15);
var serifFont = createFont("serif", 16);

var DOT_SIZE = 16;
var AXIS_SIZE = 90;
var persp = 800;

/********************************************************
 *      Initial values
*********************************************************/

// Angles of rotation for camera
var xRotate = 45;
var yRotate = 20;
var rotationMatrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];

// RGB amounts as proportions in the range 0 - 1.
var colors = [0.2, 0.5, 0.8];
// RGB in opposite order, as R = z, G = y, B = x
var letters = ['B', 'G', 'R'];

// GUI functions
{
/******************************************
 * Generic GUI component from which other
 * elements inherit
 * The default object is basically a button
*******************************************/
{
var GUI_Component = function(x, y, w, h, name, updateFunction) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.name = name;
    
    if (updateFunction) {
        this.trigger = updateFunction.bind(this);
    }
    
    this.selected = false;
    this.disabled = false;
    this.transition = 0;
};

GUI_Component.prototype.draw = function() {
    if (this.mouseOver()) {
        fill(100);
    } else {
        fill(200);
    }
    
    noStroke();
    rect(this.x, this.y, this.w, this.h, 12);
    
    fill(20);
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2 + 1);
};

GUI_Component.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h);
};

GUI_Component.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
};

GUI_Component.prototype.mouseDragged = function() {};

GUI_Component.prototype.mouseReleased = function() {
    if (this.selected && !this.disabled && this.mouseOver()) {
        this.trigger();
    }
    this.selected = false;
};

GUI_Component.prototype.trigger = function() {
    // To be over-written
};

GUI_Component.prototype.fade = function() {
    if (this.selected || this.mouseOver()) {
        this.transition = min(10, this.transition + 1);
    } else {
        this.transition = max(0, this.transition - 1);
    }
};
}
/******************************************
 *      GUI Button
*******************************************/
{
var Button = function(x, y, w, h, params) {
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    this.defaultCol = TOOLBAR;
    this.highlightCol = params.highlightCol || color(210, 210, 210, 250);
    if (params.filled) {
        this.makeFilled();
    }
};
Button.prototype = Object.create(GUI_Component.prototype);

Button.prototype.draw = function() {
    this.fade();
    
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(200);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 12);
    
    if (this.disabled) {
        fill(120);
    } else {
        fill(TEXTCOL);
    }
    
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2 + 1);
};

Button.prototype.drawFilled = function() {
    this.fade();
    
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(this.highlightCol);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 19);
    
    if (this.disabled) {
        fill(120);
    } else {
        fill(lerpColor(this.highlightCol, color(255, 255, 255), this.transition / 10));
    }
    
    textFont(sansFont, 16);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2);
};

Button.prototype.makeFilled = function() {
    this.draw = this.drawFilled;
    this.defaultCol = color(0, 0, 0, 1);
};

var RadioButton = function(x, y, w, h, name, trigger) {
    Button.call(this, x, y, w, h, {name: name, trigger: trigger});
    this.r = this.h - 6;
    this.cx = this.x + this.r / 2 + 5;
    this.cy = this.y + this.h / 2;
    this.marked = false;
};
RadioButton.prototype = Object.create(Button.prototype);

RadioButton.prototype.draw = function() {
    this.fade();
    
    if (this.transition) {
        noStroke();
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        rect(this.x, this.y, this.w, this.h + 1, 4);
    }
    
    fill(10);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    text(this.name, this.cx + this.r /2 + 4, this.cy + 1);
    
    noFill();
    stroke(10);
    strokeWeight(1);
    ellipse(this.cx, this.cy, this.r, this.r);
    
    if (this.marked) {
        fill(10);
        ellipse(this.cx, this.cy, this.r / 2, this.r / 2);
    }
};
}
/******************************************
 *      GUI Slider
*******************************************/
{
var Slider = function(x, y, w, h, params) {
    // Size of ball
    this.ballR = 14;
    this.ballD = this.ballR * 2;
    
    x += this.ballR;
    w -= this.ballR * 2;
    
    var h = this.ballD + (params.name ? 16 : 0);
    y += h - this.ballR;
    
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    
    this.x2 = x + w;
    this.fill = params.fill || color(240);
    this.stroke = params.stroke || color(180);
    
    this.min = params.min || 0;
    this.max = params.max === undefined ? 1 : params.max;
    this.val = params.now === undefined ? this.min : params.now;
    this.decimalPlaces = params.decimalPlaces === undefined ? 0 : params.decimalPlaces;
    this.setValue(this.val);
    this.trigger();
};
Slider.prototype = Object.create(GUI_Component.prototype);

Slider.prototype.draw = function() {
    if (this.name) {
        fill(20);
        textSize(16);
        textAlign(CENTER, BASELINE);
        text(this.name,  this.x + this.w / 2, this.y - 15);
        //text(this.name + ": " + this.val,  this.x + this.w / 2, this.y - 14);
    }
    
    this.fade();
    fill(lerpColor(color(this.fill), color(this.stroke), this.transition / 10));
    stroke(this.stroke);
    strokeWeight(3);
    line(this.x, this.y, this.x2, this.y);
    ellipse(this.bx, this.y, this.ballD, this.ballD);
    
    fill(20);
    textSize(13);
    textAlign(CENTER, CENTER);
    text(this.val + "%", this.bx, this.y);
};

Slider.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.bx, this.y) < this.ballR;
};

Slider.prototype.mousePressed = function() {
    if (this.mouseOver()) {
        this.selected = true;
        return true;
    }
};

Slider.prototype.mouseDragged = function() {
    if (this.selected) {
        this.bx = constrain(mouseX, this.x, this.x2);
        var p = pow(10, this.decimalPlaces);
        this.val = round(map(this.bx, this.x, this.x2, this.min, this.max) * p) / p;
        this.trigger();
        return true;
    }
};

Slider.prototype.setValue = function(v) {
    this.val = constrain(v, this.min, this.max);
    this.bx = map(this.val, this.min, this.max, this.x, this.x2);
    this.trigger();
};

var ColorSlider = function(x, y, w, h, params) {
    Slider.call(this, x, y, w, h, params);
    this.saturation = params.saturation || 200;
    this.brightness = params.brightness || 180;
    this.setColor();
};
ColorSlider.prototype = Object.create(Slider.prototype);

ColorSlider.prototype.setColor = function() {
    colorMode(HSB);
    this.color = color(this.val, this.saturation, this.brightness);
    colorMode(RGB);
    this.R = red(this.color);
    this.G = green(this.color);
    this.B = blue(this.color);
};

ColorSlider.prototype.draw = function() {
    if (this.name) {
        fill(20);
        textSize(13);
        textAlign(CENTER, BASELINE);
        text(this.name,  this.x + this.w / 2, this.y - 15);
        //text(this.name + ": " + this.val,  this.x + this.w / 2, this.y - 14);
    }
    
    this.fade();
    fill(this.color);
    strokeWeight(4);
    stroke(this.stroke);
    line(this.x, this.y, this.x2, this.y);
    stroke(250);
    strokeWeight(1);
    ellipse(this.bx, this.y, this.ballD, this.ballD);
};

ColorSlider.prototype.trigger = function() {
    this.setColor();
};

}
/******************************************
 * GUI Label
*******************************************/
var Label = function(x, y, w, h, name, params) {
    this.x1 = x + 8;
    this.x2 = x + w - 8;
    this.y = y + h + 1;
    this.y2 = y + h / 2 + 3;
    this.name = name;
    
    this.fontSize = params.fontSize || 16;
    this.underline = !params.noUnderline;
    this.alignH = params.alignH || CENTER;
    this.alignV = params.alignV || CENTER;
    
    this.x = this.alignH === CENTER ? x + w / 2: this.x1;
};

Label.prototype.draw = function() {
    fill(20);
    textFont(sansFont, this.fontSize);
    textAlign(this.alignH, this.alignV);
    text(this.name, this.x, this.y2);
    
    if (this.underline) {
        strokeWeight(1);
        stroke(20);
        line(this.x1, this.y, this.x2, this.y);
    }
};
/******************************************
 *      Toolbar
 * Container for displaying and handling
 * GUI elements like buttons and sliders.
*******************************************/
{
var Toolbar = function(x, y, w) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = 8;
    this.components = [];
    this.labels = [];
};

Toolbar.prototype.draw = function() {
    fill(250);
    strokeWeight(1);
    stroke(180);
    rect(this.x, this.y, this.w, this.h, 8);
   
    this.components.forEach(function(p) { p.draw(); });
    this.labels.forEach(function(p) { p.draw(); });
};

Toolbar.prototype.add = function(type, params) {
    params = params || {};
    var h = params.h || 20;
    var component = new type(this.x + 5, this.y + this.h, this.w - 10, h, params);
    this.components.push(component);
    this.h += component.h + 8;
};

Toolbar.prototype.addLabel = function(name) {
    var h = 20;
    this.labels.push(new Label(this.x, this.y + this.h, this.w, h, name));
    this.h += h + 8;
};

Toolbar.prototype.addRadioButtons = function(options, trigger, defaultOption) {
    var x = this.x + 3;
    var y = this.y + this.h + 2;
    var w = this.w - 6;
    var radioButtons = [];
    
    var triggerFunction = function() {
        if (!this.marked) {
            this.marked = true;
            
            // Deselected other buttons
            for (var i = 0; i < radioButtons.length; i++) {
                if (radioButtons[i] !== this) {
                    radioButtons[i].marked = false;
                }
            }
        }
        if (trigger) { trigger(this.name); }
    };
    
    for (var i = 0; i < options.length; i++) {
        var button = new RadioButton(x, y, w, 22, options[i], triggerFunction);
        radioButtons.push(button);
        y += 27;
        this.h += 27;
    }
    
    radioButtons[defaultOption || 0].trigger();
    
    this.components = this.components.concat(radioButtons);
    this.h += 2;
};

Toolbar.prototype.mousePressed = function() {
    // Check mouse is over a component
    for (var i = this.components.length; i--;) {
        if (this.components[i].mousePressed()) {
            this.active = this.components[i];
            return this.components[i];
        }
    }
};

Toolbar.prototype.mouseReleased = function() {
    if (this.active) {
        this.active.mouseReleased();
        this.active = false;
    }
};

Toolbar.prototype.mouseDragged = function() {
    if (this.active) {
        this.active.mouseDragged();
    }
};
}
}

/********************************************************
 *      Matrix functions
*********************************************************/

var getRotateXMatrix = function(theta) {
    var c = cos(theta);
    var s = sin(theta);
    return [[1, 0, 0], [0, c, -s], [0, s, c]];
};

var getRotateYMatrix = function(theta) {
    var c = cos(theta);
    var s = sin(theta);
    return [[c, 0, s], [0, 1, 0], [-s, 0, c]];
};

var printlnMatrix = function(m) {
    println("----------");
    for (var i = 0; i < m.length; i++) {
        var row = m[i];
        var s = "";
        for (var j = 0; j < row.length; j++) {
            s += round(1000 * row[j]) / 1000 + "   ";
        }
        println(s);
    }
};

var multiplyMatrices = function(m1, m2) {
    var newMatrix = [];
    var i, j, k, row, v;

    for (i = 0; i < 3; i++) {
        row = [];
        
        for (var j = 0; j < 3; j++) {
            v = 0;
            
            for (k = 0; k < 3; k++) {
                v += m1[i][k] * m2[k][j];
            }
            
            row.push(v);
        }
        
        newMatrix.push(row);
    }
    
    return newMatrix;
};

// Get an array of [x, y] coordinates after applying the rotation matrix
var applyMatrixToNodes = function(m, nodes) {
    var i, n, x, y, z, x2, y2, z2, p, l = nodes.length;
    
    var newNodes = [];
    
    for (i = 0; i < l; i++) {
        n = nodes[i];
        x = n[0];
        y = n[1];
        z = n[2];
        x2 = m[0][0] * x + m[0][1] * y + m[0][2] * z;
        y2 = m[1][0] * x + m[1][1] * y + m[1][2] * z;
        z2 = m[2][0] * x + m[2][1] * y + m[2][2] * z;
        p = persp / (z2 + persp);
        newNodes.push([x2 * p, y2 * p]);
    }
    
    return newNodes;
};

var getRotationMatrix = function() {
    var rx = getRotateXMatrix(yRotate);
    var ry = getRotateYMatrix(xRotate);
    rotationMatrix = multiplyMatrices(rx, ry);
};

var getCameraNodes = function(worldNodes) {
    var rx = getRotateXMatrix(yRotate);
    var ry = getRotateYMatrix(xRotate);
    rotationMatrix = multiplyMatrices(rx, ry);
    return applyMatrixToNodes(rotationMatrix, worldNodes);
};

/********************************************************
 *      Set-up
*********************************************************/

// Points in world space, i.e. irrespective of camera rotation
var worldNodes = [
    [-AXIS_SIZE,  AXIS_SIZE,  AXIS_SIZE],  // Origin
    [ AXIS_SIZE,  AXIS_SIZE,  AXIS_SIZE],  // x-axis
    [ AXIS_SIZE,  AXIS_SIZE, -AXIS_SIZE],
    [-AXIS_SIZE,  AXIS_SIZE, -AXIS_SIZE],  // z-axis
    [-AXIS_SIZE, -AXIS_SIZE,  AXIS_SIZE],  // y-axis
    [ AXIS_SIZE, -AXIS_SIZE,  AXIS_SIZE],
    [ AXIS_SIZE, -AXIS_SIZE, -AXIS_SIZE],
    [-AXIS_SIZE, -AXIS_SIZE, -AXIS_SIZE],
];

var cameraNodes = getCameraNodes(worldNodes);

var toolbar = new Toolbar(5, 70, 120);

/********************************************************
 *      Drawing functions
*********************************************************/

var getRotatedPoint = function(p) {
    return [
        rotationMatrix[0][0] * p[0] + 
        rotationMatrix[0][1] * p[1] +
        rotationMatrix[0][2] * p[2],
        rotationMatrix[1][0] * p[0] +
        rotationMatrix[1][1] * p[1] +
        rotationMatrix[1][2] * p[2]
    ];
};

var drawLine = function(n1, n2, p) {
    var p1 = cameraNodes[n1];
    var p2 = cameraNodes[n2];
    
    // If p is defined, then p2 is p along the line p1 to p2
    if (p !== undefined) {
        var q = 1 - p;
        p2 = [
            p1[0] * q + p2[0] * p,
            p1[1] * q + p2[1] * p,
            p1[2] * q + p2[2] * p,
        ];
    }
    
    //p1 = getRotatedPoint(p1);
    //p2 = getRotatedPoint(p2);
    
    line(p1[0], p1[1], p2[0], p2[1]);
};

var drawQuad = function(n1, n2, n3, n4) {
    var p1 = cameraNodes[n1];
    var p2 = cameraNodes[n2];
    var p3 = cameraNodes[n3];
    var p4 = cameraNodes[n4];
    
    // Edge vectors
    var dx1 = p2[0] - p1[0];
    var dy1 = p2[1] - p1[1];
    var dx2 = p3[0] - p2[0];
    var dy2 = p3[1] - p2[1];
    var dx3 = p4[0] - p3[0];
    var dy3 = p4[1] - p3[1];
    var dx4 = p1[0] - p4[0];
    var dy4 = p1[1] - p4[1];
    
    // If face is facing away from the camera, quit now
    if (dx1 * dy2 - dy1 * dx2 < 0) { return; }
    
    quad(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1], p4[0], p4[1]);
};

/********************************************************
 *      Main loop
*********************************************************/

draw = function() {
    background(BACKGROUND);
    
    pushMatrix();
    translate(200, 200);
    
    strokeWeight(1);
    stroke(40);
    fill(98, 174, 224);
    
    // Axes
    drawQuad(0, 3, 2, 1);   // Bottom
    drawQuad(4, 5, 6, 7);   // Top
    drawQuad(0, 1, 5, 4);
    drawQuad(1, 2, 6, 5);
    drawQuad(2, 3, 7, 6);
    drawQuad(3, 0, 4, 7);

/*
    drawLine(1, 5);
    drawLine(2, 6);
    drawLine(3, 7);
    drawLine(0, 4);
*/

    popMatrix();
};

/********************************************************
 *      Event handling
*********************************************************/

mousePressed = function() {
    //toolbar.mousePressed();
};

mouseDragged = function() {
    var d = 0.4;
    xRotate += d * (pmouseX - mouseX);
    yRotate += d * (mouseY - pmouseY);
    cameraNodes = getCameraNodes(worldNodes);
};

mouseReleased = function() {
    //toolbar.mouseReleased();
};

mouseOut = mouseReleased;
