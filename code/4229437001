
// Final interactive for Patterns 1

// Improve anti-alias speed
// Improve hitting top of scales
// Smooth normals of scale edges
// Improve calculation of which scale sides to test
// Improve test with bottom of leg skin

// Move brightness slider onto colour picker
// Intersections with edges of scales
// Adding site recalculates jitter
// Center align

randomSeed(0);

var IMAGE_WIDTH = 400;
var IMAGE_WIDTH2 = IMAGE_WIDTH / 2;
var IMAGE_HEIGHT = 400;
var IMAGE_X = 160;
var MIN_SITE_DIST = 20;

var BLACK = color(0);

// Initial parameters
var edgeWidth = 95;
var jitter = 0;
var extrude = 10;

// Leg parameters
// Leg position
var legX = 0;
var legY = 400;
var legZ = 1500;

// Leg size (radius including scales)
var legR = IMAGE_WIDTH / PI;
var legR2 = legR * legR;

// Leg size without scales
var scaleThickness = 20;
var legInner = legR - scaleThickness;
var legInner2 = legInner * legInner;

// How big is the gap inside the leg
var legEmpty = legR - 50;
var legEmpty2 = legEmpty * legEmpty;

// Height of leg
var legH = IMAGE_HEIGHT;

// Bounding box
var legX1 = legX - legR;
var legX2 = legX + legR;
var legY1 = legY - legH / 2;
var legY2 = legY + legH / 2;

var legZ1 = legZ - legR;    // Frontmost point of the leg
var legZ2 = legZ * legZ;    // Distance to center squared for intersection calculation
var legDZ = legR2 - legZ2;  // For intersection calculation
// Inner cylinder values
var legIZ1 = legZ - legInner;
var legIDZ = legInner2 - legZ2;

// Light parameters
var lightX = -110;
var lightY = 100;
var lightZ = 1100;

var lightDX = -6;
var lightDY = 4;
var lightDZ = -10;

// Normalise    
var lightD = sqrt(lightDX * lightDX + lightDY * lightDY + lightDZ * lightDZ);
lightDX /= lightD;
lightDY /= lightD;
lightDZ /= lightD;

// How light falls off over distance
var lightIntensity = 160000;

// Used to map point on cylinder to point on surface
var HalfAngle = IMAGE_WIDTH2 / asin(1);

var MAX_TIME = 60;

var sansFont = createFont("sans", 15);
var serifFont = createFont("serif", 16);
var showing = {};

var mode = 'model';

var SWATCHSIZE = 128;
var swatch;
var createSwatch = function(n, brightness) {
    loadPixels();
    var px = imageData.data;
    
    var ni = 1 / n;
    var x, y, h, s, r, g, b, i, f, p, q, t;
    var index;
    
    //var s = 0.5;          // Saturation
    var v = brightness;     // Brightness
    
    for (x = 0; x < n; x++) {
        h = ni * x;     // Hue along x-axis
        for (y = 0; y < n; y++) {
            s = ni * y; // Saturation along y-axis
            //v = ni * y; // Brightness along y-axis
            i = floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            index = x + (y * width) << 2;
            px[index++] = r * 0xFF | 0;
            px[index++] = g * 0xFF | 0;
            px[index++] = b * 0xFF | 0;
        }
    }
    updatePixels();
    return get(0, 0, n, n);
};

// GUI
{
/*************************************************
 * Generic GUI component from which other elements
 * inherit
 * The default object is basically a button
**************************************************/
{
var GUI_Component = function(x, y, w, h, name, updateFunction) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.name = name;
    
    if (updateFunction) {
        this.trigger = updateFunction.bind(this);
    }
    
    this.selected = false;
    this.disabled = false;
    this.transition = 0;
};

GUI_Component.prototype.draw = function() {
    var y = this.y + this.h;
    fill(20);
    stroke(20);
    strokeWeight(2);
    if (this.mouseOver()) {
        line(this.x + 8, y, this.x + this.w - 8, y);
    }
    
    textFont(sansFont, 16);
    textAlign(CENTER, BASELINE);
    text(this.name, this.x + this.w / 2, y - 3);
};

GUI_Component.prototype.mouseOver = function() {
    return (mouseX >= this.x && mouseX <= this.x + this.w &&
            mouseY >= this.y && mouseY <= this.y + this.h);
};

GUI_Component.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
};

GUI_Component.prototype.mouseDragged = function() {};

GUI_Component.prototype.mouseReleased = function() {
    if (this.selected && !this.disabled && this.mouseOver()) {
        this.trigger();
    }
    this.selected = false;
};

GUI_Component.prototype.trigger = function() {
    // To be over-written
};

GUI_Component.prototype.fade = function() {
    if (this.selected || this.mouseOver()) {
        this.transition = min(10, this.transition + 1);
    } else {
        this.transition = max(0, this.transition - 1);
    }
};
}
/*************************************************
 *  GUI Button
**************************************************/
{
var Button = function(x, y, w, h, params) {
    x += 5;
    w -= 10;
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    this.defaultCol = color(235, 235, 235, 240);
    this.highlightCol = params.highlightCol || color(210, 210, 210, 250);
    if (params.filled) {
        this.makeFilled();
    }
};
Button.prototype = Object.create(GUI_Component.prototype);

Button.prototype.draw = function() {
    this.fade();
    
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(200);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 12);
    
    if (this.disabled) {
        fill(120);
    } else {
        fill(20);
    }
    
    textFont(sansFont, 15);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2 + 1);
};

Button.prototype.drawFilled = function() {
    this.fade();
    
    if (this.disabled) {
        fill(180);
        noStroke();
    } else {
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        strokeWeight(1);
        stroke(this.highlightCol);
    }
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 19);
    
    if (this.disabled) {
        fill(120);
    } else {
        fill(lerpColor(this.highlightCol, color(255, 255, 255), this.transition / 10));
    }
    
    textFont(sansFont, 16);
    textAlign(CENTER, CENTER);
    text(this.name, this.x + this.w / 2, this.y + this.h/2);
};

Button.prototype.makeFilled = function() {
    this.draw = this.drawFilled;
    this.defaultCol = color(0, 0, 0, 1);
};

var CheckBox = function(x, y, w, h, name) {
    Button.call(this, x, y, w, h, { name: name });
    this.box = this.h - 6;
    this.bx = this.x + 5;
    this.by = this.y + 3;
};
CheckBox.prototype = Object.create(Button.prototype);

CheckBox.prototype.trigger = function() {
    showing[this.name] = !showing[this.name];  
};

CheckBox.prototype.draw = function() {
    this.fade();
    
    if (this.transition) {
        noStroke();
        fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
        rect(this.x, this.y, this.w, this.h + 1, 4);
    }
    
    fill(20);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    text(this.name, this.x + this.box + 9, this.y + this.h/2 + 1);
    
    noFill();
    stroke(10);
    strokeWeight(1);
    rect(this.bx, this.y + 3, this.box, this.box);

    if (showing[this.name]) {
        line(this.bx + 1, this.by + 1, this.bx + this.box, this.by + this.box);
        line(this.bx + this.box, this.by + 1, this.bx + 1, this.by + this.box);
    }
};
// Button to set a colour
var SwatchButton = function(x, y, w, h, name, colour, updateFunction) {
    Button.call(this, x, y, w, h, {
        name: name,
        trigger: function() {
            this.showSwatch = !this.showSwatch;
        }
    });
    this.color = colour;
    this.hue = hue(this.color) / 255;
    this.sat = saturation(this.color) / 255;
    this.bri = brightness(this.color) / 255;

    this.defaultCol = color(250);
    this.updateFunction = updateFunction;
    
    if (this.updateFunction) { this.updateFunction(); }
    
    this.showSwatch = false;
    this.sx = this.x + this.w + 16;
    this.sy = this.y - 4;
    this.sx2 = this.sx + SWATCHSIZE;
    this.sy2 = this.sy + SWATCHSIZE;
};
SwatchButton.prototype = Object.create(Button.prototype);

SwatchButton.prototype.draw = function() {
    this.fade();
    
    fill(lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
    noStroke();
    
    rect(this.x, this.y - 1, this.w, this.h + 3, 8);
    
    fill(20);
    textFont(sansFont, 15);
    textAlign(LEFT, CENTER);
    var txt = this.name + ":";
    text(txt, this.x + 3, this.y + this.h / 2 + 1);
    
    strokeWeight(1);
    stroke(20);
    fill(this.color);
    rect(this.x + textWidth(txt) + 8, this.y + 2, 16, 16);
    
    // TODO: make a swatch object
    if (this.showSwatch) {
        noStroke();
        fill(0, 0, 0, 50);
        rect(this.sx + 2, this.sy + 2, SWATCHSIZE + 2, SWATCHSIZE + 29);
        fill(0);
        //rect(this.sx, this.sy, SWATCHSIZE, SWATCHSIZE + 30);
        image(swatch, this.sx, this.sy);
        
        noFill();
        strokeWeight(1);
        stroke(255);
        ellipse(this.sx + this.hue * SWATCHSIZE, this.sy + this.sat * SWATCHSIZE, 5, 5);
        
        strokeWeight(2);
        stroke(0);
        rect(this.sx - 1, this.sy - 1, SWATCHSIZE + 2, SWATCHSIZE + 2);
        
        if (this.mouseOverSwatch()) {
            colorMode(HSB);
            var hue = norm(mouseX, this.sx, this.sx2);
            var sat = norm(mouseY, this.sy, this.sy2);
            fill(hue * 255, sat * 255, this.bri * 255);
            rect(this.sx - 1, this.sy2 + 1, SWATCHSIZE + 2, 24);
            colorMode(RGB);
        } else {
            textAlign(CENTER, CENTER);
            fill(0);
            rect(this.sx - 1, this.sy2 + 1, SWATCHSIZE + 2, 24);
            fill(255);
            text("Pick a color", this.sx + SWATCHSIZE / 2, this.sy2 + 12);
        }
    }
};

SwatchButton.prototype.setColor = function() {
    colorMode(HSB);
    this.color = color(this.hue * 255, this.sat * 255, this.bri * 255);
    colorMode(RGB);
};

SwatchButton.prototype.findColor = function() {
    this.hue = norm(mouseX, this.sx, this.sx2);
    this.sat = norm(mouseY, this.sy, this.sy2);
};

SwatchButton.prototype.mouseOverSwatch = function() {
    return mouseX >= this.sx && mouseX <= this.sx2 &&
           mouseY >= this.sy && mouseY <= this.sy2;
};

SwatchButton.prototype.mousePressed = function() {
    this.selected = this.mouseOver();
    if (this.showSwatch && !this.mouseOverSwatch()) {
        this.showSwatch = false;
    }
};

SwatchButton.prototype.mouseReleased = function() {
    if (this.selected && this.mouseOver()) {
        this.trigger();
    } else if (this.showSwatch) {
        if (this.mouseOverSwatch()) {
            this.findColor();
            this.setColor();
            if (this.updateFunction) {
                this.updateFunction(this.color);
            }
        } else {
            this.showSwatch = false;
        }
    }
    this.selected = false;
};
}
/*************************************************
 * GUI Slider
**************************************************/
{
var Slider = function(x, y, w, h, params) {
    // Size of ball
    this.ballR = 12;
    this.ballD = this.ballR * 2;
    
    x += this.ballR;
    w -= this.ballR * 2;
    
    var h = this.ballD + (params.name ? 16 : 0);
    y += h - this.ballR;
    
    GUI_Component.call(this, x, y, w, h, params.name, params.trigger);
    
    this.x2 = x + w;
    this.fill = params.fill || color(240);
    this.stroke = params.stroke || color(180);
    
    this.min = params.min || 0;
    this.max = params.max === undefined ? 1 : params.max;
    this.val = params.now === undefined ? this.min : params.now;
    this.decimalPlaces = params.decimalPlaces === undefined ? 0 : params.decimalPlaces;
    this.setValue(this.val);
    this.trigger();
};
Slider.prototype = Object.create(GUI_Component.prototype);

Slider.prototype.draw = function() {
    if (this.name) {
        fill(20);
        textSize(13);
        textAlign(CENTER, BASELINE);
        text(this.name,  this.x + this.w / 2, this.y - 15);
        //text(this.name + ": " + this.val,  this.x + this.w / 2, this.y - 14);
    }
    
    this.fade();
    fill(lerpColor(color(this.fill), color(this.stroke), this.transition / 10));
    stroke(this.stroke);
    strokeWeight(3);
    line(this.x, this.y, this.x2, this.y);
    ellipse(this.bx, this.y, this.ballD, this.ballD);
    
    fill(20);
    textSize(11);
    textAlign(CENTER, CENTER);
    text("" + this.val, this.bx, this.y);
};

Slider.prototype.mouseOver = function() {
    return dist(mouseX, mouseY, this.bx, this.y) < this.ballR;
};

Slider.prototype.mousePressed = function() {
    if (this.mouseOver()) {
        this.selected = true;
        return true;
    }
};

Slider.prototype.mouseDragged = function() {
    if (this.selected) {
        this.bx = constrain(mouseX, this.x, this.x2);
        var p = pow(10, this.decimalPlaces);
        this.val = round(map(this.bx, this.x, this.x2, this.min, this.max) * p) / p;
        //this.trigger();
    }
};

Slider.prototype.mouseReleased = function() {
    if (this.selected) {
        this.trigger();
    }
    this.selected = false;
};

Slider.prototype.setValue = function(v) {
    this.val = constrain(v, this.min, this.max);
    this.bx = map(this.val, this.min, this.max, this.x, this.x2);
    this.trigger();
};
}
/*************************************************
 * GUI Label
**************************************************/
var Label = function(x, y, w, h, name) {
    this.x = x + w / 2;
    this.x1 = x + 8;
    this.x2 = x + w - 8;
    this.y = y + h - 4;
    this.name = name;
};

Label.prototype.draw = function() {
    fill(40);
    textFont(sansFont, 16);
    textAlign(CENTER, BASELINE);
    text(this.name, this.x, this.y - 2);
    
    strokeWeight(1);
    stroke(40);
    line(this.x1, this.y, this.x2, this.y);
};
/*************************************************
 *      Toolbar
 * A container for buttons and sliders.
**************************************************/
{
var Toolbar = function(x, y, w) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = 8;
    this.components = [];
    this.labels = [];
};

Toolbar.prototype.draw = function() {
    fill(250);
    strokeWeight(1);
    stroke(180);
    rect(this.x, this.y, this.w, this.h, 8);
   
    this.components.forEach(function(p) { p.draw(); });
    this.labels.forEach(function(p) { p.draw(); });
};

Toolbar.prototype.add = function(type, params) {
    params = params || {};
    var h = params.h || 20;
    var component = new type(this.x + 5, this.y + this.h, this.w - 10, h, params);
    this.components.push(component);
    this.h += component.h + 8;
};

Toolbar.prototype.addLabel = function(name) {
    var h = 20;
    this.labels.push(new Label(this.x, this.y + this.h, this.w, h, name));
    this.h += h + 8;
};

Toolbar.prototype.addOptions = function(options) {
    var x = this.x + 3;
    var y = this.y + this.h + 2;
    var w = this.w - 6;
    var h = 22;
    
    for (var opt in options) {
        var button = new CheckBox(x, y, w, h, opt);
        this.components.push(button);
        y += h + 5;
        this.h += h + 5;
    }
    
    this.h += 2;
};

Toolbar.prototype.addSwatch = function(name, colour, trigger) {
    var h = 20;
    var button = new SwatchButton(this.x + 5, this.y + this.h, this.w - 10, h, name, colour, trigger);
    this.components.push(button);
    this.h += h + 8;
    return button;
};

Toolbar.prototype.mousePressed = function() {
    this.components.forEach(function(p) { p.mousePressed(); });
};

Toolbar.prototype.mouseReleased = function() {
    this.components.forEach(function(p) { p.mouseReleased(); });
};

Toolbar.prototype.mouseDragged = function() {
    this.components.forEach(function(p) { p.mouseDragged(); });
};
}
/*************************************************
 *      Tabbed Toolbar
 * A container for toolbars
**************************************************/
{
var TabbedToolbar = function(x, y, w) {
    this.x = x;
    this.tx = x;
    this.y = y;
    this.w = 160;
    
    this.toolbars = [];
    this.tabs = [];
    this.currentTab = -1;
    this.components = [];
    this.labels = [];
};

TabbedToolbar.prototype = Object.create(Toolbar.prototype);

TabbedToolbar.prototype.draw = function() {
    // Background
    noStroke();
    fill(200);
    rect(this.x, this.y, this.w, 24);
    
    textFont(sansFont, 16);
    textAlign(LEFT, BASELINE);
    var tx = this.x;
    var ty = this.y + 22;
    
    // Draw tab
    if (this.currentTab !== -1) {
        var tab = this.tabs[this.currentTab];
        fill(250);
        noStroke();
        rect(tab.x, tab.y, tab.w - 2, 26, 3);
    }

    this.components.forEach(function(p) { p.draw(); });
    this.labels.forEach(function(p) { p.draw(); });
};

TabbedToolbar.prototype.changeTab = function(n) {
    this.currentTab = n;
    this.components = this.tabs.concat(this.toolbars[n].components);
    this.labels = this.toolbars[n].labels;
};

TabbedToolbar.prototype.addTab = function(name, toolbar) {
    textFont(sansFont, 16);
    var w = textWidth(name) + 16;
    var index = this.tabs.length;
    var self = this;
    this.tabs.push(
        new GUI_Component(this.tx - 1, this.y + 2, w, 20,
            name, function() {
                self.changeTab(index);
            }
        )
    );
    this.tx += w;
    
    this.toolbars.push(toolbar);
    if (this.currentTab === -1) { this.changeTab(0); }
};
}
}

// Get initial sites using Possion distribution
var possionDiscSampling = function(minDist) {
    // How many points we try before rejecting a point
    var k = 30;
    var maxDist = minDist * 2;
    var minDist2 = minDist * minDist;
    
    var x, y, i, j, p, d;
    // Final array of points that we'll return
    var points = [];
    
    // Points that we use to find neighbours
    var activePoints = [];
    
    // Start at a random point
    x = (0.2 + random() * 0.6) * IMAGE_WIDTH;
    y = (0.2 + random() * 0.6) * IMAGE_HEIGHT;
    points.push([x, y]);
    activePoints.push([x, y]);
    
    var activeIndex, currentPoint, pointAdded, angle, collision;
    var d = 100;
    var w = IMAGE_WIDTH + d;
    var h = IMAGE_HEIGHT + d;
    
    while (activePoints.length) {
        // Pick a random active point
        activeIndex = floor(random() * activePoints.length);
        currentPoint = activePoints[activeIndex];
        pointAdded = false;
        
        for (i = 0; i < k; i++) {
            angle = random() * 360;
            d = random(minDist, maxDist);
            x = currentPoint[0] + cos(angle) * d;
            y = currentPoint[1] + sin(angle) * d;
            
            if (x < -d || x > w || y < -d || y > h) {
                continue;
            }
            
            // Check distance from each other point is > minDist
            collision = false;
            for (j = points.length; j--;) {
                p = points[j];
                if ((x - p[0]) * (x - p[0]) + (y - p[1]) * (y - p[1]) < minDist2) {
                    collision = true;
                    break;
                }
            }
            
            if (!collision) {
                points.push([x, y]);
                activePoints.push([x, y]);
                pointAdded = true;
                break;
            }
        }
        
        // Failed to add point so remove it from the active list
        if (!pointAdded) {
            activePoints.splice(activeIndex, 1);
        }
    }
    
    return points;
};

/*********************************************************
 *       Site Object
 * Represents an initial point on the diagram.
 * Has methods to draw a parabola using the site
 * as a focus and the sweepline as a directrix.
*********************************************************/
{
var sortVertices = function(a, b) { return a.angle - b.angle; };
    
var Site = function(focus, id) {
    this.x = focus[0];
    this.x2 = this.x * this.x;
    this.y = focus[1];
    this.id = id;
    
    // Array of vertices that define the cell
    this.cell = [];
};

Site.prototype.getCellProperties = function() {
    var vertices = this.cell;
    var n = vertices.length;
    this.numVertices = n;
    
    var vertex2 = vertices[n - 1];
    // Find bounding box
    this.minX = vertex2.x;
    this.maxX = vertex2.x;
    this.minY = vertex2.y;
    this.maxY = vertex2.y;
    
    var x = this.x;
    var y = this.y;
    var i, vertex, dx, dy, d;
    
    for (i = 0; i < n; i++) {
        vertex = vertices[i];
        dx = vertex.x - x;
        dy = vertex.y - y;
        d = sqrt(dx * dx + dy * dy);

        vertices[i] = {
            angle: atan2(dy, dx),
            jitter: (random() - 0.5) * d,
            x: vertex.x,
            y: vertex.y,
            d: d,
            dx: dx / d,
            dy: dy / d
        };
        
        if (vertex.x > this.maxX) { this.maxX = vertex.x; }
        else if (vertex.x < this.minX) { this.minX = vertex.x; }
        if (vertex.y > this.maxY) { this.maxY = vertex.y; }
        else if (vertex.y < this.minY) { this.minY = vertex.y; }
    }
    
    if (this.maxX < 0 || this.minX > IMAGE_WIDTH ||
        this.maxY < 0 || this.minY > IMAGE_HEIGHT) {
        this.toRemove = true;
        return;
    }
    
    vertices.sort(sortVertices);
    
    var vertex2 = vertices[n - 1];
    this.area = 0;
    this.deltas = [];
    this.normals = [];
    for (i = 0; i < n; i++) {
        vertex = vertices[i];
        this.area += vertex2.x * vertex.y - vertex.x * vertex2.y;
        
        // Get edge vectors for mouseover calculation
        this.deltas.push([vertex.x - vertex2.x, vertex.y - vertex2.y]);

        // Get normal of edge for shading purposes
        dx = vertex.dx + vertex2.dx;
        dy = vertex.dy + vertex2.dy;
        d = sqrt(dx * dx + dy * dy);
        this.normals.push([-dx, -dy]);
        
        vertex2 = vertex;
    }
};

Site.prototype.updateSize = function() {
    var vertices = this.cell;
    var n = vertices.length;
    var d = 100 - edgeWidth;
    var j = jitter * 0.01;
    var p1 = vertices[n - 1];
    var p2, i, jitterDist, edgeDist, px, py, pz, px2, py2, pz2;
    
    // Coordinates on 3D cylinder
    this.inner = [];
    this.outer = [];
    this.edges1 = [];   // Radial edges
    this.edges2 = [];   // Edges around scale inner
    this.edges3 = [];   // Edges around scale outer

    // Normal of edge face in 3D, one for the two corners
    this.normals1 = [];
    this.normals2 = [];
    this.normals3 = [];     // Average of the two

    for (i = 0; i < n; i++) {
        p2 = vertices[i];
        jitterDist = constrain(d + p2.jitter * j, 0, p2.d);
        edgeDist = min(jitterDist + extrude, p2.d);
        
        // Edge after jitter and shrinking
        p2.x1 = p2.x - p2.dx * jitterDist;
        p2.y1 = p2.y - p2.dy * jitterDist;

        // Edge after extrusion
        p2.x2 = p2.x - p2.dx * edgeDist;
        p2.y2 = p2.y - p2.dy * edgeDist;

        // Find coordinates for this vertex on the 3D cylinder (scale surface)
        px = legR * sin((p2.x2 - IMAGE_WIDTH2) / HalfAngle);
        py = p2.y2 + legY1;
        pz = legZ - sqrt(legR2 - px * px);

        // Find coordinates for this vertex on the 3D cylinder (skin surface)
        px2 = legInner * sin((p2.x1 - IMAGE_WIDTH2) / HalfAngle);
        py2 = p2.y1 + legY1;
        pz2 = legZ - sqrt(legInner2 - px2 * px2);

        this.inner.push([px, py, pz]);
        this.outer.push([px2, py2, pz2]);
        this.edges1.push([px2 - px, py2 - py, pz2 - pz]);
        
        p1 = p2;
    }

    var edge;
    var px3, py3, pz3;
    for (i = 0, j = n - 1; i < n; j = i++) {
        px = this.inner[j][0] - this.inner[i][0];
        py = this.inner[j][1] - this.inner[i][1];
        pz = this.inner[j][2] - this.inner[i][2];
        this.edges2.push([px, py, pz]);

        // Normal of plane in one corner
        edge = this.edges1[i];
        px2 = py * edge[2] - pz * edge[1];
        py2 = pz * edge[0] - px * edge[2];
        pz2 = px * edge[1] - py * edge[0];
        d = 1 / sqrt(px2 * px2 + py2 * py2 + pz2 * pz2);
        px2 *= d;
        py2 *= d;
        pz2 *= d;
        this.normals1.push([px2, py2, pz2]);

        // Normal of plane in other corner
        px = this.outer[j][0] - this.outer[i][0];
        py = this.outer[j][1] - this.outer[i][1];
        pz = this.outer[j][2] - this.outer[i][2];
        this.edges3.push([px, py, pz]);

        edge = this.edges1[j];
        px3 = py * edge[2] - pz * edge[1];
        py3 = pz * edge[0] - px * edge[2];
        pz3 = px * edge[1] - py * edge[0];
        d = 1 / sqrt(px3 * px3 + py3 * py3 + pz3 * pz3);
        px3 *= d;
        py3 *= d;
        pz3 *= d;
        this.normals2.push([px3, py3, pz3]);
        this.normals3.push([(px2 + px3) * 0.5, (py2 + py3) * 0.5, (pz2 + pz3) * 0.5]);
    }

};

Site.prototype.pointInArea = function(px, py) {
    // Bounding box test
    if (this.toRemove || px <= this.minX || px >= this.maxX || py <= this.minY) {
        return false;
    }
    
    var i, d, p;
    for (i = this.cell.length; i--; ) {
        p = this.cell[i];
        d = this.deltas[i];
        if (d[0] * (py - p.y) - d[1] * (px - p.x) < 0) { return false; }
    }

    return true;
};

Site.prototype.pointInArea2 = function(px, py) {
    var c = false;
    var i, p1, p2 = this.cell[0];
    
    for (i = this.cell.length; i--;) {
        p1 = this.cell[i];
        
        if (((p1.y1 > py) !== (p2.y1 > py)) &&
             (px < (p2.x1 - p1.x1) * (py - p1.y1) / (p2.y1 - p1.y1) + p1.x1)) {
           c = !c;
        }
        p2 = p1;
    }
    return c;
};

Site.prototype.pointInScaleSurface = function(px, py) {
    var c = false;
    var i, p1, p2 = this.cell[0];
    
    for (i = this.cell.length; i--;) {
        p1 = this.cell[i];
        
        if (((p1.y2 > py) !== (p2.y2 > py)) &&
             (px < (p2.x2 - p1.x2) * (py - p1.y2) / (p2.y2 - p1.y2) + p1.x2)) {
           c = !c;
        }
        p2 = p1;
    }
    return c;
};

// Find intersection with a ray from (0, 0, 0) to (ix, iy, iz) and any of the cell edges
Site.prototype.findRayIntersectionWithEdges = function(rx, ry, rz) {
    var i, j, t, t1, ix, iy, iz, norm, inner, outer, dot, d;
    var n = this.cell.length;
    var minT = Infinity;

    for (i = 0; i < n; i++) {
        t = minT;
        inner = this.inner[i];

        // Dot first face normal with ray
        norm = this.normals1[i];
        dot = norm[0] * rx + norm[1] * ry + norm[2] * rz;
        if (dot > 0) {
            t1 = (inner[0] * norm[0] + inner[1] * norm[1] + inner[2] * norm[2]) / dot;
            if (t1 > 0) { t = t1; }
        }

        // Dot first face normal with ray
        norm = this.normals2[i];
        dot = norm[0] * rx + norm[1] * ry + norm[2] * rz;
        if (dot > 0) {
            outer = this.outer[i];
            t1 = (outer[0] * norm[0] + outer[1] * norm[1] + outer[2] * norm[2]) / dot;
            if (t1 > 0 && t1 < t) { t = t1; }
        }

        if (t > minT) { continue; }

        // Where ray hits plane
        ix = rx * t;
        iy = ry * t;
        iz = rz * t;

        // Check we are in front of leg
        if (iz > legZ) { continue; }

        // Check we are between scale surface and skin surface
        //d = ix * ix + (iz - legZ) * (iz - legZ);
        //println(d);
        //if (d < legInner2 || d > legR2 + 20) { continue; }
        //if (d < legInner2) { continue; }
        //if (d > legR2) { continue; }

        j = (i + n - 1) % n;

        if (
            // Left
            this.edges1[i][0] * (iy - inner[1]) - this.edges1[i][1] * (ix - inner[0]) - 0.1 < 0 &&
            // Upper 
            this.edges2[i][0] * (iy - inner[1]) - this.edges2[i][1] * (ix - inner[0]) > 0 &&
            // Right
            this.edges1[j][0] * (iy - this.inner[j][1]) - this.edges1[j][1] * (ix - this.inner[j][0]) + 0.1 > 0 &&
            // Lower
            this.edges3[i][0] * (iy - this.outer[j][1]) - this.edges3[i][1] * (ix - this.outer[j][0]) < 0
        ) {
            return this.normals1[i];
        }
    }
};

Site.prototype.draw = function() {
    strokeWeight(3);
    stroke(255, 0, 0);
    fill(255, 0, 0, 128);
    
    beginShape();
    for (var i = this.cell.length; i--;) {
        vertex(this.cell[i].x + IMAGE_X, this.cell[i].y);
    }
    endShape(CLOSE);

    // First point
    strokeWeight(4);
    stroke(0,0,255);
    //point(this.cell[0].x + IMAGE_X, this.cell[0].y);
    //println(this.coords[0]);

/*
    var gx = IMAGE_WIDTH - acos(this.inner[0][0] / legR) * HalfAngle;
    var gy = this.inner[0][1] - legY1;
    var dx = IMAGE_WIDTH - acos((this.inner[0][0] + this.edges2[0][0]) / legR) * HalfAngle;
    var dy = this.inner[0][1] + this.edges2[0][1] - legY1;

    line(gx + IMAGE_X, gy, dx + IMAGE_X, dy);

    var dx = IMAGE_WIDTH - acos((this.inner[0][0] + this.edges1[0][0]) / legInner) * HalfAngle;
    var dy = this.inner[0][1] + this.edges1[0][1] - legY1;
    line(gx + IMAGE_X, gy, dx + IMAGE_X, dy);

    println(this.inner[0]);
    println(this.edges1[0]);
    println(this.edges2[0]);
*/
    stroke(0,255,0);
    point(this.cell[this.cell.length-1].x + IMAGE_X, this.cell[this.cell.length-1].y);

};
}
/*********************************************************
 *          Node object
 * Represents a node in the binary tree
 * Internal nodes represents breakpoint between
 * two arcs in the beachline (left and right).
 * Leaf nodes point to a parabola site and
 * represent an arc in the beachline.
*********************************************************/
{
var Node = function() {
    if (arguments.length === 1) {
        // Make an arc
        this.site = arguments[0];
    } else {
        // Make a breakpoint with the parameters as children
        this.setChild('left', arguments[0]);
        this.setChild('right', arguments[1]);
    }
};

Node.prototype.setChild = function(dir, child) {
    this[dir] = child;
    child.parent = this;
};

// Find the arc to the left of this breakpoint
Node.prototype.getLeftArc = function() {
    var node = this.left;
    while (!node.site) {
        node = node.right;
    }
    return node;
};

Node.prototype.getRightArc = function() {
    var node = this.right;
    while (!node.site) {
        node = node.left;
    }
    return node;
};

Node.prototype.getParent = function(dir) {
    var parent = this.parent;
    var parentLast = this;
    
    while (parent[dir] === parentLast) { 
        if (!parent.parent) { return; }
        parentLast = parent;
        parent = parent.parent; 
    }
    
    return parent;
};

Node.prototype.getY = function(x, y) {
    var d = this.site.y - y;
    var a = 0.5 / d;
    return a * x * x - 2 * a * this.site.x * x + a * this.site.x2 + y + 0.5 * d;
};

Node.prototype.finishEdge = function() {
    var edge = this.edge;
    if (edge) {
        var x = edge.dx < 0 ?
            max(IMAGE_WIDTH, edge.start.x + 100) :
            min(0, edge.start.x - 100);
        
        var p = { x: x, y: edge.getY(x) };
        edge.end = p;
        
        // Add vertex to cell
        edge.siteLeft.cell.push(p);
        edge.siteRight.cell.push(p);
    }
    
    if (!this.left.site) { this.left.finishEdge(); }
    if (!this.right.site) { this.right.finishEdge(); }
};
}
/*********************************************************
 *          Edge object
 * Represents an edge in Voronoi diagram
 * Edges are created whenever a breakpoint is created
 * They can be ended when a breakpoint is removed.
*********************************************************/
{
var Edge = function(start, siteLeft, siteRight) {
    this.start = start;
    this.siteLeft = siteLeft;
    this.siteRight = siteRight;
    
    // Direction vector
    this.dx = this.siteLeft.y - this.siteRight.y;
    this.dy = this.siteRight.x - this.siteLeft.x;

    // Constant term in line equation
    // y - y1 = (dy / dx)(x - x1) rearranged to
    //  dx(y) = dy(y) - dy(x1) + dx(y1)
    this.c = start.x * this.dy - start.y * this.dx;
    
    // TODO: fix for dy = 0
    this.grad = this.dy / this.dx;
};

Edge.prototype.getY = function(x) {
    return this.start.y + this.grad * (x - this.start.x);
};
}
/*********************************************************
 *          Voronoi object
 * Constructs the cells for a Voronoi diagram.
*********************************************************/
{
var sortSites = function(a, b) { return b[1] - a[1]; };
var sortSites2 = function(a, b) { return b.y - a.y; };
var sortEvents = function(a, b) { return b.site.y - a.site.y; };

var Voronoi = function(size, col1, col2, col3) {
    this.col1 = col1;
    this.col2 = col2;
    this.col3 = col3;
    
    this.getSites(size);
    this.compute();
};

Voronoi.prototype.getSites = function(size) {
    var sites = possionDiscSampling(size);
    sites.sort(sortSites);
    
    this.sites = [];
    for (var i = 0, len = sites.length; i < len; i++) {
        // Convert array of coordinates into a site object
        this.sites.push(new Site(sites[i], i));
    }
};

Voronoi.prototype.compute = function() {
    this.root = null;
    this.events = [];
    this.edges = [];
    this.canAddSite = false;
    var i, n = this.sites.length;
    
    // Add each site to the event queue
    for (i = 0; i < n; i++) {
        this.events.push({
            site: this.sites[i],
            newArc: true
        });
        this.sites[i].toRemove = false;
    }
        
    while (this.events.length) {
        var event = this.events.pop();
        this.sweepline = event.site.y;
        
        // Process event
        if (event.newArc) {
            this.insertArc(event.site);
        } else {
            this.removeArc(event);
        }
    }
    
    this.root.finishEdge();
    var len = this.edges.length;
    for (i = 0; i < len; i++) {
        if (this.edges[i].neighbour) {
            this.edges[i].start = this.edges[i].neighbour.end;
        }
    }
    
    // Sort cell vertices
    var minArea = 400 * 400;
    var maxArea = 0;
    var site;
    
    for (i = n; i--;) {
        site = this.sites[i];
        site.getCellProperties();
        if (site.toRemove) {
            //this.sites.splice(i, 1);
            //n--;
            continue;
        }
        
        site.updateSize();
        // Only count cells completely on-screen
        if (site.minX > 0 && site.maxX < IMAGE_WIDTH &&
            site.minY > 0 && site.maxY < IMAGE_HEIGHT) {
            if (site.area > maxArea) {
                maxArea = site.area;
            } else if (site.area < minArea) {
                minArea = site.area;
            }
        }
    }
    
    maxArea = min(maxArea, 4 * minArea);
    var areaNorm = 1 / (maxArea - minArea);
    
    for (i = n; i--;) {
        this.sites[i].areaFactor = (min(maxArea, this.sites[i].area) - minArea) * areaNorm;
    }
    
    //this.sites = [this.sites[20]];

    this.calculateScaleColours();
    this.recalculateScaleSize();
    this.getSiteMap();
};

Voronoi.prototype.draw = function() {
    pushMatrix();
    translate(IMAGE_X, 0);
    
    noStroke();
    colorMode(HSB);
    fill(this.col3.col);
    
    rect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
    colorMode(RGB);
    
    noStroke();
    var i, j, n, site, p1, p2;
    for (i = this.sites.length; i--;) {
        site = this.sites[i];
        
        // Edges of scale
        n = site.cell.length;
        p1 = site.cell[n - 1];
        for (j = 0; j < n; j++) {
            p2 = site.cell[j];
            fill(site.cell[j].shade);
            triangle(p1.x1, p1.y1, p2.x1, p2.y1, site.x, site.y);
            p1 = p2;
        }
        
        // Top of scale
        fill(site.color);
        beginShape();
        for (j = site.cell.length; j--;) {
            vertex(site.cell[j].x2, site.cell[j].y2);
        }
        endShape(CLOSE);
    }
    
    popMatrix();
};

// Add a new arc with its focus at the given site
Voronoi.prototype.insertArc = function(site) {
    // Create a new arc based on this site
    var newArc = new Node(site);
    
    // No need to do anything further with the first parabola
    if (!this.root) {
        this.root = newArc;
        return;
    }
    
    // Find leaf representing the arc above the new parabola
    var existingArc = this.getArcAbovePointX(site.x);
    
    // Split existing arc into two pieces
    var arc1 = new Node(existingArc.site);
    var arc2 = new Node(existingArc.site);
    var breakpoint = new Node(newArc, arc2);

    // Convert existing arc node to a breakpoint
    existingArc.left = arc1;
    existingArc.right = breakpoint;
    arc1.parent = existingArc;
    breakpoint.parent = existingArc;
    
    this.removeCircleEvent(existingArc);
    
    // Add a new edge
    var p = { x: site.x, y: existingArc.getY(site.x, this.sweepline) };
    var leftEdge = new Edge(p, existingArc.site, site);
    var rightEdge = new Edge(p, site, existingArc.site);
    
    leftEdge.neighbour = rightEdge;
    this.edges.push(leftEdge);
    existingArc.edge = rightEdge;
    breakpoint.edge = leftEdge;
    
    existingArc.site = false;
    
    // Check for new circle events
    this.checkForCircleEvent(arc1);
    this.checkForCircleEvent(arc2);
};

// Search binary tree for parabola covering given x-position
Voronoi.prototype.getArcAbovePointX = function(x) {
    var node = this.root;
    var p1, p2, d1, d2, a1, a2, a, b, c, discriminant, testX, x1, x2;
    
    // While we are not at a leaf in the tree (representing an arc).
    while (!node.site) {
        p1 = node.getLeftArc().site;
        p2 = node.getRightArc().site;
    
        // Coeffiecients for parabola equation in standard form
        d1 = p1.y - this.sweepline;
        d2 = p2.y - this.sweepline;
        
        a1 = 0.5 / d1;
        a2 = 0.5 / d2;
        
        a = a1 - a2;
        b = 2 * (a2 * p2.x - a1 * p1.x);
        c = a1 * p1.x2 - a2 * p2.x2 + 0.5 * (d1 - d2);
    
        discriminant = b * b - 4 * a * c;
        a *= 2;
        x1 = (-b + sqrt(discriminant)) / a;
        x2 = (-b - sqrt(discriminant)) / a;
        testX = p1.y > p2.y ? max(x1, x2) : min(x1, x2);
        node = testX > x ? node.left : node.right;
    }
    
    return node;
};

Voronoi.prototype.removeArc = function(event) {
    var arc = event.arc;
    var leftBreak = arc.getParent('left');
    var rightBreak = arc.getParent('right');
    var leftArc = leftBreak.getLeftArc();
    var rightArc = rightBreak.getRightArc();

    // Get point where the arc disappears
    var x = event.site.x;
    var p = { x: x, y: arc.getY(x, this.sweepline) };
    
    // Add a vertex to each of the cells
    arc.site.cell.push(p);
    leftArc.site.cell.push(p);
    rightArc.site.cell.push(p);
    
    // Add an end point to the two breakpoints that have joined

    leftBreak.edge.end = p;
    rightBreak.edge.end = p;
    
    this.removeCircleEvent(leftArc);
    this.removeCircleEvent(rightArc);
    
    // Find the higher breakpoint
    var higher;
    var parent = arc;
    while (parent !== this.root){
        parent = parent.parent;
        if (parent === leftBreak) { higher = leftBreak; }
        if (parent === rightBreak) { higher = rightBreak; }
    }
    
    higher.edge = new Edge(p, rightArc.site, leftArc.site);
    this.edges.push(higher.edge);

    // Remove leaf from tree and reorder
    var parent = arc.parent;
    var gparent = parent.parent;
    var d1, d2;
    
    if (parent.left === arc) {
        d2 = 'right';
        d1 = gparent.left === parent ? 'left' : 'right';
    } else {
        d2 = 'left';
        d1 = gparent.left === parent ? 'left' : 'right';
    }
    
    // Set new parents
    gparent.setChild(d1, parent[d2]);
    
    this.checkForCircleEvent(leftArc);
    this.checkForCircleEvent(rightArc);
};

Voronoi.prototype.checkForCircleEvent = function(b) {
    var leftBreak = b.getParent('left');
    var rightBreak = b.getParent('right');
    
    if (!leftBreak || !rightBreak) { return; }
    
    var a = leftBreak.getLeftArc();
    var c = rightBreak.getRightArc();
    
    if (!a || !c || a.site === c.site) { return; }
    
    //println(a + " " + b + " " + c);
    
    // Check whether edges of breakpoints intersect
    var e1 = leftBreak.edge;
    var e2 = rightBreak.edge;
    var den = e1.dx * e2.dy - e1.dy * e2.dx;
    
    // Lines are parallel
    if (!den) { return; }
    
    // Center circle at intersection point
    var ix = (e2.c * e1.dx - e1.c * e2.dx) / den;
    var iy = (e2.c * e1.dy - e1.c * e2.dy) / den;
    
    // Test whether edge is in the wrong direction
    if ((ix - e1.start.x) * e1.dx > 0 || (iy - e1.start.y) * e1.dy > 0 ||
        (ix - e2.start.x) * e2.dx > 0 || (iy - e2.start.y) * e2.dy > 0) {
        return;
    }

    var radius = dist(ix, iy, a.site.x, a.site.y);
    
    //println(radius);
    //println(ix + " " + iy);
    
    // Convert center to lower edge
    iy += radius;
    
    // Ignore circle if the sweep line has passed
    if (iy <= this.sweepline) { return; }
    
    // Create new event
    var event = {
        site: { x: ix, y: iy },
        radius: radius,
        arc: b
    };
    
    b.circleEvent = event;
    this.events.push(event);
    this.events.sort(sortEvents);
};

// Remove a circle event associated with the given arc
Voronoi.prototype.removeCircleEvent = function(arc) {
    //println("Remove circle event " + arc);
    if (arc.circleEvent) {
        //println("Removed");
        var index = this.events.indexOf(arc.circleEvent);
        if (index > -1) { this.events.splice(index, 1); }
        arc.circleEvent = null;
    }
};

// Map (x, y) coordinate to site id
Voronoi.prototype.getSiteMap = function() {
    this.siteMap = [];
    var x, y, i;
    var sites = this.sites.slice();
    var n = sites.length;
    var oldSite = sites[n - 1];

    for (y = 0; y < IMAGE_HEIGHT; y++) {
        for (x = 0; x < IMAGE_WIDTH; x++) {
            // Most likely its the same site as before
            if (oldSite.pointInArea(x, y)) {
                this.siteMap.push(oldSite);
                continue;
            }
            
            for (i = n; i--;) {
                if (sites[i] !== oldSite &&
                    sites[i].pointInArea(x, y)) {
                    oldSite = sites[i];
                    this.siteMap.push(sites[i]);
                }
            }
        }
        
        // Remove any sites we've moved past to save checking later
        for (i = n; i--;) {
            if (y > sites[i].maxY) {
                sites.splice(i, 1);
                n--;
            }
        }
    }
};

Voronoi.prototype.getPointInArea = function(x, y) {
    var site = this.siteMap[round(x) + round(y) * IMAGE_WIDTH];
    if (site && site.pointInArea2(x, y)) {
        return site;
    }
};

Voronoi.prototype.getPointInScaleSurface = function(x, y) {
    var site = this.siteMap[round(x) + round(y) * IMAGE_WIDTH];
    if (site && site.pointInScaleSurface(x, y)) {
        return site;
    }
};

Voronoi.prototype.recalculateScaleSize = function() {
    for (var i = this.sites.length; i--;) {
        this.sites[i].updateSize();
    }
};

Voronoi.prototype.calculateScaleColours = function() {
    var c1 = this.col1.col;
    var c2 = this.col2.col;
    var i, j, site;
    
    for (i = this.sites.length; i--;) {
        site = this.sites[i];
        if (!site.toRemove) {
            site.color = lerpColor(c1, c2, site.areaFactor);
            site.r = red(site.color);
            site.g = green(site.color);
            site.b = blue(site.color);
            
            for (j = site.cell.length; j--;) {
                site.cell[j].shade = lerpColor(site.color, BLACK, 0.5 - 0.2 * site.normals[j][1]);
            }
        }
    }
};

Voronoi.prototype.mouseOver = function() {
    // Only calculate if the mouse has moved
    if (this.mx !== mouseX || this.my !== mouseY) {
        this.mx = mouseX;
        this.my = mouseY;
        var x = mouseX - IMAGE_X;
        var y = mouseY;
        // Check mouse is over image, may need more tests
        if (x > 0 && x < IMAGE_WIDTH) {
            this.selectedSite = this.siteMap[x + y * IMAGE_WIDTH];
            this.canAddSite = dist(x, y, this.selectedSite.x, this.selectedSite.y) > MIN_SITE_DIST;
        }
    }
};

Voronoi.prototype.deleteSite = function() {
    if (this.selectedSite) {
        this.sites.splice(this.sites.indexOf(this.selectedSite), 1);
        
        // Clear site data so we can recalculate it
        for (var i = this.sites.length; i--;) {
            this.sites[i].cell = [];
            this.sites[i].vertices = [];
        }
        
        this.mx = -1;
        this.my = -1;
        this.compute();
        this.selectedSite = false;
        return true;
    }
};

Voronoi.prototype.addSite = function(x, y) {
    if (this.canAddSite) {
        // Clear site data so we can recalculate it
        for (var i = this.sites.length; i--;) {
            this.sites[i].cell = [];
            this.sites[i].vertices = [];
        }
        
        this.sites.push(new Site([x, y], this.sites.length));
        this.sites.sort(sortSites2);
        this.compute();
        return true;
    }
};
}
/*********************************************************
 *      Create object
*********************************************************/

var voronoi;
var scaleSwatch1, scaleSwatch2, skinSwatch;

// Create toolbars
{
var mainToolbar = new Toolbar(0, 22, 160);
var skinToolbar = new Toolbar(0, 22, 160);
var scaleToolbar = new Toolbar(0, 22, 160);
var toolbar = new TabbedToolbar(0, 0, 160);
toolbar.addTab('Model', mainToolbar);
toolbar.addTab('Skin', skinToolbar);
toolbar.addTab('Scale', scaleToolbar);

// Main toolbar
mainToolbar.add(Slider, {
    name: 'Scale size',
    min: 50,
    now: edgeWidth,
    max: 100,
    trigger: function() {
        if (voronoi && edgeWidth !== this.val) {
            edgeWidth = this.val;
            voronoi.recalculateScaleSize();
        }
    }
});
mainToolbar.add(Slider, {
    name: 'Jitter',
    min: 0,
    now: jitter,
    max: 100,
    trigger: function() {
        if (voronoi && jitter !== this.val) {
            jitter = this.val;
            voronoi.recalculateScaleSize();
        }
    }
});
mainToolbar.add(Slider, {
    name: 'Extrude',
    min: 0,
    now: extrude,
    max: 30,
    trigger: function() {
        if (voronoi && extrude !== this.val) {
            extrude = this.val;
            voronoi.recalculateScaleSize();
        }
    }
});

mainToolbar.add(Button, {
    name: 'Add site mode',
    trigger: function() { mode = 'Add'; }
});
mainToolbar.add(Button, {
    name: 'Delete site mode',
    trigger: function() { mode = 'Delete'; }
});
mainToolbar.add(Button, {
    name: 'New scale pattern',
    trigger: function() {
        voronoi = new Voronoi(
            50, scaleSwatch1, scaleSwatch2, skinSwatch
        );
    }
});

var updateColors = function() {
    colorMode(HSB);
    this.col = color(
        this.hue * 0xFF,
        this.sat * 0xFF,
        this.bri * 0xFF
    );
    colorMode(RGB);
    
    if (voronoi) {
        voronoi.calculateScaleColours();
    }
};

// Color toolbar
skinToolbar.addSwatch('Color', color(100, 85, 45), updateColors);
    
skinSwatch = skinToolbar.components[0];
skinToolbar.add(Slider, {
    name: 'Brightness',
    now: 100,
    max: 255,
    trigger: function() {
        skinSwatch.bri = this.val / 255;
        skinSwatch.setColor();
        skinSwatch.updateFunction();
    }
});

scaleSwatch1 = scaleToolbar.addSwatch(
    'Color 1', color(210, 190, 90), updateColors);
scaleToolbar.add(Slider, {
    name: 'Brightness',
    now: 180,
    max: 255,
    trigger: function() {
        scaleSwatch1.bri = this.val / 255;
        scaleSwatch1.setColor();
        scaleSwatch1.updateFunction();
    }
});

scaleSwatch2 = scaleToolbar.addSwatch(
    'Color 2', color(80, 120, 140), updateColors);
scaleToolbar.add(Slider, {
    name: 'Brightness',
    now: 140,
    max: 255,
    trigger: function() {
        scaleSwatch2.bri = this.val / 255;
        scaleSwatch2.setColor();
        scaleSwatch2.updateFunction();
    }
});

var closeButton = new Button(10, 160, 140, 22, {
    name: 'Close',
    trigger: function() { mode = 'model'; }
});

var modeInfo = {
    Delete: "Click on a scale to remove it.",
    Add: "Click on the image to add a new scale. New scale sites cannot be too close to existing sites."
};

}

/*********************************************************
 *      Create initial Voronoi diagram
**********************************************************/

voronoi = new Voronoi(50, scaleSwatch1, scaleSwatch2, skinSwatch);

/*********************************************************
 *      PixelGrid
 *  Where we do the ray-tracing 
*********************************************************/

var i9 = 1 / 9;
var PixelGrid = {
    // Set up pixel grid with width and height (w, h),
    // centered on (0, y, z), perpendicular to the vector
    // from (0, 0, 0) to (0, y, z)
    x: 0,

    setup: function(y, z, w, h) {
        this.y = y;
        this.z = z;
        
        this.w = w;
        this.h = h;
        var w2 = w / 2;
        var h2 = h / 2;

        var d = sqrt(y * y + z * z);
        this.dy = z / d;
        this.dz = -y / d;
        
        // Vector to top left corner
        this.x1 = this.x - w2;
        this.y1 = this.y - h2 * this.dy;
        this.z1 = this.z - h2 * this.dz;
    },
    
    reset: function() {
        // How far through the ray trace are we
        this.rayTraceY = 0;
        
        // What pixels are we working with
        // Start by shifting everything over
        this.index = IMAGE_X * 4;
        this.pixelY = 0;
        this.pix = new Array(width * height * 4);

        for (var i = this.pix.length; i--;) {
            this.pix[i] = 0;
        }
        
        fill(0);
        noStroke();
        rect(IMAGE_X, 0, IMAGE_WIDTH, height);
    },
    
    rayTrace: function() {
        var imageDX = (IMAGE_WIDTH - this.w) / 2;

        // Make variables local
        var w = this.w;
        var h = this.h;
        var py = this.pixelY;
        var index = this.index;
        var x1 = this.x1;
        
        var skinR = red(skinSwatch.col);
        var skinG = green(skinSwatch.col);
        var skinB = blue(skinSwatch.col);
        
        // Do we need to write this value to two lines of pixels
        var doubleY;
        var pixelDY = width * 4;
        
        var x, y,               // Pixel in grid
            rx, ry, rz,         // Ray from camera to pixel
            y2, z2,             // Squared value for ry and rz
            ix, iy, iz,         // Intersection of ray with leg
            nx, ny, nz,         // Normal at intersection
            gx, gy, gx2, gy2;   // Where on the Voronoi diagram intersection maps to

        var foundHit, miss, diffusion, _specular, shine, scaleZ, li, site, site2, dot, det, t, d, d2, r, g, b;
        

        // Test intersection of ray with each edge
        var i, j, t1, norm, norm2, inner, outer, ix2, iy2, iz2, rx2, ry2, rz2, dot2, hitSite, n;
        var minT = Infinity;

        var testSiteForIntersections = function(site) {
            if (!site) { return; }
            n = site.cell.length;
            j = n - 1;
            minT = Infinity;

            for (i = 0; i < n; j = i++) {
                inner = site.inner[i];
                outer = site.outer[i];
                norm2 = site.normals3[i];

                // Dot first face normal with ray
                norm = site.normals1[i];
                dot2 = norm[0] * rx + norm[1] * ry + norm[2] * rz;
                if (dot2 > 0) {
                    t = (inner[0] * norm[0] + inner[1] * norm[1] + inner[2] * norm[2]) / dot2;

                    if (t > 0 && t < minT) {
                         // Check we are in front of leg (iz2 = rz * t;)
                        if (rz * t < legZ) {
                            // Where ray hits plane
                            ix2 = rx * t;
                            iy2 = ry * t;

                            if (
                                // Left
                                site.edges1[i][0] * (iy2 - inner[1]) - site.edges1[i][1] * (ix2 - inner[0]) < 1e-5 &&
                                // Upper 
                                site.edges2[i][0] * (iy2 - inner[1]) - site.edges2[i][1] * (ix2 - inner[0]) > -1e-5 &&
                                // Right
                                site.edges1[j][0] * (iy2 - site.inner[j][1]) - site.edges1[j][1] * (ix2 - site.inner[j][0]) > -1e-5 &&
                                // Lower
                                site.edges3[i][0] * (iy2 - outer[1]) - site.edges3[i][1] * (ix2 - outer[0]) < 1e-5
                            ) {
                                minT = t;
                                hitSite = site;
                                nx = -norm2[0];
                                ny = norm2[1];
                                nz = -norm2[2];
                            }

                        }
                    }
                }

                // Dot second face normal with ray
                norm = site.normals2[i];
                dot2 = norm[0] * rx + norm[1] * ry + norm[2] * rz;
                if (dot2 > 0) {
                    t = (outer[0] * norm[0] + outer[1] * norm[1] + outer[2] * norm[2]) / dot2;

                    if (t > 0 && t < minT) {
                        // Check we are in front of leg (iz2 = rz * t;)
                        if (rz * t < legZ) {
                            // Where ray hits plane
                            ix2 = rx * t;
                            iy2 = ry * t;

                            if (
                                /*
                                // Left
                                site.edges1[i][0] * (iy2 - inner[1]) - site.edges1[i][1] * (ix2 - inner[0]) < 1e-5 &&
                                // Upper 
                                site.edges2[i][0] * (iy2 - inner[1]) - site.edges2[i][1] * (ix2 - inner[0]) > -1e-5 &&
                                // Right
                                site.edges1[j][0] * (iy2 - site.outer[j][1]) - site.edges1[j][1] * (ix2 - site.outer[j][0]) > -1e-5 &&
                                // Lower

                                site.edges3[i][0] * (iy2 - site.outer[i][1]) - site.edges3[i][1] * (ix2 - site.outer[i][0]) < 1e-5 */
                                // Left
                                site.edges1[i][0] * (iy2 - inner[1]) - site.edges1[i][1] * (ix2 - inner[0]) < 1e-5 &&
                                // Upper 
                                site.edges2[i][0] * (iy2 - inner[1]) - site.edges2[i][1] * (ix2 - inner[0]) > -1e-5 &&
                                // Right
                                site.edges1[j][0] * (iy2 - site.inner[j][1]) - site.edges1[j][1] * (ix2 - site.inner[j][0]) > -1e-5 &&
                                // Lower
                                site.edges3[i][0] * (iy2 - outer[1]) - site.edges3[i][1] * (ix2 - outer[0]) < 1e-5
                              
                            ) {
                                minT = t;
                                hitSite = site;
                                nx = -norm2[0];
                                ny = norm2[1];
                                nz = -norm2[2];
                            }

                        }
                    }
                }
            }                

            if (minT !== Infinity) {
                site = hitSite;
                return true;
            }
        };

        var m = millis();
        
        // Draw pixels
        loadPixels();
        var p = imageData.data;
        var pix = this.pix;         // Proxy for p which stores floating point numbers

        for (y = this.rayTraceY; y <= h; y += 0.5) {
            ry = this.y1 + y * this.dy;
            rz = this.z1 + y * this.dz;
            y2 = ry * ry;
            z2 = rz * rz;

            // Ratio of distance to the center of the leg to the
            // distance from camera to pixel grid
            scaleZ = legZ / rz;

            for (x = 0; x <= w; x += 0.5) {
                foundHit = false;
                miss = false;
                shine = 0;

                r = 0;
                g = 0;
                b = 0;
                
                // Ray trace with a ray from [0, 0, 0] to [px, py, pz]
                rx = x1 + x;
                
                // Test for topcap
                // Find intersection with plane at legY1
                
                // How many ray lengths to reach the plane
                ny = legY1 / ry;
                
                // Ray hitting point (ix, iy, iz)
                ix = rx * ny;
                iz = rz * ny;

                // Distance from intersection to center of leg
                // Since legX = 0, we can ix as the distance in x
                nz = iz - legZ;
                d = ix * ix + nz * nz;

                // Hits top of leg
                if (d < legR2) {
                    iy = legY1;

                    foundHit = true;
                    
                    if (d < legEmpty2) {
                        // Inside leg
                        // TODO: Convert from intersection on top to intersection with inner side
                        nx = -ix / legEmpty;
                        nz = -sqrt(1 - nx * nx);
                        li = i9 * (0.1 + 0.4 * max(0, (nx * lightDX + nz * lightDZ)));
                        r = 100;
                        g = 85;
                        b = 45;
                    } else if (d < legInner2) {
                        // Top of leg skin
                        nx = 0;
                        ny = 1;
                        nz = 0;
                        r = 100;
                        g = 85 ;
                        b = 45;
                    } else {
                        // Where along the grid are we?
                        gx = IMAGE_WIDTH2 - atan(ix / nz) * HalfAngle;
                        site = voronoi.getPointInArea(gx, 0);

                        if (site) {
                            // Top of scales
                            nx = 0;
                            ny = -1;
                            nz = 0;
                            r = site.r;
                            g = site.g;
                            b = site.b;
                        } else if (nz < 0) {
                            // Misses scales at top of leg, so hits edges or skin instead                            
                            site = voronoi.siteMap[round(gx)];

                            if (site) {
                                n = site.findRayIntersectionWithEdges(ix, iy, iz);
                                if (n) {
                                    // Hit edge
                                    r = site.r * 0.85;
                                    g = site.g * 0.85;
                                    b = site.b * 0.85;
                                    nx = -n[0];
                                    ny = n[1];
                                    nz = -n[2];

                                    shine = 10;
                                    foundHit = true;
                                } else if (abs(rx * scaleZ) < legInner) {
                                    // Hit skin
                                    // Calculate normal
                                    nz = iz - legZ;
                                    d = sqrt(ix * ix + nz * nz);
                                    nx = ix / d;
                                    nz /= d;

                                    r = skinR;
                                    g = skinG;
                                    b = skinB;
                                    shine = 2;
                                    foundHit = true;
                                } else {
                                    // Gap in scales at side of leg
                                    miss = true;
                                }
                            }
                        } else {
                            // Gap in scales behind leg
                            miss = true;
                        }
                    }
                }
                
                // Bounding-box test to save some calculations
                if (!miss && !foundHit) {
                    // Does the ray hit a rectangle of width 2r in front of the cylinder
                    ix = rx * scaleZ;
                    
                    // If intersection with plane wider than leg, then miss
                    miss = ix < legX1 || ix > legX2 || ry * scaleZ < legY1;
                }
                
                if (!miss) {
                    if (!foundHit) {
                        // Test for intersection with outer cylinder (scales)

                        // Distance squared from center of leg to start of ray
                        d2 = rx * rx + z2;
                        dot = z2 * legZ2 / d2;
                        det = dot + legDZ;

                        // Might miss to the left and right of the cylinder
                        if (det > 0) {
                            // Length of 3D vector to pixel grid
                            d = sqrt(d2);
            
                            // Distance along ray as unit vector
                            t = (sqrt(dot) - sqrt(det)) / d;
            
                            // Coordinates of intersection of ray with scale cylinder
                            ix = rx * t;
                            iy = ry * t;
                            iz = rz * t;

                            // Can hit up to 16 lower on the skin
                            if (iy < legY2 + 16) {
                                if (iy < legY2) {
                                    // Map to position on 2D grid
                                    gx = IMAGE_WIDTH - acos(ix / legR) * HalfAngle;
                                    gy = iy - legY1;

                                    // Test for hitting voronoi cell
                                    site = voronoi.getPointInScaleSurface(gx, gy);
                                } else {
                                    site = false;
                                }

                                if (site) {
                                    // Hit a scale
                                    // Calculate normal
                                    nz = iz - legZ;
                                    d = sqrt(ix * ix + nz * nz);
                                    nx = ix / d;
                                    ny = 0;
                                    nz /= d;

                                    // Set color
                                    r = site.r;
                                    g = site.g;
                                    b = site.b;
                                    shine = 50;
                                } else {
                                    // Miss scale surface so test for intersection with edge of scale
                                    // Find site/cell that ray passes through
                                    site = voronoi.siteMap[round(gx) + round(gy) * IMAGE_WIDTH];

                                    // Should always be a site, but test just in case
                                    if (site) {
                                        rx2 = ix;
                                        ry2 = iy;
                                        rz2 = iz;

                                        t = testSiteForIntersections(site);

                                        // TODO: test second site with ray
                                        if (t) {
                                            // Hit edge
                                            r = site.r * 0.85;
                                            g = site.g * 0.85;
                                            b = site.b * 0.85;
                                            shine = 10;
                                        } else {
                                            // Hit skin
                                            det = dot + legIDZ;

                                            if (det > 0) {
                                                // Distance along ray as unit vector
                                                t = (sqrt(dot) - sqrt(det)) / d;
                                
                                                iy = ry * t;
                                                if (iy < legY2) {
                                                    // Calculate normal
                                                    nz = iz - legZ;
                                                    d = sqrt(ix * ix + nz * nz);
                                                    nx = ix / d;
                                                    nz /= d;

                                                    r = skinR;
                                                    g = skinG;
                                                    b = skinB;
                                                    shine = 2;
                                                }
                                            } else {
                                                // Miss cylinder of skin
                                                miss = true;

                                                // Calculate intersection with plane in line with legZ
                                                ix = rx * scaleZ;
                                                iy = ry * scaleZ;

                                                gx = ix < 0 ? 0 : IMAGE_WIDTH - 1;
                                                gy = iy - legY1;

                                                if (iy < legY2) {
                                                    // TODO: need to test other sites that ray may pass through
                                                    site = voronoi.siteMap[gx + round(gy) * IMAGE_WIDTH];
                                                    if (site) {
                                                        rx2 = ix;
                                                        ry2 = iy;
                                                        rz2 = legZ;
                                                        t = testSiteForIntersections(site);
                                                        if (t) {
                                                            // Hit edge
                                                            r = site.r * 0.85;
                                                            g = site.g * 0.85;
                                                            b = site.b * 0.85;
                                                            shine = 10;
                                                            miss = false;
                                                        }
                                                    }
                                                } 
                                            }    
                                        }
                                    }
                                }
                            }
                        } else {
                            // Off the bottom of the leg
                            //r = 255;
                            miss = true;
                        }
                    }

                    // If we've hit something, calculate light and shading
                    if (!miss) {
                        // Diffuse lighting: dot with light vector
                        diffusion = (nx * lightDX + ny * lightDY + nz * lightDZ);
                        li = 0.5 + 0.5 * diffusion;

                        // Reflection
                        diffusion *= 2;
                        // Vector of reflection
                        nx = diffusion * nx - lightDX;
                        ny = diffusion * ny - lightDY;
                        nz = diffusion * nz - lightDZ;

                        // Dot with vector towards camera (-ix, -iy, -iz)
                        _specular = ix * nx + iy * ny + iz * nz;
                        _specular /= -sqrt(ix * ix + iy * iy + iz * iz);

                        if (_specular > 0) {
                            li += 0.15 * pow(_specular, shine);
                        }

                        // Intensity based on distance from light source
                        d = (ix - lightX) * (ix - lightX) +
                            (iy - lightY) * (iy - lightY) +
                            (iz - lightZ) * (iz - lightZ);
                        //d = 90000;
                        li *= i9 * lightIntensity / d;

                        r *= li;
                        g *= li;
                        b *= li;
                    }

                }

                /****************************
                 * Write pixels
                 * Each pixel value is the sum of 9 points
                 * The points at the edges are shared with
                 * neighbouring pixels
                *****************************/
                
                // Store pixel value in pix so we can save floating point numbers
                if (!miss) {
                    pix[index] += r;
                    pix[index + 1] += g;
                    pix[index + 2] += b;
                    p[index] = pix[index];
                    p[index + 1] = pix[index + 1];
                    p[index + 2] = pix[index + 2];
                    
                    // Write in the pixel below
                    if (doubleY) {
                        pix[index + pixelDY] += r;
                        pix[index + pixelDY + 1] += g;
                        pix[index + pixelDY + 2] += b;
                        p[index + pixelDY] = pix[index];
                        p[index + pixelDY + 1] = pix[index + pixelDY + 1];
                        p[index + pixelDY + 2] = pix[index + pixelDY + 2];
                    }
                }
                
                // Also write in the next pixel along if this isn't the first or last pixel and x is a whole number
                if (x && x !== w && x === (x | 0)) {
                    // Move pixel right
                    index += 4;
                    if (!miss) {
                        pix[index] += r;
                        pix[index + 1] += g;
                        pix[index + 2] += b;
                        p[index] = pix[index];
                        p[index + 1] = pix[index + 1];
                        p[index + 2] = pix[index + 2];
                        
                        // Write in below right
                        if (doubleY) {
                            pix[index + pixelDY] += r;
                            pix[index + pixelDY + 1] += g;
                            pix[index + pixelDY + 2] += b;
                            p[index + pixelDY] = pix[index];
                            p[index + pixelDY + 1] = pix[index + pixelDY + 1];
                            p[index + pixelDY + 2] = pix[index + pixelDY + 2];
                        }
                    }
                }
            }
            
            // When do we need to skip a line
            doubleY = y && y !== h && y === (y | 0);
            if (doubleY) { py++; }

            index = IMAGE_X + imageDX + py * width << 2;
            
            if (!doubleY && millis() - m > MAX_TIME) {
                this.pixelY = py;
                this.index = index;
                break;
            }
        }
     
        updatePixels();
        this.rayTraceY = y + 0.5;
    }
};

PixelGrid.setup(320, 1200, IMAGE_HEIGHT * 0.6, IMAGE_HEIGHT);

mainToolbar.add(Button, {
    name: 'Render in 3D',
    trigger: function() {
        mode = '3D';
        PixelGrid.reset();
        noStroke();
        fill(0);
        rect(IMAGE_X, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
    }
});

toolbar.changeTab(0);

/*********************************************************
 *      Main loop
**********************************************************/

draw = function() {
    if (!swatch) { swatch = createSwatch(SWATCHSIZE, 0.8); }
    
    if (mode !== '3D') {
        background(250);
        voronoi.draw();
        //image(imageOfScales, IMAGE_X, 0);
    }
    
    // Toolbar region
    noStroke();
    fill(250);
    rect(0, 0, IMAGE_X, height);
    rect(IMAGE_X + IMAGE_WIDTH, 0, width, height);
    
    if (mode === 'model') {
        toolbar.draw();
    } else if (mode === '3D') {
        PixelGrid.rayTrace();
        
        // Info
        fill(20);
        textSize(18);
        textAlign(CENTER, TOP);
        text("3D Render", 80, 8);
        
        textSize(14);
        textAlign(LEFT, TOP);
        text("Rendering dinosaur leg in 3D. This may take some time...", 8, 40, IMAGE_X - 16, 100);
        
        closeButton.draw();
    } else {
        var i, n = voronoi.sites.length;
        voronoi.mouseOver();
        
        if (mode === 'Delete') {
            if (voronoi.selectedSite) {
                voronoi.selectedSite.draw();
            }
            stroke(255, 0, 0);
            strokeWeight(6);
        } else if (mode === 'Add') {
            strokeWeight(MIN_SITE_DIST);
            stroke(255, 255, 255, 100);
        }
        
        for (i = n; i--;) {
            point(voronoi.sites[i].x + IMAGE_X, voronoi.sites[i].y);
        }
        
        if (mode === 'Add') {
            // Show where new site is going to be add
            // Site is red if it's too close to another site
            stroke(voronoi.canAddSite ?
                color(255, 255, 255, 100) :
                color(255, 0, 0, 150));
            if (mouseX > IMAGE_X) {
                point(mouseX, mouseY);
            }
        }
        
        // Toolbar region
        noStroke();
        fill(250);
        rect(0, 0, IMAGE_X, height);
        rect(IMAGE_X + IMAGE_WIDTH, 0, width, height);
        
        // Info
        fill(20);
        textSize(18);
        textAlign(CENTER, TOP);
        text(mode + " Mode", 80, 8);
        
        textSize(14);
        textAlign(LEFT, TOP);
        text("There are currently " + n + " scales.", 8, 40, IMAGE_X - 16, 100);
        text(modeInfo[mode], 8, 75, IMAGE_X - 16, 100);
        
        closeButton.draw();
    }
};

/**************************************
 *  Event handling
***************************************/
{
mousePressed = function() {
    if (mode === 'model') {
        toolbar.mousePressed();
    } else {
        closeButton.mousePressed();
    }
};

mouseDragged = function() {
    toolbar.mouseDragged();
};

mouseReleased = function() {
    if (mode === 'model') {
        toolbar.mouseReleased();
    } else {
        closeButton.mouseReleased();
        if ((mode === 'Delete' && voronoi.deleteSite()) ||
            (mode === 'Add' && voronoi.addSite(mouseX - IMAGE_X, mouseY))) {
        }
    }
};

mouseOut = function() {
    toolbar.mouseReleased();
};
}
